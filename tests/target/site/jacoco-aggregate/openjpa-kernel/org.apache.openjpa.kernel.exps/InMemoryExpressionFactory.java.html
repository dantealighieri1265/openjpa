<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>InMemoryExpressionFactory.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-kernel</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.kernel.exps</a> &gt; <span class="el_source">InMemoryExpressionFactory.java</span></div><h1>InMemoryExpressionFactory.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.kernel.exps;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Objects;
import java.util.Set;

import org.apache.openjpa.kernel.Extent;
import org.apache.openjpa.kernel.StoreContext;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.meta.ClassMetaData;
import org.apache.openjpa.util.ImplHelper;
import org.apache.openjpa.util.UnsupportedException;
import org.apache.openjpa.util.UserException;

/**
 * Expression factory implementation that can be used to execute queries
 * in memory.
 *
 * @author Abe White
 */
<span class="nc" id="L48">public class InMemoryExpressionFactory</span>
    implements ExpressionFactory {

<span class="nc" id="L51">    private static final Value NULL = new Null();</span>
<span class="nc" id="L52">    private static final Object UNIQUE = new Object();</span>

    // list of unbound variables in this query
<span class="nc" id="L55">    private List&lt;UnboundVariable&gt; _unbounds = null;</span>

    /**
     * Tests whether the given candidate matches the given type and this
     * expression.
     */
    public boolean matches(QueryExpressions exps, ClassMetaData type,
        boolean subs, Object candidate, StoreContext ctx, Object[] params) {
        // ignore candidates of the wrong type
<span class="nc bnc" id="L64" title="All 2 branches missed.">        if (candidate == null)</span>
<span class="nc" id="L65">            return false;</span>
<span class="nc bnc" id="L66" title="All 4 branches missed.">        if (!subs &amp;&amp; candidate.getClass() != type.getDescribedType())</span>
<span class="nc" id="L67">            return false;</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">        if (subs &amp;&amp; !type.getDescribedType().isAssignableFrom</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            (candidate.getClass()))</span>
<span class="nc" id="L70">            return false;</span>

        // evaluate the expression for all possible combinations of values
        // of the unbound variables; the candidate matches if any combination
        // matches
<span class="nc" id="L75">        return matches((Exp) exps.filter, candidate, ctx, params, 0);</span>
    }

    /**
     * Recursive method to evaluate the expression for all possible
     * combinations of unbound variables. This method simulates a sequence
     * of embedded procedural loops over the extents of all variables in the
     * unbounds list.
     */
    protected boolean matches(Exp exp, Object candidate, StoreContext ctx,
        Object[] params, int i) {
        // base case: all variables have been aliased; evaluate for current
        // values
<span class="nc bnc" id="L88" title="All 4 branches missed.">        if (_unbounds == null || i == _unbounds.size())</span>
<span class="nc" id="L89">            return exp.evaluate(candidate, candidate, ctx, params);</span>

        // grab the extent for this variable
<span class="nc" id="L92">        UnboundVariable var = _unbounds.get(i);</span>
<span class="nc" id="L93">        Iterator&lt;Object&gt; itr = ctx.extentIterator(var.getType(), true, null, false);</span>
        try {
            // if the extent was empty, then alias the variable to null
<span class="nc bnc" id="L96" title="All 2 branches missed.">            if (!itr.hasNext()) {</span>
<span class="nc" id="L97">                var.setValue(null);</span>
<span class="nc" id="L98">                return matches(exp, candidate, ctx, params, i + 1);</span>
            }

            // try every value, short-circuiting on match
<span class="nc bnc" id="L102" title="All 2 branches missed.">            while (itr.hasNext()) {</span>
                // set the variable to each extent value and recurse
<span class="nc" id="L104">                var.setValue(itr.next());</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">                if (matches(exp, candidate, ctx, params, i + 1))</span>
<span class="nc" id="L106">                    return true;</span>
            }

            // no match
<span class="nc" id="L110">            return false;</span>
        } finally {
<span class="nc" id="L112">            ImplHelper.close(itr);</span>
        }
    }

    /**
     * Group the list of matches into a list of lists.
     */
    public List group(QueryExpressions exps, List matches,
        StoreContext ctx, Object[] params) {
<span class="nc bnc" id="L121" title="All 6 branches missed.">        if (matches == null || matches.isEmpty() || exps.grouping.length == 0)</span>
<span class="nc" id="L122">            return matches;</span>

        // to form groups we first order on the grouping criteria
<span class="nc" id="L125">        matches = order(exps, exps.grouping, false, matches, ctx, params);</span>

        // now we combine all results whose values for each grouping clause
        // are the same, relying on the fact that these values will already be
        // together due to the sorting
<span class="nc" id="L130">        Object[] prevs = new Object[exps.grouping.length];</span>
<span class="nc" id="L131">        Arrays.fill(prevs, UNIQUE);</span>
<span class="nc" id="L132">        Object[] curs = new Object[exps.grouping.length];</span>
<span class="nc" id="L133">        List grouped = new ArrayList();</span>
<span class="nc" id="L134">        List group = null;</span>
        Object pc;
        boolean eq;
<span class="nc bnc" id="L137" title="All 2 branches missed.">        for (Iterator itr = matches.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L138">            pc = itr.next();</span>
<span class="nc" id="L139">            eq = true;</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">            for (int i = 0; i &lt; exps.grouping.length; i++) {</span>
<span class="nc" id="L141">                curs[i] = ((Val) exps.grouping[i]).evaluate(pc, pc, ctx,</span>
                    params);
<span class="nc bnc" id="L143" title="All 4 branches missed.">                eq = eq &amp;&amp; Objects.equals(prevs[i], curs[i]);</span>
            }

            // if this object's grouping values differ from the prev,
            // start a new group
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if (!eq) {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">                if (group != null)</span>
<span class="nc" id="L150">                    grouped.add(group);</span>
<span class="nc" id="L151">                group = new ArrayList();</span>
            }
<span class="nc" id="L153">            group.add(pc);</span>
<span class="nc" id="L154">            System.arraycopy(curs, 0, prevs, 0, curs.length);</span>
        }
        // add the last group formed
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (group != null)</span>
<span class="nc" id="L158">            grouped.add(group);</span>

<span class="nc" id="L160">        return grouped;</span>
    }

    /**
     * Return true if the given group matches the having expression.
     */
    public boolean matches(QueryExpressions exps, Collection group,
        StoreContext ctx, Object[] params) {
<span class="nc bnc" id="L168" title="All 4 branches missed.">        if (group == null || group.isEmpty())</span>
<span class="nc" id="L169">            return false;</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (exps.having == null)</span>
<span class="nc" id="L171">            return true;</span>

        // evaluate the expression for all possible combinations of values
        // of the unbound variables; the group matches if any combination
        // matches
<span class="nc" id="L176">        return matches((Exp) exps.having, group, ctx, params, 0);</span>
    }

    /**
     * Recursive method to evaluate the expression for all possible
     * combinations of unbound variables. This method simulates a sequence
     * of embedded procedural loops over the extents of all variables in the
     * unbounds list.
     */
    private boolean matches(Exp exp, Collection group, StoreContext ctx,
        Object[] params, int i) {
        // base case: all variables have been aliased; evaluate for current
        // values
<span class="nc bnc" id="L189" title="All 4 branches missed.">        if (_unbounds == null || i == _unbounds.size())</span>
<span class="nc" id="L190">            return exp.evaluate(group, ctx, params);</span>

        // grab the extent for this variable
<span class="nc" id="L193">        UnboundVariable var = _unbounds.get(i);</span>
<span class="nc" id="L194">        Extent extent = ctx.getBroker().newExtent(var.getType(), true);</span>
<span class="nc" id="L195">        Iterator itr = extent.iterator();</span>
        try {
            // if the extent was empty, then alias the variable to null
<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (!itr.hasNext()) {</span>
<span class="nc" id="L199">                var.setValue(null);</span>
<span class="nc" id="L200">                return matches(exp, group, ctx, params, i + 1);</span>
            }

            // try every value, short-circuiting on match
<span class="nc bnc" id="L204" title="All 2 branches missed.">            while (itr.hasNext()) {</span>
                // set the variable to each extent value and recurse
<span class="nc" id="L206">                var.setValue(itr.next());</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">                if (matches(exp, group, ctx, params, i + 1))</span>
<span class="nc" id="L208">                    return true;</span>
            }

            // no match
<span class="nc" id="L212">            return false;</span>
        } finally {
<span class="nc" id="L214">            ImplHelper.close(itr);</span>
        }
    }

    /**
     * Create the projections for the given results.
     */
    public List project(QueryExpressions exps, List matches,
        StoreContext ctx, Object[] params) {
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (exps.projections.length == 0)</span>
<span class="nc" id="L224">            return matches;</span>

        // if an ungrouped aggregate, evaluate the whole matches list
<span class="nc bnc" id="L227" title="All 4 branches missed.">        if (exps.grouping.length == 0 &amp;&amp; exps.isAggregate()) {</span>
<span class="nc" id="L228">            Object[] projection = project(matches, exps, true, ctx, params);</span>
<span class="nc" id="L229">            return Arrays.asList(new Object[]{ projection });</span>
        }

        // evaluate each candidate
<span class="nc" id="L233">        List projected = new ArrayList(matches.size());</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        for (Iterator itr = matches.iterator(); itr.hasNext();)</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            projected.add(project(itr.next(), exps, exps.grouping.length &gt; 0,</span>
                ctx, params));
<span class="nc" id="L237">        return projected;</span>
    }

    /**
     * Generate a projection on the given candidate.
     */
    private Object[] project(Object candidate, QueryExpressions exps,
        boolean agg, StoreContext ctx, Object[] params) {
<span class="nc" id="L245">        Object[] projection = new Object[exps.projections.length</span>
            + exps.ordering.length];

        // calcualte result values
<span class="nc" id="L249">        Object result = null;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">        for (int i = 0; i &lt; exps.projections.length; i++) {</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            if (agg)</span>
<span class="nc" id="L252">                result = ((Val) exps.projections[i]).evaluate((Collection)</span>
                    candidate, null, ctx, params);
            else
<span class="nc" id="L255">                result = ((Val) exps.projections[i]).evaluate(candidate,</span>
                    candidate, ctx, params);
<span class="nc" id="L257">            projection[i] = result;</span>
        }

        // tack on ordering values
        boolean repeat;
<span class="nc bnc" id="L262" title="All 2 branches missed.">        for (int i = 0; i &lt; exps.ordering.length; i++) {</span>
            // already selected as a result?
<span class="nc" id="L264">            repeat = false;</span>
<span class="nc bnc" id="L265" title="All 4 branches missed.">            for (int j = 0; !repeat &amp;&amp; j &lt; exps.projections.length; j++) {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">                if (exps.orderingClauses[i].equals(exps.projectionClauses[j])) {</span>
<span class="nc" id="L267">                    result = projection[j];</span>
<span class="nc" id="L268">                    repeat = true;</span>
                }
            }

            // not selected as result; calculate value
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (!repeat) {</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">                if (agg)</span>
<span class="nc" id="L275">                    result = ((Val) exps.ordering[i]).evaluate((Collection)</span>
                        candidate, null, ctx, params);
                else
<span class="nc" id="L278">                    result = ((Val) exps.ordering[i]).evaluate(candidate,</span>
                        candidate, ctx, params);
            }

<span class="nc" id="L282">            projection[i + exps.projections.length] = result;</span>
        }
<span class="nc" id="L284">        return projection;</span>
    }

    /**
     * Order the given list of matches on the given value.
     */
    public List order(QueryExpressions exps, List matches,
        StoreContext ctx, Object[] params) {
<span class="nc" id="L292">        return order(exps, exps.ordering, true, matches, ctx, params);</span>
    }

    /**
     * Order the given list of matches on the given value.
     *
     * @param projected whether projections have been applied to the matches yet
     */
    private List order(QueryExpressions exps, Value[] orderValues,
        boolean projected, List matches, StoreContext ctx, Object[] params) {
<span class="nc bnc" id="L302" title="All 8 branches missed.">        if (matches == null || matches.isEmpty()</span>
            || orderValues == null || orderValues.length == 0)
<span class="nc" id="L304">            return matches;</span>

<span class="nc bnc" id="L306" title="All 2 branches missed.">        int results = (projected) ? exps.projections.length : 0;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        boolean[] asc = (projected) ? exps.ascending : null;</span>
        int idx;
<span class="nc bnc" id="L309" title="All 2 branches missed.">        for (int i = orderValues.length - 1; i &gt;= 0; i--) {</span>
            // if this is a projection, then in project() we must have selected
            // the ordering value already after the projection values
<span class="nc bnc" id="L312" title="All 2 branches missed.">            idx = (results &gt; 0) ? results + i : -1;</span>
<span class="nc bnc" id="L313" title="All 4 branches missed.">            Collections.sort(matches,</span>
                new OrderValueComparator((Val) orderValues[i],
                    asc == null || asc[i], idx, ctx, params));
        }
<span class="nc" id="L317">        return matches;</span>
    }

    /**
     * Filter the given list of matches, removing duplicate entries.
     */
    public List distinct(QueryExpressions exps, boolean fromExtent,
        List matches) {
<span class="nc bnc" id="L325" title="All 4 branches missed.">        if (matches == null || matches.isEmpty())</span>
<span class="nc" id="L326">            return matches;</span>

        // no need to do distinct if not instructed to, or if these are
        // candidate objects from an extent
<span class="nc" id="L330">        int len = exps.projections.length;</span>
<span class="nc bnc" id="L331" title="All 6 branches missed.">        if ((exps.distinct &amp; QueryExpressions.DISTINCT_TRUE) == 0</span>
            || (fromExtent &amp;&amp; len == 0))
<span class="nc" id="L333">            return matches;</span>

<span class="nc" id="L335">        Set seen = new HashSet(matches.size());</span>
<span class="nc" id="L336">        List distinct = null;</span>
        Object cur;
        Object key;
<span class="nc bnc" id="L339" title="All 2 branches missed.">        for (ListIterator li = matches.listIterator(); li.hasNext();) {</span>
<span class="nc" id="L340">            cur = li.next();</span>
<span class="nc bnc" id="L341" title="All 4 branches missed.">            key = (len &gt; 0 &amp;&amp; cur != null) ? new ArrayKey((Object[]) cur) : cur;</span>

<span class="nc bnc" id="L343" title="All 2 branches missed.">            if (seen.add(key)) {</span>
                // key hasn't been seen before; if we've created a distinct
                // list, keep adding to it
<span class="nc bnc" id="L346" title="All 2 branches missed.">                if (distinct != null)</span>
<span class="nc" id="L347">                    distinct.add(cur);</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">            } else if (distinct == null) {</span>
                // we need to copy the matches list because the distinct list
                // will be different (we've come across a non-unique key); add
                // all the elements we've skipped over so far
<span class="nc" id="L352">                distinct = new ArrayList(matches.size());</span>
<span class="nc" id="L353">                distinct.addAll(matches.subList(0, li.previousIndex()));</span>
            }
        }
<span class="nc bnc" id="L356" title="All 2 branches missed.">        return (distinct == null) ? matches : distinct;</span>
    }

    @Override
    public Expression emptyExpression() {
<span class="nc" id="L361">        return new Exp();</span>
    }

    @Override
    public Expression asExpression(Value v) {
<span class="nc" id="L366">        return new ValExpression((Val) v);</span>
    }

    @Override
    public Expression equal(Value v1, Value v2) {
<span class="nc" id="L371">        return new EqualExpression((Val) v1, (Val) v2);</span>
    }

    @Override
    public Expression notEqual(Value v1, Value v2) {
<span class="nc" id="L376">        return new NotEqualExpression((Val) v1, (Val) v2);</span>
    }

    @Override
    public Expression lessThan(Value v1, Value v2) {
<span class="nc" id="L381">        return new LessThanExpression((Val) v1, (Val) v2);</span>
    }

    @Override
    public Expression greaterThan(Value v1, Value v2) {
<span class="nc" id="L386">        return new GreaterThanExpression((Val) v1, (Val) v2);</span>
    }

    @Override
    public Expression lessThanEqual(Value v1, Value v2) {
<span class="nc" id="L391">        return new LessThanEqualExpression((Val) v1, (Val) v2);</span>
    }

    @Override
    public Expression greaterThanEqual(Value v1, Value v2) {
<span class="nc" id="L396">        return new GreaterThanEqualExpression((Val) v1, (Val) v2);</span>
    }

    @Override
    public Expression isEmpty(Value v1) {
<span class="nc" id="L401">        return new IsEmptyExpression((Val) v1);</span>
    }

    @Override
    public Expression isNotEmpty(Value v1) {
<span class="nc" id="L406">        return not(isEmpty(v1));</span>
    }

    @Override
    public Expression contains(Value v1, Value v2) {
<span class="nc" id="L411">        return new ContainsExpression((Val) v1, (Val) v2);</span>
    }

    @Override
    public Expression containsKey(Value v1, Value v2) {
<span class="nc" id="L416">        return new ContainsKeyExpression((Val) v1, (Val) v2);</span>
    }

    @Override
    public Expression containsValue(Value v1, Value v2) {
<span class="nc" id="L421">        return new ContainsValueExpression((Val) v1, (Val) v2);</span>
    }

    @Override
    public Value getMapValue(Value map, Value arg) {
<span class="nc" id="L426">        return new GetMapValue((Val) map, (Val) arg);</span>
    }

    @Override
    public Expression isInstance(Value v1, Class c) {
<span class="nc" id="L431">        return new InstanceofExpression((Val) v1, c);</span>
    }

    @Override
    public Expression and(Expression exp1, Expression exp2) {
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (exp1 instanceof BindVariableExpression)</span>
<span class="nc" id="L437">            return new BindVariableAndExpression((BindVariableExpression) exp1,</span>
                (Exp) exp2);
<span class="nc" id="L439">        return new AndExpression((Exp) exp1, (Exp) exp2);</span>
    }

    @Override
    public Expression or(Expression exp1, Expression exp2) {
<span class="nc" id="L444">        return new OrExpression((Exp) exp1, (Exp) exp2);</span>
    }

    @Override
    public Expression not(Expression exp) {
<span class="nc" id="L449">        return new NotExpression((Exp) exp);</span>
    }

    @Override
    public Expression bindVariable(Value var, Value val) {
<span class="nc" id="L454">        return new BindVariableExpression((BoundVariable) var, (Val) val);</span>
    }

    @Override
    public Expression bindKeyVariable(Value var, Value val) {
<span class="nc" id="L459">        return new BindKeyVariableExpression((BoundVariable) var, (Val) val);</span>
    }

    @Override
    public Expression bindValueVariable(Value var, Value val) {
<span class="nc" id="L464">        return new BindValueVariableExpression((BoundVariable) var, (Val) val);</span>
    }

    @Override
    public Expression endsWith(Value v1, Value v2) {
<span class="nc" id="L469">        return new EndsWithExpression((Val) v1, (Val) v2);</span>
    }

    @Override
    public Expression matches(Value v1, Value v2,
        String single, String multi, String esc) {
<span class="nc" id="L475">        return new MatchesExpression((Val) v1, (Val) v2, single, multi, esc,</span>
            true);
    }

    @Override
    public Expression notMatches(Value v1, Value v2,
        String single, String multi, String esc) {
<span class="nc" id="L482">        return new MatchesExpression((Val) v1, (Val) v2, single, multi, esc,</span>
            false);
    }

    @Override
    public Expression startsWith(Value v1, Value v2) {
<span class="nc" id="L488">        return new StartsWithExpression((Val) v1, (Val) v2);</span>
    }

    @Override
    public Subquery newSubquery(ClassMetaData candidate, boolean subs,
        String alias) {
<span class="nc" id="L494">        return new SubQ(alias);</span>
    }

    @Override
    public Path newPath() {
<span class="nc" id="L499">        return new CandidatePath();</span>
    }

    @Override
    public Path newPath(Value val) {
<span class="nc" id="L504">        return new ValuePath((Val) val);</span>
    }

    @Override
    public Literal newLiteral(Object val, int parseType) {
<span class="nc" id="L509">        return new Lit(val, parseType);</span>
    }

    @Override
    public Literal newTypeLiteral(Object val, int parseType) {
<span class="nc" id="L514">        return new TypeLit(val, parseType);</span>
    }

    @Override
    public Value getThis() {
<span class="nc" id="L519">        return new This();</span>
    }

    @Override
    public Value getNull() {
<span class="nc" id="L524">        return NULL;</span>
    }

    @Override
    public &lt;T extends Date&gt; Value getCurrentDate(Class&lt;T&gt; dateType) {
<span class="nc" id="L529">        return new CurrentDate(dateType);</span>
    }

    @Override
    public  &lt;T extends Date&gt; Value getCurrentTime(Class&lt;T&gt; dateType) {
<span class="nc" id="L534">        return new CurrentDate(dateType);</span>
    }

    @Override
    public &lt;T extends Date&gt; Value getCurrentTimestamp(Class&lt;T&gt; dateType) {
<span class="nc" id="L539">        return new CurrentDate(dateType);</span>
    }

    @Override
    public Parameter newParameter(Object name, Class type) {
<span class="nc" id="L544">        return new Param(name, type);</span>
    }

    @Override
    public Parameter newCollectionValuedParameter(Object name, Class type) {
<span class="nc" id="L549">        return new CollectionParam(name, type);</span>
    }

    @Override
    public Value newExtension(FilterListener listener, Value target,
        Value arg) {
<span class="nc" id="L555">        return new Extension(listener, (Val) target, (Val) arg);</span>
    }

    @Override
    public Value newAggregate(AggregateListener listener, Value arg) {
<span class="nc" id="L560">        return new Aggregate(listener, (Val) arg);</span>
    }

    @Override
    public Arguments newArgumentList(Value val1, Value val2) {
<span class="nc" id="L565">        return new Args(val1, val2);</span>
    }

    @Override
    public Arguments newArgumentList(Value... values) {
<span class="nc" id="L570">        return new Args(values);</span>
    }

    @Override
    public Value newUnboundVariable(String name, Class type) {
<span class="nc" id="L575">        UnboundVariable var = new UnboundVariable(type);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">        if (_unbounds == null)</span>
<span class="nc" id="L577">            _unbounds = new ArrayList&lt;&gt;(3);</span>
<span class="nc" id="L578">        _unbounds.add(var);</span>
<span class="nc" id="L579">        return var;</span>
    }

    @Override
    public Value newBoundVariable(String name, Class type) {
<span class="nc" id="L584">        return new BoundVariable(type);</span>
    }

    @Override
    public Value cast(Value val, Class cls) {
<span class="nc bnc" id="L589" title="All 2 branches missed.">        if (val instanceof CandidatePath)</span>
<span class="nc" id="L590">            ((CandidatePath) val).castTo(cls);</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">        else if (val instanceof BoundVariable)</span>
<span class="nc" id="L592">            ((BoundVariable) val).castTo(cls);</span>
        else
<span class="nc" id="L594">            val = new Cast((Val) val, cls);</span>
<span class="nc" id="L595">        return val;</span>
    }

    @Override
    public Value add(Value val1, Value val2) {
<span class="nc" id="L600">        return new Add((Val) val1, (Val) val2);</span>
    }

    @Override
    public Value subtract(Value val1, Value val2) {
<span class="nc" id="L605">        return new Subtract((Val) val1, (Val) val2);</span>
    }

    @Override
    public Value multiply(Value val1, Value val2) {
<span class="nc" id="L610">        return new Multiply((Val) val1, (Val) val2);</span>
    }

    @Override
    public Value divide(Value val1, Value val2) {
<span class="nc" id="L615">        return new Divide((Val) val1, (Val) val2);</span>
    }

    @Override
    public Value mod(Value val1, Value val2) {
<span class="nc" id="L620">        return new Mod((Val) val1, (Val) val2);</span>
    }

    @Override
    public Value abs(Value val) {
<span class="nc" id="L625">        return new Abs((Val) val);</span>
    }

    @Override
    public Value indexOf(Value val1, Value val2) {
<span class="nc" id="L630">        return new IndexOf((Val) val1, (Val) val2);</span>
    }

    @Override
    public Value concat(Value val1, Value val2) {
<span class="nc" id="L635">        return new Concat((Val) val1, (Val) val2);</span>
    }

    @Override
    public Value stringLength(Value str) {
<span class="nc" id="L640">        return new StringLength((Val) str);</span>
    }

    @Override
    public Value trim(Value str, Value trimChar, Boolean where) {
<span class="nc" id="L645">        return new Trim((Val) str, (Val) trimChar, where);</span>
    }

    @Override
    public Value sqrt(Value val) {
<span class="nc" id="L650">        return new Sqrt((Val) val);</span>
    }

    @Override
    public Value substring(Value val1, Value val2) {
<span class="nc" id="L655">        return new Substring((Val) val1, (Val) val2);</span>
    }

    @Override
    public Value toUpperCase(Value val) {
<span class="nc" id="L660">        return new ToUpperCase((Val) val);</span>
    }

    @Override
    public Value toLowerCase(Value val) {
<span class="nc" id="L665">        return new ToLowerCase((Val) val);</span>
    }

    @Override
    public Value avg(Value val) {
<span class="nc" id="L670">        return new Avg((Val) val);</span>
    }

    @Override
    public Value count(Value val) {
<span class="nc" id="L675">        return new Count((Val) val);</span>
    }

    @Override
    public Value distinct(Value val) {
<span class="nc" id="L680">        return new Distinct((Val) val);</span>
    }

    @Override
    public Value max(Value val) {
<span class="nc" id="L685">        return new Max((Val) val);</span>
    }

    @Override
    public Value min(Value val) {
<span class="nc" id="L690">        return new Min((Val) val);</span>
    }

    @Override
    public Value sum(Value val) {
<span class="nc" id="L695">        return new Sum((Val) val);</span>
    }

    @Override
    public Value any(Value val) {
<span class="nc" id="L700">        return new Any((Val) val);</span>
    }

    @Override
    public Value all(Value val) {
<span class="nc" id="L705">        return new All((Val) val);</span>
    }

    @Override
    public Value size(Value val) {
<span class="nc" id="L710">        return new Size((Val) val);</span>
    }

    @Override
    public Value index(Value val) {
<span class="nc" id="L715">        return new Index((Val) val);</span>
    }

    @Override
    public Value type(Value val) {
<span class="nc" id="L720">        return new Type((Val) val);</span>
    }

    @Override
    public Value mapEntry(Value key, Value val) {
<span class="nc" id="L725">        throw new UnsupportedException(&quot;not implemented yet&quot;);</span>
    }

    @Override
    public Value mapKey(Value key, Value val) {
<span class="nc" id="L730">        throw new UnsupportedException(&quot;not implemented yet&quot;);</span>
    }

    @Override
    public Value getKey(Value val) {
<span class="nc" id="L735">        throw new UnsupportedException(&quot;not implemented yet&quot;);</span>
    }

    @Override
    public Value getObjectId(Value val) {
<span class="nc" id="L740">        return new GetObjectId((Val) val);</span>
    }

    /**
     * Key that implements hashCode and equals methods for object arrays.
     */
    private static class ArrayKey {

        private final Object[] _arr;

<span class="nc" id="L750">        public ArrayKey(Object[] arr) {</span>
<span class="nc" id="L751">            _arr = arr;</span>
<span class="nc" id="L752">        }</span>

        @Override
        public int hashCode() {
<span class="nc" id="L756">            int rs = 17;</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            for (int i = 0; i &lt; _arr.length; i++)</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">                rs = 37 * rs + ((_arr[i] == null) ? 0 : _arr[i].hashCode());</span>
<span class="nc" id="L759">            return rs;</span>
        }

        @Override
        public boolean equals(Object other) {
<span class="nc bnc" id="L764" title="All 2 branches missed.">            if (other == this)</span>
<span class="nc" id="L765">                return true;</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">            if (other == null)</span>
<span class="nc" id="L767">                return false;</span>

<span class="nc" id="L769">            Object[] arr = ((ArrayKey) other)._arr;</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">            if (_arr.length != arr.length)</span>
<span class="nc" id="L771">                return false;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">            for (int i = 0; i &lt; _arr.length; i++)</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">                if (!Objects.equals(_arr[i], arr[i]))</span>
<span class="nc" id="L774">                    return false;</span>
<span class="nc" id="L775">            return true;</span>
        }
    }

    /**
     * Comparator that uses the result of eval'ing a Value to sort on. Null
     * values are placed last if sorting in ascending order, first if
     * descending.
     */
    private static class OrderValueComparator
        implements Comparator {

        private final StoreContext _ctx;
        private final Val _val;
        private final boolean _asc;
        private final int _idx;
        private final Object[] _params;

        private OrderValueComparator(Val val, boolean asc, int idx,
<span class="nc" id="L794">            StoreContext ctx, Object[] params) {</span>
<span class="nc" id="L795">            _ctx = ctx;</span>
<span class="nc" id="L796">            _val = val;</span>
<span class="nc" id="L797">            _asc = asc;</span>
<span class="nc" id="L798">            _idx = idx;</span>
<span class="nc" id="L799">            _params = params;</span>
<span class="nc" id="L800">        }</span>

        @Override
        public int compare(Object o1, Object o2) {
<span class="nc bnc" id="L804" title="All 2 branches missed.">            if (_idx != -1) {</span>
<span class="nc" id="L805">                o1 = ((Object[]) o1)[_idx];</span>
<span class="nc" id="L806">                o2 = ((Object[]) o2)[_idx];</span>
            } else {
<span class="nc" id="L808">                o1 = _val.evaluate(o1, o1, _ctx, _params);</span>
<span class="nc" id="L809">                o2 = _val.evaluate(o2, o2, _ctx, _params);</span>
            }

<span class="nc bnc" id="L812" title="All 4 branches missed.">            if (o1 == null &amp;&amp; o2 == null)</span>
<span class="nc" id="L813">                return 0;</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">            if (o1 == null)</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">                return (_asc) ? 1 : -1;</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">            if (o2 == null)</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">                return (_asc) ? -1 : 1;</span>

<span class="nc bnc" id="L819" title="All 4 branches missed.">            if (o1 instanceof Boolean &amp;&amp; o2 instanceof Boolean) {</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">                int i1 = ((Boolean) o1).booleanValue() ? 1 : 0;</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">                int i2 = ((Boolean) o2).booleanValue() ? 1 : 0;</span>
<span class="nc" id="L822">                return i1 - i2;</span>
            }

            try {
<span class="nc bnc" id="L826" title="All 2 branches missed.">                if (_asc)</span>
<span class="nc" id="L827">                    return ((Comparable) o1).compareTo(o2);</span>
<span class="nc" id="L828">                return ((Comparable) o2).compareTo(o1);</span>
<span class="nc" id="L829">            } catch (ClassCastException cce) {</span>
<span class="nc" id="L830">                Localizer loc = Localizer.forPackage</span>
<span class="nc" id="L831">                    (InMemoryExpressionFactory.class);</span>
<span class="nc" id="L832">                throw new UserException(loc.get(&quot;not-comp&quot;, o1, o2));</span>
			}
		}
	}

    @Override
    public Value generalCaseExpression(Expression[] exp, Value val) {
<span class="nc" id="L839">        Exp[] exps = new Exp[exp.length];</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">        for (int i = 0; i &lt; exp.length; i++)</span>
<span class="nc" id="L841">            exps[i] = (Exp) exp[i];</span>
<span class="nc" id="L842">        return new GeneralCase(exps, (Val) val);</span>
    }

    @Override
    public Value simpleCaseExpression(Value caseOperand, Expression[] exp,
        Value val) {
<span class="nc" id="L848">            Exp[] exps = new Exp[exp.length];</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">            for (int i = 0; i &lt; exp.length; i++)</span>
<span class="nc" id="L850">                exps[i] = (Exp) exp[i];</span>
<span class="nc" id="L851">            return new SimpleCase((Val) caseOperand, exps, (Val) val);</span>
    }

    @Override
    public Expression whenCondition(Expression exp, Value val) {
<span class="nc" id="L856">        return new WhenCondition((Exp) exp, (Val) val);</span>
    }

    @Override
    public Expression whenScalar(Value val1, Value val2) {
<span class="nc" id="L861">        return new WhenScalar((Val) val1, (Val) val2);</span>
    }

    @Override
    public Value coalesceExpression(Value[] val) {
<span class="nc" id="L866">        Val[] vals = new Val[val.length];</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">        for (int i = 0; i &lt; val.length; i++)</span>
<span class="nc" id="L868">            vals[i] = (Val) val[i];</span>
<span class="nc" id="L869">        return new Coalesce(vals);</span>
    }

    @Override
    public Value nullIfExpression(Value val1, Value val2) {
<span class="nc" id="L874">        return new NullIf((Val) val1, (Val) val2);</span>
    }

    @Override
    public Value newFunction(String functionName, Class&lt;?&gt; resultType, Value... args) {
<span class="nc" id="L879">        throw new AbstractMethodError();</span>
    }

    @Override
    public boolean isVerticalType(Value val) {
<span class="nc" id="L884">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>