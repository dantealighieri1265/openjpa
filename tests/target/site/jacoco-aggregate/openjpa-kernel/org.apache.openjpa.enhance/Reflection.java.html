<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Reflection.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-kernel</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.enhance</a> &gt; <span class="el_source">Reflection.java</span></div><h1>Reflection.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.enhance;

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import org.apache.commons.collections4.map.AbstractReferenceMap.ReferenceStrength;
import org.apache.openjpa.lib.util.J2DoPrivHelper;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.lib.util.Localizer.Message;
import org.apache.openjpa.lib.util.Reflectable;
import org.apache.openjpa.lib.util.StringUtil;
import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;
import org.apache.openjpa.util.GeneralException;
import org.apache.openjpa.util.UserException;

/**
 * Reflection utilities used to support and augment enhancement.  Used both
 * at enhancement time and at runtime.
 *
 * @author Abe White
 */
<span class="nc" id="L48">public class Reflection {</span>

<span class="nc" id="L50">    private static final Localizer _loc = Localizer.forPackage</span>
<span class="nc" id="L51">        (Reflection.class);</span>

    // Weak HashMap caches of getter/setter/beanProperty methods
<span class="nc" id="L54">    private static Map&lt;Class&lt;?&gt;, Map&lt;String, Method&gt;&gt; getterMethodCache =</span>
        new ConcurrentReferenceHashMap(ReferenceStrength.WEAK, ReferenceStrength.HARD);
<span class="nc" id="L56">    private static Map&lt;Class&lt;?&gt;, Map&lt;String, Method&gt;&gt; setterMethodCache =</span>
        new ConcurrentReferenceHashMap(ReferenceStrength.WEAK, ReferenceStrength.HARD);
<span class="nc" id="L58">    private static Map&lt;Class&lt;?&gt;, Set&lt;String&gt;&gt; beanPropertiesNameCache =</span>
        new ConcurrentReferenceHashMap(ReferenceStrength.WEAK, ReferenceStrength.HARD);

    private static Method getGetterMethod(Class&lt;?&gt; cls, String prop) {
<span class="nc" id="L62">        Method rtnMethod = null;</span>
<span class="nc" id="L63">        Map&lt;String, Method&gt; clsMap = getterMethodCache.get(cls);</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">        if (clsMap != null) {</span>
<span class="nc" id="L65">            rtnMethod = clsMap.get(prop);</span>
        }
<span class="nc" id="L67">        return rtnMethod;</span>
    }

    private static void setGetterMethod(Class&lt;?&gt; cls, String prop,
        Method method) {
<span class="nc" id="L72">        Map&lt;String, Method&gt; clsMap = getterMethodCache.get(cls);</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">        if (clsMap == null) {</span>
<span class="nc" id="L74">            clsMap = new ConcurrentReferenceHashMap(ReferenceStrength.HARD,</span>
                ReferenceStrength.WEAK);
<span class="nc" id="L76">            getterMethodCache.put(cls, clsMap);</span>
        }
<span class="nc" id="L78">        clsMap.put(prop, method);</span>
<span class="nc" id="L79">    }</span>

    private static Method getSetterMethod(Class&lt;?&gt; cls, String prop) {
<span class="nc" id="L82">        Method rtnMethod = null;</span>
<span class="nc" id="L83">        Map&lt;String, Method&gt; clsMap = setterMethodCache.get(cls);</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">        if (clsMap != null) {</span>
<span class="nc" id="L85">            rtnMethod = clsMap.get(prop);</span>
        }
<span class="nc" id="L87">        return rtnMethod;</span>
    }

    private static void setSetterMethod(Class&lt;?&gt; cls, String prop,
        Method method) {
<span class="nc" id="L92">        Map&lt;String, Method&gt; clsMap = setterMethodCache.get(cls);</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (clsMap == null) {</span>
<span class="nc" id="L94">            clsMap = new ConcurrentReferenceHashMap(ReferenceStrength.HARD,</span>
                ReferenceStrength.WEAK);
<span class="nc" id="L96">            setterMethodCache.put(cls, clsMap);</span>
        }
<span class="nc" id="L98">        clsMap.put(prop, method);</span>
<span class="nc" id="L99">    }</span>

    /**
     * Return the getter method matching the given property name, optionally
     * throwing an exception if none.
     */
    public static Method findGetter(Class cls, String prop, boolean mustExist) {
<span class="nc" id="L106">        Method m = getGetterMethod(cls, prop);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">        if (m != null) {</span>
<span class="nc" id="L108">            return m;</span>
        }
<span class="nc" id="L110">        String capProp = StringUtil.capitalize(prop);</span>
        try {
            // this algorithm searches for a get&lt;prop&gt; or is&lt;prop&gt; method in
            // a breadth-first manner.
<span class="nc bnc" id="L114" title="All 4 branches missed.">            for (Class c = cls; c != null &amp;&amp; c != Object.class;</span>
<span class="nc" id="L115">                c = c.getSuperclass()) {</span>
<span class="nc" id="L116">                m = getDeclaredMethod(c, &quot;get&quot; + capProp, null);</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">                if (m != null) {</span>
<span class="nc" id="L118">                    setGetterMethod(cls, prop, m);</span>
<span class="nc" id="L119">                    return m;</span>
                } else {
<span class="nc" id="L121">                    m = getDeclaredMethod(c, &quot;is&quot; + capProp, null);</span>
<span class="nc bnc" id="L122" title="All 4 branches missed.">                    if (m != null &amp;&amp; (m.getReturnType() == boolean.class</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                        || m.getReturnType() == Boolean.class)) {</span>
<span class="nc" id="L124">                        setGetterMethod(cls, prop, m);</span>
<span class="nc" id="L125">                        return m;</span>
                    } else {
<span class="nc" id="L127">                        m = getDeclaredMethod(c, &quot;get&quot; + prop, null);</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                        if (m != null) {</span>
<span class="nc" id="L129">                            setGetterMethod(cls, prop, m);</span>
<span class="nc" id="L130">                            return m;</span>
                        } else {
<span class="nc" id="L132">                            m = getDeclaredMethod(c, &quot;is&quot; + prop, null);</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">                            if (m != null</span>
<span class="nc bnc" id="L134" title="All 4 branches missed.">                                    &amp;&amp; (m.getReturnType() == boolean.class || m.getReturnType() == Boolean.class)) {</span>
<span class="nc" id="L135">                                setGetterMethod(cls, prop, m);</span>
<span class="nc" id="L136">                                return m;</span>
                            }
                        }
                    }
                }
            }
<span class="nc" id="L142">        } catch (Exception e) {</span>
<span class="nc" id="L143">            throw new GeneralException(e);</span>
<span class="nc" id="L144">        }</span>

<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (mustExist)</span>
<span class="nc" id="L147">            throw new UserException(_loc.get(&quot;bad-getter&quot;, cls, prop));</span>
<span class="nc" id="L148">        return null;</span>
    }

    /**
     * Return the setter method matching the given property name, optionally
     * throwing an exception if none.  The property must also have a getter.
     */
    public static Method findSetter(Class cls, String prop, boolean mustExist) {
<span class="nc" id="L156">        Method getter = findGetter(cls, prop, mustExist);</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        return (getter == null) ? null</span>
<span class="nc" id="L158">            : findSetter(cls, prop, getter.getReturnType(), mustExist);</span>
    }

    /**
     * Return the setter method matching the given property name, optionally
     * throwing an exception if none.
     */
    public static Method findSetter(Class cls, String prop, Class param,
        boolean mustExist) {
<span class="nc" id="L167">        Method m = getSetterMethod(cls, prop);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (m != null) {</span>
<span class="nc" id="L169">            return m;</span>
        }
<span class="nc" id="L171">        String name = &quot;set&quot; + StringUtil.capitalize(prop);</span>
        try {
<span class="nc bnc" id="L173" title="All 4 branches missed.">            for (Class c = cls; c != null &amp;&amp; c != Object.class;</span>
<span class="nc" id="L174">                c = c.getSuperclass()) {</span>
<span class="nc" id="L175">                m = getDeclaredMethod(c, name, param);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">                if (m != null) {</span>
<span class="nc" id="L177">                    setSetterMethod(cls, prop, m);</span>
<span class="nc" id="L178">                    return m;</span>
                }
            }
<span class="nc" id="L181">        } catch (Exception e) {</span>
<span class="nc" id="L182">            throw new GeneralException(e);</span>
<span class="nc" id="L183">        }</span>

<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (mustExist)</span>
<span class="nc" id="L186">            throw new UserException(_loc.get(&quot;bad-setter&quot;, cls, prop));</span>
<span class="nc" id="L187">        return null;</span>
    }

    /**
     * Invokes &lt;code&gt;cls.getDeclaredMethods()&lt;/code&gt;, and returns the method
     * that matches the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;param&lt;/code&gt; arguments.
     * Avoids the exception thrown by &lt;code&gt;Class.getDeclaredMethod()&lt;/code&gt;
     * for performance reasons. &lt;code&gt;param&lt;/code&gt; may be null. Additionally,
     * if there are multiple methods with different return types, this will
     * return the method defined in the least-derived class.
     *
     * @since 0.9.8
     */
    static Method getDeclaredMethod(Class cls, String name,
        Class param) {
<span class="nc" id="L202">        Method[] methods = (Method[]) AccessController.doPrivileged(</span>
<span class="nc" id="L203">            J2DoPrivHelper.getDeclaredMethodsAction(cls));</span>
<span class="nc" id="L204">        Method candidate = null;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        for (int i = 0 ; i &lt; methods.length; i++) {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">    	    if (name.equals(methods[i].getName())) {</span>
<span class="nc" id="L207">                Class[] methodParams = methods[i].getParameterTypes();</span>
<span class="nc bnc" id="L208" title="All 4 branches missed.">                if (param == null &amp;&amp; methodParams.length == 0)</span>
<span class="nc" id="L209">                    candidate = mostDerived(methods[i], candidate);</span>
<span class="nc bnc" id="L210" title="All 4 branches missed.">                else if (param != null &amp;&amp; methodParams.length == 1</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">                    &amp;&amp; param.equals(methodParams[0]))</span>
<span class="nc" id="L212">                    candidate = mostDerived(methods[i], candidate);</span>
            }
        }
<span class="nc" id="L215">        return candidate;</span>
    }

    static Method mostDerived(Method meth1, Method meth2) {
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (meth1 == null)</span>
<span class="nc" id="L220">            return meth2;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (meth2 == null)</span>
<span class="nc" id="L222">            return meth1;</span>

<span class="nc" id="L224">        Class cls2 = meth2.getDeclaringClass();</span>
<span class="nc" id="L225">        Class cls1 = meth1.getDeclaringClass();</span>

<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (cls1.equals(cls2)) {</span>
<span class="nc" id="L228">            Class ret1 = meth1.getReturnType();</span>
<span class="nc" id="L229">            Class ret2 = meth2.getReturnType();</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (ret1.isAssignableFrom(ret2))</span>
<span class="nc" id="L231">                return meth2;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">            else if (ret2.isAssignableFrom(ret1))</span>
<span class="nc" id="L233">                return meth1;</span>
            else
<span class="nc" id="L235">                throw new IllegalArgumentException(</span>
<span class="nc" id="L236">                    _loc.get(&quot;most-derived-unrelated-same-type&quot;, meth1, meth2)</span>
<span class="nc" id="L237">                        .getMessage());</span>
        } else {
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (cls1.isAssignableFrom(cls2))</span>
<span class="nc" id="L240">                return meth2;</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            else if (cls2.isAssignableFrom(cls1))</span>
<span class="nc" id="L242">                return meth1;</span>
            else
<span class="nc" id="L244">                throw new IllegalArgumentException(</span>
<span class="nc" id="L245">                    _loc.get(&quot;most-derived-unrelated&quot;, meth1, meth2)</span>
<span class="nc" id="L246">                        .getMessage());</span>
        }
    }

    /**
     * Return the field with the given name, optionally throwing an exception
     * if none.
     */
    public static Field findField(Class cls, String name, boolean mustExist) {
        try {
            Field f;
<span class="nc bnc" id="L257" title="All 4 branches missed.">            for (Class c = cls; c != null &amp;&amp; c != Object.class;</span>
<span class="nc" id="L258">                c = c.getSuperclass()) {</span>
<span class="nc" id="L259">                f = getDeclaredField(c, name);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                if (f != null)</span>
<span class="nc" id="L261">                    return f;</span>
            }
<span class="nc" id="L263">        } catch (Exception e) {</span>
<span class="nc" id="L264">            throw new GeneralException(e);</span>
<span class="nc" id="L265">        }</span>

<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (mustExist)</span>
<span class="nc" id="L268">            throw new UserException(_loc.get(&quot;bad-field&quot;, cls, name));</span>
<span class="nc" id="L269">        return null;</span>
    }

    /**
     * Invokes &lt;code&gt;cls.getDeclaredFields()&lt;/code&gt;, and returns the field
     * that matches the &lt;code&gt;name&lt;/code&gt; argument.  Avoids the exception
     * thrown by &lt;code&gt;Class.getDeclaredField()&lt;/code&gt; for performance reasons.
     *
     * @since 0.9.8
     */
    private static Field getDeclaredField(Class cls, String name) {
<span class="nc" id="L280">        Field[] fields = AccessController.doPrivileged(</span>
<span class="nc" id="L281">            J2DoPrivHelper.getDeclaredFieldsAction(cls));</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">        for (int i = 0 ; i &lt; fields.length; i++) {</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">    	    if (name.equals(fields[i].getName()))</span>
<span class="nc" id="L284">		        return fields[i];</span>
        }
<span class="nc" id="L286">        return null;</span>
    }

    /**
     * Return the value of the given field in the given object.
     */
    public static Object get(Object target, Field field) {
<span class="nc bnc" id="L293" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L294">            return null;</span>
<span class="nc" id="L295">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L297">            return field.get(target);</span>
<span class="nc" id="L298">        } catch (Throwable t) {</span>
<span class="nc" id="L299">            throw wrapReflectionException(t, _loc.get(&quot;get-field&quot;, target, field));</span>
        }
    }

    /**
     * Get the value of the given named field or a corresponding getter method.
     *
     * @return null if the field does not exist and mustExist is set to false or
     * the given target is null.
     *
     * @exception UserException if mustExist is true and the field or getter
     * method is non-existent
     */
    public static Object getValue(Object obj, String prop, boolean mustExist) {
<span class="nc bnc" id="L313" title="All 2 branches missed.">    	if (obj == null)</span>
<span class="nc" id="L314">    		return null;</span>
<span class="nc" id="L315">    	Class cls = obj.getClass();</span>
<span class="nc" id="L316">    	Field field = findField(cls, prop, false);</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">    	if (field != null)</span>
<span class="nc" id="L318">    		return get(obj, field);</span>
<span class="nc" id="L319">    	Method getter = findGetter(cls, prop, false);</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">    	if (getter != null)</span>
<span class="nc" id="L321">    		return get(obj, getter);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (mustExist)</span>
<span class="nc" id="L323">            throw new UserException(_loc.get(&quot;bad-field&quot;, cls, prop));</span>
<span class="nc" id="L324">        return null; // should not reach</span>
    }

    /**
     * Make the given member accessible if it isn't already.
     */
    private static void makeAccessible(AccessibleObject ao, int mods) {
        try {
<span class="nc bnc" id="L332" title="All 4 branches missed.">            if (!Modifier.isPublic(mods) &amp;&amp; !ao.isAccessible())</span>
<span class="nc" id="L333">                AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc" id="L334">                    .setAccessibleAction(ao, true));</span>
<span class="nc" id="L335">        } catch (SecurityException se) {</span>
<span class="nc" id="L336">            throw new UserException(_loc.get(&quot;reflect-security&quot;, ao)).</span>
<span class="nc" id="L337">                setFatal(true);</span>
<span class="nc" id="L338">        }</span>
<span class="nc" id="L339">    }</span>

    /**
     * Wrap the given reflection exception as a runtime exception.
     */
    private static RuntimeException wrapReflectionException(Throwable t, Message message) {
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (t instanceof InvocationTargetException)</span>
<span class="nc" id="L346">            t = ((InvocationTargetException) t).getTargetException();</span>
<span class="nc" id="L347">        t.initCause(new IllegalArgumentException(message.getMessage()));</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (t instanceof RuntimeException)</span>
<span class="nc" id="L349">            return (RuntimeException) t;</span>
<span class="nc" id="L350">        return new GeneralException(t);</span>
    }

    /**
     * Return the value of the given field in the given object.
     */
    public static boolean getBoolean(Object target, Field field) {
<span class="nc bnc" id="L357" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L358">            return false;</span>
<span class="nc" id="L359">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L361">            return field.getBoolean(target);</span>
<span class="nc" id="L362">        } catch (Throwable t) {</span>
<span class="nc" id="L363">            throw wrapReflectionException(t, _loc.get(&quot;get-field&quot;, target, field));</span>
        }
    }

    /**
     * Return the value of the given field in the given object.
     */
    public static byte getByte(Object target, Field field) {
<span class="nc bnc" id="L371" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L372">            return (byte) 0;</span>
<span class="nc" id="L373">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L375">            return field.getByte(target);</span>
<span class="nc" id="L376">        } catch (Throwable t) {</span>
<span class="nc" id="L377">            throw wrapReflectionException(t, _loc.get(&quot;get-field&quot;, target, field));</span>
        }
    }

    /**
     * Return the value of the given field in the given object.
     */
    public static char getChar(Object target, Field field) {
<span class="nc bnc" id="L385" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L386">            return (char) 0;</span>
<span class="nc" id="L387">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L389">            return field.getChar(target);</span>
<span class="nc" id="L390">        } catch (Throwable t) {</span>
<span class="nc" id="L391">            throw wrapReflectionException(t, _loc.get(&quot;get-field&quot;, target, field));</span>
        }
    }

    /**
     * Return the value of the given field in the given object.
     */
    public static double getDouble(Object target, Field field) {
<span class="nc bnc" id="L399" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L400">            return 0D;</span>
<span class="nc" id="L401">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L403">            return field.getDouble(target);</span>
<span class="nc" id="L404">        } catch (Throwable t) {</span>
<span class="nc" id="L405">            throw wrapReflectionException(t, _loc.get(&quot;get-field&quot;, target, field));</span>
        }
    }

    /**
     * Return the value of the given field in the given object.
     */
    public static float getFloat(Object target, Field field) {
<span class="nc bnc" id="L413" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L414">            return 0F;</span>
<span class="nc" id="L415">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L417">            return field.getFloat(target);</span>
<span class="nc" id="L418">        } catch (Throwable t) {</span>
<span class="nc" id="L419">            throw wrapReflectionException(t, _loc.get(&quot;get-field&quot;, target, field));</span>
        }
    }

    /**
     * Return the value of the given field in the given object.
     */
    public static int getInt(Object target, Field field) {
<span class="nc bnc" id="L427" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L428">            return 0;</span>
<span class="nc" id="L429">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L431">            return field.getInt(target);</span>
<span class="nc" id="L432">        } catch (Throwable t) {</span>
<span class="nc" id="L433">            throw wrapReflectionException(t, _loc.get(&quot;get-field&quot;, target, field));</span>
        }
    }

    /**
     * Return the value of the given field in the given object.
     */
    public static long getLong(Object target, Field field) {
<span class="nc bnc" id="L441" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L442">            return 0L;</span>
<span class="nc" id="L443">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L445">            return field.getLong(target);</span>
<span class="nc" id="L446">        } catch (Throwable t) {</span>
<span class="nc" id="L447">            throw wrapReflectionException(t, _loc.get(&quot;get-field&quot;, target, field));</span>
        }
    }

    /**
     * Return the value of the given field in the given object.
     */
    public static short getShort(Object target, Field field) {
<span class="nc bnc" id="L455" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L456">            return (short) 0;</span>
<span class="nc" id="L457">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L459">            return field.getShort(target);</span>
<span class="nc" id="L460">        } catch (Throwable t) {</span>
<span class="nc" id="L461">            throw wrapReflectionException(t, _loc.get(&quot;get-field&quot;, target, field));</span>
        }
    }

    /**
     * Return the return value of the given getter in the given object.
     */
    public static Object get(Object target, Method getter) {
<span class="nc bnc" id="L469" title="All 4 branches missed.">        if (target == null || getter == null)</span>
<span class="nc" id="L470">            return null;</span>
<span class="nc" id="L471">        makeAccessible(getter, getter.getModifiers());</span>
        try {
<span class="nc" id="L473">            return getter.invoke(target, (Object[]) null);</span>
<span class="nc" id="L474">        } catch (Throwable t) {</span>
<span class="nc" id="L475">            throw wrapReflectionException(t, _loc.get(&quot;get-method&quot;, target, getter));</span>
        }
    }

    /**
     * Return the return value of the given getter in the given object.
     */
    public static boolean getBoolean(Object target, Method getter) {
<span class="nc" id="L483">        Object o = get(target, getter);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">        return (o == null) ? false : ((Boolean) o).booleanValue();</span>
    }

    /**
     * Return the return value of the given getter in the given object.
     */
    public static byte getByte(Object target, Method getter) {
<span class="nc" id="L491">        Object o = get(target, getter);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        return (o == null) ? (byte) 0 : ((Number) o).byteValue();</span>
    }

    /**
     * Return the return value of the given getter in the given object.
     */
    public static char getChar(Object target, Method getter) {
<span class="nc" id="L499">        Object o = get(target, getter);</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        return (o == null) ? (char) 0 : ((Character) o).charValue();</span>
    }

    /**
     * Return the return value of the given getter in the given object.
     */
    public static double getDouble(Object target, Method getter) {
<span class="nc" id="L507">        Object o = get(target, getter);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        return (o == null) ? 0D : ((Number) o).doubleValue();</span>
    }

    /**
     * Return the return value of the given getter in the given object.
     */
    public static float getFloat(Object target, Method getter) {
<span class="nc" id="L515">        Object o = get(target, getter);</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">        return (o == null) ? 0F : ((Number) o).floatValue();</span>
    }

    /**
     * Return the return value of the given getter in the given object.
     */
    public static int getInt(Object target, Method getter) {
<span class="nc" id="L523">        Object o = get(target, getter);</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">        return (o == null) ? 0 : ((Number) o).intValue();</span>
    }

    /**
     * Return the return value of the given getter in the given object.
     */
    public static long getLong(Object target, Method getter) {
<span class="nc" id="L531">        Object o = get(target, getter);</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">        return (o == null) ? 0L : ((Number) o).longValue();</span>
    }

    /**
     * Return the return value of the given getter in the given object.
     */
    public static short getShort(Object target, Method getter) {
<span class="nc" id="L539">        Object o = get(target, getter);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">        return (o == null) ? (short) 0 : ((Number) o).shortValue();</span>
    }

    /**
     * Set the value of the given field in the given object.
     */
    public static void set(Object target, Field field, Object value) {
<span class="nc bnc" id="L547" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L548">            return;</span>
<span class="nc" id="L549">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L551">            field.set(target, value);</span>
<span class="nc" id="L552">        } catch (Throwable t) {</span>
<span class="nc" id="L553">            throw wrapReflectionException(t, _loc.get(&quot;set-field&quot;, new Object[]{target, field, value,</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                    value == null ? &quot;&quot; : value.getClass()}));</span>
<span class="nc" id="L555">        }</span>
<span class="nc" id="L556">    }</span>

    /**
     * Set the value of the given field in the given object.
     */
    public static void set(Object target, Field field, boolean value) {
<span class="nc bnc" id="L562" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L563">            return;</span>
<span class="nc" id="L564">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L566">            field.setBoolean(target, value);</span>
<span class="nc" id="L567">        } catch (Throwable t) {</span>
<span class="nc" id="L568">            throw wrapReflectionException(t, _loc.get(&quot;set-field&quot;, new Object[]{target, field, value, &quot;boolean&quot;}));</span>
<span class="nc" id="L569">        }</span>
<span class="nc" id="L570">    }</span>

    /**
     * Set the value of the given field in the given object.
     */
    public static void set(Object target, Field field, byte value) {
<span class="nc bnc" id="L576" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L577">            return;</span>
<span class="nc" id="L578">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L580">            field.setByte(target, value);</span>
<span class="nc" id="L581">        } catch (Throwable t) {</span>
<span class="nc" id="L582">            throw wrapReflectionException(t, _loc.get(&quot;set-field&quot;, new Object[]{target, field, value, &quot;byte&quot;}));</span>
<span class="nc" id="L583">        }</span>
<span class="nc" id="L584">    }</span>

    /**
     * Set the value of the given field in the given object.
     */
    public static void set(Object target, Field field, char value) {
<span class="nc bnc" id="L590" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L591">            return;</span>
<span class="nc" id="L592">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L594">            field.setChar(target, value);</span>
<span class="nc" id="L595">        } catch (Throwable t) {</span>
<span class="nc" id="L596">            throw wrapReflectionException(t, _loc.get(&quot;set-field&quot;, new Object[]{target, field, value, &quot;char&quot;}));</span>
<span class="nc" id="L597">        }</span>
<span class="nc" id="L598">    }</span>

    /**
     * Set the value of the given field in the given object.
     */
    public static void set(Object target, Field field, double value) {
<span class="nc bnc" id="L604" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L605">            return;</span>
<span class="nc" id="L606">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L608">            field.setDouble(target, value);</span>
<span class="nc" id="L609">        } catch (Throwable t) {</span>
<span class="nc" id="L610">            throw wrapReflectionException(t, _loc.get(&quot;set-field&quot;, new Object[]{target, field, value, &quot;double&quot;}));</span>
<span class="nc" id="L611">        }</span>
<span class="nc" id="L612">    }</span>

    /**
     * Set the value of the given field in the given object.
     */
    public static void set(Object target, Field field, float value) {
<span class="nc bnc" id="L618" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L619">            return;</span>
<span class="nc" id="L620">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L622">            field.setFloat(target, value);</span>
<span class="nc" id="L623">        } catch (Throwable t) {</span>
<span class="nc" id="L624">            throw wrapReflectionException(t, _loc.get(&quot;set-field&quot;, new Object[]{target, field, value, &quot;float&quot;}));</span>
<span class="nc" id="L625">        }</span>
<span class="nc" id="L626">    }</span>

    /**
     * Set the value of the given field in the given object.
     */
    public static void set(Object target, Field field, int value) {
<span class="nc bnc" id="L632" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L633">            return;</span>
<span class="nc" id="L634">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L636">            field.setInt(target, value);</span>
<span class="nc" id="L637">        } catch (Throwable t) {</span>
<span class="nc" id="L638">            throw wrapReflectionException(t, _loc.get(&quot;set-field&quot;, new Object[]{target, field, value, &quot;int&quot;}));</span>
<span class="nc" id="L639">        }</span>
<span class="nc" id="L640">    }</span>

    /**
     * Set the value of the given field in the given object.
     */
    public static void set(Object target, Field field, long value) {
<span class="nc bnc" id="L646" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L647">            return;</span>
<span class="nc" id="L648">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L650">            field.setLong(target, value);</span>
<span class="nc" id="L651">        } catch (Throwable t) {</span>
<span class="nc" id="L652">            throw wrapReflectionException(t, _loc.get(&quot;set-field&quot;, new Object[]{target, field, value, &quot;long&quot;}));</span>
<span class="nc" id="L653">        }</span>
<span class="nc" id="L654">    }</span>

    /**
     * Set the value of the given field in the given object.
     */
    public static void set(Object target, Field field, short value) {
<span class="nc bnc" id="L660" title="All 4 branches missed.">        if (target == null || field == null)</span>
<span class="nc" id="L661">            return;</span>
<span class="nc" id="L662">        makeAccessible(field, field.getModifiers());</span>
        try {
<span class="nc" id="L664">            field.setShort(target, value);</span>
<span class="nc" id="L665">        } catch (Throwable t) {</span>
<span class="nc" id="L666">            throw wrapReflectionException(t, _loc.get(&quot;set-field&quot;, new Object[]{target, field, value, &quot;short&quot;}));</span>
<span class="nc" id="L667">        }</span>
<span class="nc" id="L668">    }</span>

    /**
     * Set the value of the given field in the given object.
     * Same behavior as above methods, but parameter ordering is rearranged
     * to simplify usage from generated bytecodes.
     *
     * @since 1.0.0
     */
    public static void set(Object target, Object value, Field field) {
<span class="nc" id="L678">        set(target, field, value);</span>
<span class="nc" id="L679">    }</span>

    /**
     * Set the value of the given field in the given object.
     * Same behavior as above methods, but parameter ordering is rearranged
     * to simplify usage from generated bytecodes.
     *
     * @since 1.0.0
     */
    public static void set(Object target, boolean value, Field field) {
<span class="nc" id="L689">        set(target, field, value);</span>
<span class="nc" id="L690">    }</span>

    /**
     * Set the value of the given field in the given object.
     * Same behavior as above methods, but parameter ordering is rearranged
     * to simplify usage from generated bytecodes.
     *
     * @since 1.0.0
     */
    public static void set(Object target, byte value, Field field) {
<span class="nc" id="L700">        set(target, field, value);</span>
<span class="nc" id="L701">    }</span>

    /**
     * Set the value of the given field in the given object.
     * Same behavior as above methods, but parameter ordering is rearranged
     * to simplify usage from generated bytecodes.
     *
     * @since 1.0.0
     */
    public static void set(Object target, char value, Field field) {
<span class="nc" id="L711">        set(target, field, value);</span>
<span class="nc" id="L712">    }</span>

    /**
     * Set the value of the given field in the given object.
     * Same behavior as above methods, but parameter ordering is rearranged
     * to simplify usage from generated bytecodes.
     *
     * @since 1.0.0
     */
    public static void set(Object target, double value, Field field) {
<span class="nc" id="L722">        set(target, field, value);</span>
<span class="nc" id="L723">    }</span>

    /**
     * Set the value of the given field in the given object.
     * Same behavior as above methods, but parameter ordering is rearranged
     * to simplify usage from generated bytecodes.
     *
     * @since 1.0.0
     */
    public static void set(Object target, float value, Field field) {
<span class="nc" id="L733">        set(target, field, value);</span>
<span class="nc" id="L734">    }</span>

    /**
     * Set the value of the given field in the given object.
     * Same behavior as above methods, but parameter ordering is rearranged
     * to simplify usage from generated bytecodes.
     *
     * @since 1.0.0
     */
    public static void set(Object target, int value, Field field) {
<span class="nc" id="L744">        set(target, field, value);</span>
<span class="nc" id="L745">    }</span>

    /**
     * Set the value of the given field in the given object.
     * Same behavior as above methods, but parameter ordering is rearranged
     * to simplify usage from generated bytecodes.
     *
     * @since 1.0.0
     */
    public static void set(Object target, long value, Field field) {
<span class="nc" id="L755">        set(target, field, value);</span>
<span class="nc" id="L756">    }</span>

    /**
     * Set the value of the given field in the given object.
     * Same behavior as above methods, but parameter ordering is rearranged
     * to simplify usage from generated bytecodes.
     *
     * @since 1.0.0
     */
    public static void set(Object target, short value, Field field) {
<span class="nc" id="L766">        set(target, field, value);</span>
<span class="nc" id="L767">    }</span>

    /**
     * Invoke the given setter on the given object.
     */
    public static void set(Object target, Method setter, Object value) {
<span class="nc bnc" id="L773" title="All 4 branches missed.">        if (target == null || setter == null)</span>
<span class="nc" id="L774">            return;</span>
<span class="nc" id="L775">        makeAccessible(setter, setter.getModifiers());</span>
        try {
<span class="nc" id="L777">            setter.invoke(target, new Object[] { value });</span>
<span class="nc" id="L778">        } catch (Throwable t) {</span>
<span class="nc" id="L779">            throw wrapReflectionException(t, _loc.get(&quot;set-method&quot;, new Object[]{target, setter, value,</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">                    value == null ? &quot;&quot; : value.getClass()}));</span>
<span class="nc" id="L781">        }</span>
<span class="nc" id="L782">    }</span>

    /**
     * Invoke the given setter on the given object.
     */
    public static void set(Object target, Method setter, boolean value) {
<span class="nc bnc" id="L788" title="All 2 branches missed.">        set(target, setter, (value) ? Boolean.TRUE : Boolean.FALSE);</span>
<span class="nc" id="L789">    }</span>

    /**
     * Invoke the given setter on the given object.
     */
    public static void set(Object target, Method setter, byte value) {
<span class="nc" id="L795">        set(target, setter, Byte.valueOf(value));</span>
<span class="nc" id="L796">    }</span>

    /**
     * Invoke the given setter on the given object.
     */
    public static void set(Object target, Method setter, char value) {
<span class="nc" id="L802">        set(target, setter, Character.valueOf(value));</span>
<span class="nc" id="L803">    }</span>

    /**
     * Invoke the given setter on the given object.
     */
    public static void set(Object target, Method setter, double value) {
<span class="nc" id="L809">        set(target, setter, new Double(value));</span>
<span class="nc" id="L810">    }</span>

    /**
     * Invoke the given setter on the given object.
     */
    public static void set(Object target, Method setter, float value) {
<span class="nc" id="L816">        set(target, setter, new Float(value));</span>
<span class="nc" id="L817">    }</span>

    /**
     * Invoke the given setter on the given object.
     */
    public static void set(Object target, Method setter, int value) {
<span class="nc" id="L823">        set(target, setter, Integer.valueOf(value));</span>
<span class="nc" id="L824">    }</span>

    /**
     * Invoke the given setter on the given object.
     */
    public static void set(Object target, Method setter, long value) {
<span class="nc" id="L830">        set(target, setter, Long.valueOf(value));</span>
<span class="nc" id="L831">    }</span>

    /**
     * Invoke the given setter on the given object.
     */
    public static void set(Object target, Method setter, short value) {
<span class="nc" id="L837">        set(target, setter, Short.valueOf(value));</span>
<span class="nc" id="L838">    }</span>

    /**
     * Gets all bean-style property names of the given Class or its superclass.
     * A bean-style property 'abc' exists in Class C iff C has declared
     * following pair of methods:
     *   public void setAbc(Y y) or public C setAbc(Y y)
     *   public Y getAbc();
     *
     * If a getter property is annotated with {@link Reflectable}, then
     * it is ignored.
     *
     */
    public static Set&lt;String&gt; getBeanStylePropertyNames(Class&lt;?&gt; c) {
<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (c == null)</span>
<span class="nc" id="L853">            return Collections.emptySet();</span>
<span class="nc" id="L854">        Set&lt;String&gt; result = beanPropertiesNameCache.get(c);</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L856">            return result;</span>
        }
<span class="nc" id="L858">        Method[] methods = c.getMethods();</span>
<span class="nc bnc" id="L859" title="All 4 branches missed.">        if (methods == null || methods.length &lt; 2)</span>
<span class="nc" id="L860">            return Collections.emptySet();</span>
<span class="nc" id="L861">        result = new TreeSet&lt;&gt;();</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">        for (Method m : methods) {</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">            if (m.getName().startsWith(&quot;get&quot;)) {</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">                if (!canReflect(m))</span>
<span class="nc" id="L865">                    continue;</span>
<span class="nc" id="L866">                String prop = StringUtil.capitalize(m.getName()</span>
<span class="nc" id="L867">                    .substring(&quot;get&quot;.length()));</span>
<span class="nc" id="L868">                Class&lt;?&gt; rtype = m.getReturnType();</span>
                try {
<span class="nc" id="L870">                  Method setter = c.getMethod(&quot;set&quot;+prop, new Class&lt;?&gt;[]{rtype});</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">                  if (setter.getReturnType() == void.class ||</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">                      setter.getReturnType().isAssignableFrom(c))</span>
<span class="nc" id="L873">                  result.add(prop);</span>
<span class="nc" id="L874">                } catch (NoSuchMethodException e) {</span>

<span class="nc" id="L876">                }</span>
            }
        }
<span class="nc" id="L879">        beanPropertiesNameCache.put(c, result);</span>
<span class="nc" id="L880">        return result;</span>
    }

    /**
     * Gets all public field names of the given Class.
     *
     */
    public static Set&lt;String&gt; getPublicFieldNames(Class c) {
<span class="nc bnc" id="L888" title="All 2 branches missed.">        if (c == null)</span>
<span class="nc" id="L889">            return Collections.EMPTY_SET;</span>
<span class="nc" id="L890">        Field[] fields = c.getFields();</span>
<span class="nc bnc" id="L891" title="All 4 branches missed.">        if (fields == null || fields.length == 0)</span>
<span class="nc" id="L892">            return Collections.EMPTY_SET;</span>
<span class="nc" id="L893">        Set&lt;String&gt; result = new TreeSet&lt;&gt;();</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">        for (Field f : fields) {</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">            if (canReflect(f))</span>
<span class="nc" id="L896">                result.add(f.getName());</span>
        }
<span class="nc" id="L898">        return result;</span>
    }

    /**
     * Gets values of all field f the given class such that f exactly
     * match the given modifiers and are of given type (Object implies any type)
     * unless f is annotated as {@link Reflectable}.
     *
     */
    public static &lt;T&gt; Set&lt;T&gt; getFieldValues(Class c, int mods, Class&lt;T&gt; t){
<span class="nc bnc" id="L908" title="All 2 branches missed.">        if (c == null)</span>
<span class="nc" id="L909">            return Collections.EMPTY_SET;</span>
<span class="nc" id="L910">        Field[] fields = c.getFields();</span>
<span class="nc bnc" id="L911" title="All 4 branches missed.">        if (fields == null || fields.length == 0)</span>
<span class="nc" id="L912">            return Collections.EMPTY_SET;</span>
<span class="nc" id="L913">        Set&lt;T&gt; result = new TreeSet&lt;&gt;();</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">        for (Field f : fields) {</span>
<span class="nc bnc" id="L915" title="All 4 branches missed.">            if (mods == f.getModifiers()</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">            &amp;&amp; (t == Object.class || t.isAssignableFrom(f.getType()))</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">            &amp;&amp; canReflect(f)) {</span>
                try {
<span class="nc" id="L919">                    result.add((T)f.get(null));</span>
<span class="nc" id="L920">                } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L921">                } catch (IllegalAccessException e) {</span>
<span class="nc" id="L922">                }</span>
            }
        }
<span class="nc" id="L925">        return result;</span>
    }

    /**
     * Affirms if the given member is selected for reflection. The decision is
     * based on the following truth table on both the class-level and
     * member-level annotation (null annotation represents MAYBE)
     *
     * Class   member
     * MAYBE   MAYBE   YES
     * MAYBE   YES     YES
     * MAYBE   NO      NO
     *
     * YES     MAYBE   YES
     * YES     YES     YES
     * YES     NO      NO
     *
     * NO      YES     YES
     * NO      MAYBE   NO
     * NO      NO      NO
     *
    */
    static boolean canReflect(Reflectable cls, Reflectable member) {
<span class="nc bnc" id="L948" title="All 4 branches missed.">        if (cls == null || cls.value()) {</span>
<span class="nc bnc" id="L949" title="All 4 branches missed.">            return member == null || member.value() == true;</span>
        } else {
<span class="nc bnc" id="L951" title="All 4 branches missed.">            return member != null &amp;&amp; member.value() == true;</span>
        }
    }

    /**
     * Affirms if the original declaration the given field is annotated
     * for reflection.
     */
    static boolean canReflect(Field field) {
<span class="nc" id="L960">        Class cls = field.getDeclaringClass();</span>
<span class="nc" id="L961">        return canReflect((Reflectable)cls.getAnnotation(Reflectable.class),</span>
<span class="nc" id="L962">            field.getAnnotation(Reflectable.class));</span>
    }

    /**
     * Affirms if the original declaration the given method is annotated
     * for reflection.
     */
    static boolean canReflect(Method method) {
<span class="nc" id="L970">        Class cls = getDeclaringClass(method);</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (cls != method.getDeclaringClass())</span>
<span class="nc" id="L972">            method = getDeclaringMethod(cls, method);</span>
<span class="nc" id="L973">        return canReflect((Reflectable)cls.getAnnotation(Reflectable.class),</span>
<span class="nc" id="L974">            method.getAnnotation(Reflectable.class));</span>
    }

    /**
     * Gets the declaring class of the given method signature but also checks
     * if the method is declared in an interface. If yes, then returns the
     * interface.
     */
    public static Class getDeclaringClass(Method m) {
<span class="nc bnc" id="L983" title="All 2 branches missed.">        if (m == null)</span>
<span class="nc" id="L984">            return null;</span>
<span class="nc" id="L985">        Class cls = m.getDeclaringClass();</span>
<span class="nc" id="L986">        Class[] intfs =  cls.getInterfaces();</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">        for (Class intf : intfs) {</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">            if (getDeclaringMethod(intf, m) != null)</span>
<span class="nc" id="L989">                cls = intf;</span>
        }
<span class="nc" id="L991">        return cls;</span>
    }

    /**
     * Gets the method in the given class that has the same signature of the
     * given method, if exists. Otherwise, null.
     */
    public static Method getDeclaringMethod(Class c, Method m) {
        try {
<span class="nc" id="L1000">            Method m0 = c.getMethod(m.getName(), m.getParameterTypes());</span>
<span class="nc" id="L1001">            return m0;</span>
<span class="nc" id="L1002">        } catch (Exception e) {</span>
<span class="nc" id="L1003">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>