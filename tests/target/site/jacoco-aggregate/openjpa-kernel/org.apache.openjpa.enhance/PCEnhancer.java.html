<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PCEnhancer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-kernel</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.enhance</a> &gt; <span class="el_source">PCEnhancer.java</span></div><h1>PCEnhancer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.enhance;

import java.io.Externalizable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamClass;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import org.apache.openjpa.conf.OpenJPAConfiguration;
import org.apache.openjpa.conf.OpenJPAConfigurationImpl;
import org.apache.openjpa.lib.conf.Configurations;
import org.apache.openjpa.lib.log.Log;
import org.apache.openjpa.lib.meta.ClassArgParser;
import org.apache.openjpa.lib.util.BytecodeWriter;
import org.apache.openjpa.lib.util.ClassUtil;
import org.apache.openjpa.lib.util.Files;
import org.apache.openjpa.lib.util.J2DoPrivHelper;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.lib.util.Localizer.Message;
import org.apache.openjpa.lib.util.Options;
import org.apache.openjpa.lib.util.Services;
import org.apache.openjpa.lib.util.StringUtil;
import org.apache.openjpa.lib.util.git.GitUtils;
import org.apache.openjpa.meta.AccessCode;
import org.apache.openjpa.meta.ClassMetaData;
import org.apache.openjpa.meta.FieldMetaData;
import org.apache.openjpa.meta.JavaTypes;
import org.apache.openjpa.meta.MetaDataModes;
import org.apache.openjpa.meta.MetaDataRepository;
import org.apache.openjpa.meta.ValueStrategies;
import org.apache.openjpa.util.ApplicationIds;
import org.apache.openjpa.util.BigDecimalId;
import org.apache.openjpa.util.BigIntegerId;
import org.apache.openjpa.util.ByteId;
import org.apache.openjpa.util.CharId;
import org.apache.openjpa.util.DateId;
import org.apache.openjpa.util.DoubleId;
import org.apache.openjpa.util.FloatId;
import org.apache.openjpa.util.GeneralException;
import org.apache.openjpa.util.Id;
import org.apache.openjpa.util.ImplHelper;
import org.apache.openjpa.util.IntId;
import org.apache.openjpa.util.InternalException;
import org.apache.openjpa.util.LongId;
import org.apache.openjpa.util.ObjectId;
import org.apache.openjpa.util.OpenJPAException;
import org.apache.openjpa.util.ShortId;
import org.apache.openjpa.util.StringId;
import org.apache.openjpa.util.UserException;

import serp.bytecode.BCClass;
import serp.bytecode.BCField;
import serp.bytecode.BCMethod;
import serp.bytecode.ClassInstruction;
import serp.bytecode.Code;
import serp.bytecode.Constants;
import serp.bytecode.Exceptions;
import serp.bytecode.FieldInstruction;
import serp.bytecode.GetFieldInstruction;
import serp.bytecode.IfInstruction;
import serp.bytecode.Instruction;
import serp.bytecode.JumpInstruction;
import serp.bytecode.LoadInstruction;
import serp.bytecode.LookupSwitchInstruction;
import serp.bytecode.MethodInstruction;
import serp.bytecode.Project;
import serp.bytecode.PutFieldInstruction;
import serp.bytecode.TableSwitchInstruction;

/**
 * Bytecode enhancer used to enhance persistent classes from metadata. The
 * enhancer must be invoked on all persistence-capable and persistence aware
 * classes.
 *
 * @author Abe White
 */
public class PCEnhancer {
    // Designates a version for maintaining compatbility when PCEnhancer
    // modifies enhancement that can break serialization or other contracts
    // Each enhanced class will return the value of this field via
    // public int getEnhancementContractVersion()
    public static final int ENHANCER_VERSION;

<span class="nc" id="L127">    boolean _addVersionInitFlag = true;</span>

    public static final int ENHANCE_NONE = 0;
    public static final int ENHANCE_AWARE = 2 &lt;&lt; 0;
    public static final int ENHANCE_INTERFACE = 2 &lt;&lt; 1;
    public static final int ENHANCE_PC = 2 &lt;&lt; 2;

    public static final String PRE = &quot;pc&quot;;
    public static final String ISDETACHEDSTATEDEFINITIVE = PRE
        + &quot;isDetachedStateDefinitive&quot;;

<span class="nc" id="L138">    private static final Class PCTYPE = PersistenceCapable.class;</span>
    private static final String SM = PRE + &quot;StateManager&quot;;
<span class="nc" id="L140">    private static final Class SMTYPE = StateManager.class;</span>
    private static final String INHERIT = PRE + &quot;InheritedFieldCount&quot;;
    private static final String CONTEXTNAME = &quot;GenericContext&quot;;
<span class="nc" id="L143">    private static final Class USEREXCEP = UserException.class;</span>
<span class="nc" id="L144">    private static final Class INTERNEXCEP = InternalException.class;</span>
<span class="nc" id="L145">    private static final Class HELPERTYPE = PCRegistry.class;</span>
    private static final String SUPER = PRE + &quot;PCSuperclass&quot;;
<span class="nc" id="L147">    private static final Class OIDFSTYPE = FieldSupplier.class;</span>
<span class="nc" id="L148">    private static final Class OIDFCTYPE = FieldConsumer.class;</span>

    private static final String VERSION_INIT_STR =  PRE + &quot;VersionInit&quot;;

<span class="nc" id="L152">    private static final Localizer _loc = Localizer.forPackage</span>
<span class="nc" id="L153">        (PCEnhancer.class);</span>
<span class="nc" id="L154">    private static final String REDEFINED_ATTRIBUTE</span>
<span class="nc" id="L155">        = PCEnhancer.class.getName() + &quot;#redefined-type&quot;;</span>

    private static final AuxiliaryEnhancer[] _auxEnhancers;
    static {
<span class="nc" id="L159">        Class[] classes = Services.getImplementorClasses(</span>
            AuxiliaryEnhancer.class,
<span class="nc" id="L161">            AccessController.doPrivileged(</span>
<span class="nc" id="L162">                J2DoPrivHelper.getClassLoaderAction(AuxiliaryEnhancer.class)));</span>
<span class="nc" id="L163">        List auxEnhancers = new ArrayList(classes.length);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        for (int i = 0; i &lt; classes.length; i++) {</span>
            try {
<span class="nc" id="L166">                auxEnhancers.add(AccessController.doPrivileged(</span>
<span class="nc" id="L167">                    J2DoPrivHelper.newInstanceAction(classes[i])));</span>
<span class="nc" id="L168">            } catch (Throwable t) {</span>
                // aux enhancer may rely on non-existant spec classes, etc
<span class="nc" id="L170">            }</span>
        }
<span class="nc" id="L172">        _auxEnhancers = (AuxiliaryEnhancer[]) auxEnhancers.toArray</span>
<span class="nc" id="L173">        (new AuxiliaryEnhancer[auxEnhancers.size()]);</span>

<span class="nc" id="L175">        int rev = 0;</span>
<span class="nc" id="L176">        Properties revisionProps = new Properties();</span>
        try {
<span class="nc" id="L178">            InputStream in = PCEnhancer.class.getResourceAsStream(&quot;/META-INF/org.apache.openjpa.revision.properties&quot;);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">            if (in != null) {</span>
                try {
<span class="nc" id="L181">                    revisionProps.load(in);</span>
                } finally {
<span class="nc" id="L183">                    in.close();</span>
                }
            }
<span class="nc" id="L186">            rev = GitUtils.convertGitInfoToPCEnhancerVersion(revisionProps.getProperty(&quot;openjpa.enhancer.revision&quot;));</span>
<span class="nc" id="L187">        } catch (Exception e) {</span>
<span class="nc" id="L188">        }</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (rev &gt; 0) {</span>
<span class="nc" id="L190">            ENHANCER_VERSION = rev;</span>
        } else {
            // Something bad happened and we couldn't load from the properties file. We need to default to using the
            // value of 2 because that is the value that was the value as of rev.511998.
<span class="nc" id="L194">            ENHANCER_VERSION = 2;</span>
        }
<span class="nc" id="L196">    }</span>

    private BCClass _pc;
    private final BCClass _managedType;
    private final MetaDataRepository _repos;
    private final ClassMetaData _meta;
    private final Log _log;
<span class="nc" id="L203">    private Collection _oids = null;</span>
<span class="nc" id="L204">    private boolean _defCons = true;</span>
<span class="nc" id="L205">    private boolean _redefine = false;</span>
<span class="nc" id="L206">    private boolean _subclass = false;</span>
<span class="nc" id="L207">    private boolean _fail = false;</span>
<span class="nc" id="L208">    private Set _violations = null;</span>
<span class="nc" id="L209">    private File _dir = null;</span>
<span class="nc" id="L210">    private BytecodeWriter _writer = null;</span>
<span class="nc" id="L211">    private Map _backingFields = null; // map of set / get names =&gt; field names</span>
<span class="nc" id="L212">    private Map _attrsToFields = null; // map of attr names =&gt; field names</span>
<span class="nc" id="L213">    private Map _fieldsToAttrs = null; // map of field names =&gt; attr names</span>
<span class="nc" id="L214">    private boolean _isAlreadyRedefined = false;</span>
<span class="nc" id="L215">    private boolean _isAlreadySubclassed = false;</span>
<span class="nc" id="L216">    private boolean _bcsConfigured = false;</span>

<span class="nc" id="L218">    private boolean _optimizeIdCopy = false; // whether to attempt optimizing id copy</span>

    /**
     * Constructor. Supply configuration and type to enhance. This will look
     * up the metadata for &lt;code&gt;type&lt;/code&gt; from &lt;code&gt;conf&lt;/code&gt;'s
     * repository.
     */
    public PCEnhancer(OpenJPAConfiguration conf, Class type) {
<span class="nc" id="L226">        this(conf, AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc" id="L227">            .loadProjectClassAction(new Project(), type)),</span>
            (MetaDataRepository) null);
<span class="nc" id="L229">    }</span>

    /**
     * Constructor. Supply configuration and type to enhance. This will look
     * up the metadata for &lt;code&gt;meta&lt;/code&gt; by converting back to a class
     * and then loading from &lt;code&gt;conf&lt;/code&gt;'s repository.
     */
    public PCEnhancer(OpenJPAConfiguration conf, ClassMetaData meta) {
<span class="nc" id="L237">        this(conf, AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc" id="L238">            .loadProjectClassAction(new Project(), meta.getDescribedType())),</span>
<span class="nc" id="L239">            meta.getRepository());</span>
<span class="nc" id="L240">    }</span>

    /**
     * Constructor. Supply configuration.
     *
     * @param type the bytecode representation fo the type to
     * enhance; this can be created from any stream or file
     * @param repos a metadata repository to use for metadata access,
     * or null to create a new reporitory; the repository
     * from the given configuration isn't used by default
     * because the configuration might be an
     * implementation-specific subclass whose metadata
     * required more than just base metadata files
     * @deprecated use {@link #PCEnhancer(OpenJPAConfiguration, BCClass,
        MetaDataRepository, ClassLoader)} instead.
     */
    @Deprecated
    public PCEnhancer(OpenJPAConfiguration conf, BCClass type,
        MetaDataRepository repos) {
<span class="nc" id="L259">        this(conf, type, repos, null);</span>
<span class="nc" id="L260">    }</span>

    /**
     * Constructor. Supply configuration.
     *
     * @param type the bytecode representation fo the type to
     * enhance; this can be created from any stream or file
     * @param repos a metadata repository to use for metadata access,
     * or null to create a new reporitory; the repository
     * from the given configuration isn't used by default
     * because the configuration might be an
     * implementation-specific subclass whose metadata
     * required more than just base metadata files
     * @param loader the environment classloader to use for loading
     * classes and resources.
     */
    public PCEnhancer(OpenJPAConfiguration conf, BCClass type,
<span class="nc" id="L277">        MetaDataRepository repos, ClassLoader loader) {</span>
<span class="nc" id="L278">        _managedType = type;</span>
<span class="nc" id="L279">        _pc = type;</span>

<span class="nc" id="L281">        _log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);</span>

<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (repos == null) {</span>
<span class="nc" id="L284">            _repos = conf.newMetaDataRepositoryInstance();</span>
<span class="nc" id="L285">            _repos.setSourceMode(MetaDataModes.MODE_META);</span>
        } else
<span class="nc" id="L287">            _repos = repos;</span>
<span class="nc" id="L288">        _meta = _repos.getMetaData(type.getType(), loader, false);</span>

<span class="nc" id="L290">        configureOptimizeIdCopy();</span>
<span class="nc" id="L291">    }</span>

    /**
     * Constructor. Supply repository. The repository's configuration will
     * be used, and the metadata passed in will be used as-is without doing
     * any additional lookups. This is useful when running the enhancer
     * during metadata load.
     *
     * @param repos a metadata repository to use for metadata access,
     * or null to create a new reporitory; the repository
     * from the given configuration isn't used by default
     * because the configuration might be an
     * implementation-specific subclass whose metadata
     * required more than just base metadata files
     * @param type the bytecode representation fo the type to
     * enhance; this can be created from any stream or file
     * @param meta the metadata to use for processing this type.
     *
     * @since 1.1.0
     */
    public PCEnhancer(MetaDataRepository repos, BCClass type,
<span class="nc" id="L312">        ClassMetaData meta) {</span>
<span class="nc" id="L313">        _managedType = type;</span>
<span class="nc" id="L314">        _pc = type;</span>

<span class="nc" id="L316">        _log = repos.getConfiguration()</span>
<span class="nc" id="L317">            .getLog(OpenJPAConfiguration.LOG_ENHANCE);</span>

<span class="nc" id="L319">        _repos = repos;</span>
<span class="nc" id="L320">        _meta = meta;</span>
<span class="nc" id="L321">    }</span>

    static String toPCSubclassName(Class cls) {
<span class="nc" id="L324">        return ClassUtil.getPackageName(PCEnhancer.class) + &quot;.&quot;</span>
<span class="nc" id="L325">            + cls.getName().replace('.', '$') + &quot;$pcsubclass&quot;;</span>
    }

    /**
     * Whether or not &lt;code&gt;className&lt;/code&gt; is the name for a
     * dynamically-created persistence-capable subclass.
     *
     * @since 1.1.0
     */
    public static boolean isPCSubclassName(String className) {
<span class="nc bnc" id="L335" title="All 2 branches missed.">        return className.startsWith(ClassUtil.getPackageName(PCEnhancer.class))</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            &amp;&amp; className.endsWith(&quot;$pcsubclass&quot;);</span>
    }

    /**
     * If &lt;code&gt;className&lt;/code&gt; is a dynamically-created persistence-capable
     * subclass name, returns the name of the class that it subclasses.
     * Otherwise, returns &lt;code&gt;className&lt;/code&gt;.
     *
     * @since 1.1.0
     */
    public static String toManagedTypeName(String className) {
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (isPCSubclassName(className)) {</span>
<span class="nc" id="L348">            className = className.substring(</span>
<span class="nc" id="L349">                ClassUtil.getPackageName(PCEnhancer.class).length() + 1);</span>
<span class="nc" id="L350">            className = className.substring(0, className.lastIndexOf(&quot;$&quot;));</span>
            // this is not correct for nested PCs
<span class="nc" id="L352">            className = className.replace('$', '.');</span>
        }

<span class="nc" id="L355">        return className;</span>
    }

    /**
     * Constructor. Supply configuration, type, and metadata.
     */
    public PCEnhancer(OpenJPAConfiguration conf, BCClass type,
        ClassMetaData meta) {
<span class="nc" id="L363">        this(conf, type, meta.getRepository());</span>
<span class="nc" id="L364">    }</span>

    /**
     * Return the bytecode representation of the persistence-capable class
     * being manipulated.
     */
    public BCClass getPCBytecode() {
<span class="nc" id="L371">        return _pc;</span>
    }

    /**
     * Return the bytecode representation of the managed class being
     * manipulated. This is usually the same as {@link #getPCBytecode},
     * except when running the enhancer to redefine and subclass
     * existing persistent types.
     */
    public BCClass getManagedTypeBytecode() {
<span class="nc" id="L381">        return _managedType;</span>
    }

    /**
     * Return the metadata for the class being manipulated, or null if not
     * a persistent type.
     */
    public ClassMetaData getMetaData() {
<span class="nc" id="L389">        return _meta;</span>
    }

    /**
     * A boolean indicating whether the enhancer should add a no-args
     * constructor if one is not already present in the class. OpenJPA
     * requires that a no-arg constructor (whether created by the compiler
     * or by the user) be present in a PC.
     */
    public boolean getAddDefaultConstructor() {
<span class="nc" id="L399">        return _defCons;</span>
    }

    /**
     * A boolean indicating whether the enhancer should add a no-args
     * constructor if one is not already present in the class. OpenJPA
     * requires that a no-arg constructor (whether created by the compiler
     * or by the user) be present in a PC.
     */
    public void setAddDefaultConstructor(boolean addDefaultConstructor) {
<span class="nc" id="L409">        _defCons = addDefaultConstructor;</span>
<span class="nc" id="L410">    }</span>

    /**
     * Whether the enhancer should mutate its arguments, or just run validation
     * and optional subclassing logic on them. Usually used in conjunction with
     * &lt;code&gt;setCreateSubclass(true)&lt;/code&gt;.
     *
     * @since 1.0.0
     */
    public boolean getRedefine() {
<span class="nc" id="L420">        return _redefine;</span>
    }

    /**
     * Whether the enhancer should mutate its arguments, or just run validation
     * and optional subclassing logic on them. Usually used in conjunction with
     * &lt;code&gt;setCreateSubclass(true)&lt;/code&gt;.
     *
     * @since 1.0.0
     */
    public void setRedefine(boolean redefine) {
<span class="nc" id="L431">        _redefine = redefine;</span>
<span class="nc" id="L432">    }</span>

    /**
     * Whether the type that this instance is enhancing has already been
     * redefined.
     *
     * @since 1.0.0
     */
    public boolean isAlreadyRedefined() {
<span class="nc" id="L441">        return _isAlreadyRedefined;</span>
    }

    /**
     * Whether the type that this instance is enhancing has already been
     * subclassed in this instance's environment classloader.
     *
     * @since 1.0.0
     */
    public boolean isAlreadySubclassed() {
<span class="nc" id="L451">        return _isAlreadySubclassed;</span>
    }

    /**
     * Whether the enhancer should make its arguments persistence-capable,
     * or generate a persistence-capable subclass.
     *
     * @since 1.0.0
     */
    public boolean getCreateSubclass() {
<span class="nc" id="L461">        return _subclass;</span>
    }

    /**
     * Whether the enhancer should make its arguments persistence-capable,
     * or generate a persistence-capable subclass.
     *
     * @since 1.0.0
     */
    public void setCreateSubclass(boolean subclass) {
<span class="nc" id="L471">        _subclass = subclass;</span>
<span class="nc" id="L472">        _addVersionInitFlag = false;</span>
<span class="nc" id="L473">    }</span>

    /**
     * Whether to fail if the persistent type uses property access and
     * bytecode analysis shows that it may be violating OpenJPA's property
     * access restrictions.
     */
    public boolean getEnforcePropertyRestrictions() {
<span class="nc" id="L481">        return _fail;</span>
    }

    /**
     * Whether to fail if the persistent type uses property access and
     * bytecode analysis shows that it may be violating OpenJPA's property
     * access restrictions.
     */
    public void setEnforcePropertyRestrictions(boolean fail) {
<span class="nc" id="L490">        _fail = fail;</span>
<span class="nc" id="L491">    }</span>

    /**
     * The base build directory to generate code to. The proper package
     * structure will be created beneath this directory. Defaults to
     * overwriting the existing class file if null.
     */
    public File getDirectory() {
<span class="nc" id="L499">        return _dir;</span>
    }

    /**
     * The base build directory to generate code to. The proper package
     * structure will be creaed beneath this directory. Defaults to
     * overwriting the existing class file if null.
     */
    public void setDirectory(File dir) {
<span class="nc" id="L508">        _dir = dir;</span>
<span class="nc" id="L509">    }</span>

    /**
     * Return the current {@link BytecodeWriter} to write to or null if none.
     */
    public BytecodeWriter getBytecodeWriter() {
<span class="nc" id="L515">        return _writer;</span>
    }

    /**
     * Set the {@link BytecodeWriter} to write the bytecode to or null if none.
     */
    public void setBytecodeWriter(BytecodeWriter writer) {
<span class="nc" id="L522">        _writer = writer;</span>
<span class="nc" id="L523">    }</span>

    /**
     * Perform bytecode enhancements.
     *
     * @return &lt;code&gt;ENHANCE_*&lt;/code&gt; constant
     */
    public int run() {
<span class="nc" id="L531">        Class&lt;?&gt; type = _managedType.getType();</span>
        try {
            // if enum, skip, no need of any meta
<span class="nc bnc" id="L534" title="All 2 branches missed.">            if (_pc.isEnum())</span>
<span class="nc" id="L535">                return ENHANCE_NONE;</span>

            // if managed interface, skip
<span class="nc bnc" id="L538" title="All 2 branches missed.">            if (_pc.isInterface())</span>
<span class="nc" id="L539">                return ENHANCE_INTERFACE;</span>

            // check if already enhanced
<span class="nc" id="L542">            ClassLoader loader = AccessController.doPrivileged(J2DoPrivHelper.getClassLoaderAction(type));</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">            for (String iface : _managedType.getDeclaredInterfaceNames()) {</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">                if (iface.equals(PCTYPE.getName())) {</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">                    if (_log.isTraceEnabled()) {</span>
<span class="nc" id="L546">                        _log.trace(_loc.get(&quot;pc-type&quot;, type, loader));</span>
                    }
<span class="nc" id="L548">                    return ENHANCE_NONE;</span>
                }
            }
<span class="nc bnc" id="L551" title="All 2 branches missed.">            if (_log.isTraceEnabled()) {</span>
<span class="nc" id="L552">                _log.trace(_loc.get(&quot;enhance-start&quot;, type, loader));</span>
            }


<span class="nc" id="L556">            configureBCs();</span>

            // validate properties before replacing field access so that
            // we build up a record of backing fields, etc
<span class="nc bnc" id="L560" title="All 2 branches missed.">            if (isPropertyAccess(_meta)) {</span>
<span class="nc" id="L561">                validateProperties();</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">                if (getCreateSubclass())</span>
<span class="nc" id="L563">                    addAttributeTranslation();</span>
            }
<span class="nc" id="L565">            replaceAndValidateFieldAccess();</span>
<span class="nc" id="L566">            processViolations();</span>

<span class="nc bnc" id="L568" title="All 2 branches missed.">            if (_meta != null) {</span>
<span class="nc" id="L569">                enhanceClass();</span>
<span class="nc" id="L570">                addFields();</span>
<span class="nc" id="L571">                addStaticInitializer();</span>
<span class="nc" id="L572">                addPCMethods();</span>
<span class="nc" id="L573">                addAccessors();</span>
<span class="nc" id="L574">                addAttachDetachCode();</span>
<span class="nc" id="L575">                addSerializationCode();</span>
<span class="nc" id="L576">                addCloningCode();</span>
<span class="nc" id="L577">                runAuxiliaryEnhancers();</span>
<span class="nc" id="L578">                return ENHANCE_PC;</span>
            }
<span class="nc" id="L580">            return ENHANCE_AWARE;</span>
<span class="nc" id="L581">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L582">            throw ke;</span>
<span class="nc" id="L583">        } catch (Exception e) {</span>
<span class="nc" id="L584">            throw new GeneralException(_loc.get(&quot;enhance-error&quot;,</span>
<span class="nc" id="L585">                type.getName(), e.getMessage()), e);</span>
        }
    }

    private void configureBCs() {
<span class="nc bnc" id="L590" title="All 2 branches missed.">        if (!_bcsConfigured) {</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">            if (getRedefine()) {</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">                if (_managedType.getAttribute(REDEFINED_ATTRIBUTE) == null)</span>
<span class="nc" id="L593">                    _managedType.addAttribute(REDEFINED_ATTRIBUTE);</span>
                else
<span class="nc" id="L595">                    _isAlreadyRedefined = true;</span>
            }

<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (getCreateSubclass()) {</span>
<span class="nc" id="L599">                PCSubclassValidator val = new PCSubclassValidator(</span>
                    _meta, _managedType, _log, _fail);
<span class="nc" id="L601">                val.assertCanSubclass();</span>

<span class="nc" id="L603">                _pc = _managedType.getProject().loadClass(</span>
<span class="nc" id="L604">                    toPCSubclassName(_managedType.getType()));</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                if (_pc.getSuperclassBC() != _managedType) {</span>
<span class="nc" id="L606">                    _pc.setSuperclass(_managedType);</span>
<span class="nc" id="L607">                    _pc.setAbstract(_managedType.isAbstract());</span>
<span class="nc" id="L608">                    _pc.declareInterface(DynamicPersistenceCapable.class);</span>
                } else {
<span class="nc" id="L610">                    _isAlreadySubclassed = true;</span>
                }
            }

<span class="nc" id="L614">            _bcsConfigured = true;</span>
        }
<span class="nc" id="L616">    }</span>

    /**
     * Write the generated bytecode.
     */
    public void record()
        throws IOException {
<span class="nc bnc" id="L623" title="All 4 branches missed.">        if (_managedType != _pc &amp;&amp; getRedefine())</span>
<span class="nc" id="L624">            record(_managedType);</span>
<span class="nc" id="L625">        record(_pc);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">        if (_oids != null)</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">            for (Iterator itr = _oids.iterator(); itr.hasNext();)</span>
<span class="nc" id="L628">                record((BCClass) itr.next());</span>
<span class="nc" id="L629">    }</span>

    /**
     * Write the given class.
     */
    private void record(BCClass bc)
        throws IOException {
<span class="nc bnc" id="L636" title="All 2 branches missed.">        if (_writer != null)</span>
<span class="nc" id="L637">            _writer.write(bc);</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">        else if (_dir == null)</span>
<span class="nc" id="L639">            AsmAdaptor.write(bc);</span>
        else {
<span class="nc" id="L641">            File dir = Files.getPackageFile(_dir, bc.getPackageName(), true);</span>
<span class="nc" id="L642">            AsmAdaptor.write(bc, new File(dir, bc.getClassName() + &quot;.class&quot;));</span>
        }
<span class="nc" id="L644">    }</span>

    /**
     * Validate that the methods that use a property-access instance are
     * written correctly. This method also gathers information on each
     * property's backing field.
     */
    private void validateProperties() {
        FieldMetaData[] fmds;
<span class="nc bnc" id="L653" title="All 2 branches missed.">        if (getCreateSubclass())</span>
<span class="nc" id="L654">            fmds = _meta.getFields();</span>
        else
<span class="nc" id="L656">            fmds = _meta.getDeclaredFields();</span>
        Method meth;
        BCMethod getter, setter;
<span class="nc" id="L659">        BCField returned, assigned = null;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>

<span class="nc bnc" id="L662" title="All 2 branches missed.">            if (!(fmds[i].getBackingMember() instanceof Method) ) {</span>
                // If not mixed access is not defined, flag the field members,
                // otherwise do not process them because they are valid
                // persistent attributes.
<span class="nc bnc" id="L666" title="All 2 branches missed.">                if (!_meta.isMixedAccess()) {</span>
<span class="nc" id="L667">                    addViolation(&quot;property-bad-member&quot;,</span>
<span class="nc" id="L668">                        new Object[]{ fmds[i], fmds[i].getBackingMember() },</span>
                        true);
                }
                continue;
            }

<span class="nc" id="L674">            meth = (Method) fmds[i].getBackingMember();</span>
            // ##### this will fail if we override and don't call super.
<span class="nc" id="L676">            BCClass declaringType = _managedType.getProject()</span>
<span class="nc" id="L677">                .loadClass(fmds[i].getDeclaringType());</span>
<span class="nc" id="L678">            getter = declaringType.getDeclaredMethod(meth.getName(),</span>
<span class="nc" id="L679">                meth.getParameterTypes());</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">            if (getter == null) {</span>
<span class="nc" id="L681">                addViolation(&quot;property-no-getter&quot;, new Object[]{ fmds[i] },</span>
                    true);
<span class="nc" id="L683">                continue;</span>
            }
<span class="nc" id="L685">            returned = getReturnedField(getter);</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">            if (returned != null)</span>
<span class="nc" id="L687">                registerBackingFieldInfo(fmds[i], getter, returned);</span>

<span class="nc" id="L689">            setter = declaringType.getDeclaredMethod(getSetterName(fmds[i]),</span>
<span class="nc" id="L690">                new Class[]{ fmds[i].getDeclaredType() });</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">            if (setter == null) {</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                if (returned == null) {</span>
<span class="nc" id="L693">                    addViolation(&quot;property-no-setter&quot;,</span>
                        new Object[]{ fmds[i] }, true);
<span class="nc" id="L695">                    continue;</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">                } else if (!getRedefine()) {</span>
                    // create synthetic setter
<span class="nc" id="L698">                    setter = _managedType.declareMethod(getSetterName(fmds[i]),</span>
<span class="nc" id="L699">                        void.class, new Class[]{ fmds[i].getDeclaredType() });</span>
<span class="nc" id="L700">                    setter.makePrivate();</span>
<span class="nc" id="L701">                    Code code = setter.getCode(true);</span>
<span class="nc" id="L702">                    code.aload().setThis();</span>
<span class="nc" id="L703">                    code.xload().setParam(0);</span>
<span class="nc" id="L704">                    code.putfield().setField(returned);</span>
<span class="nc" id="L705">                    code.vreturn();</span>
<span class="nc" id="L706">                    code.calculateMaxStack();</span>
<span class="nc" id="L707">                    code.calculateMaxLocals();</span>
                }
            }

<span class="nc bnc" id="L711" title="All 2 branches missed.">            if (setter != null)</span>
<span class="nc" id="L712">                assigned = getAssignedField(setter);</span>

<span class="nc bnc" id="L714" title="All 2 branches missed.">            if (assigned != null) {</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                if (setter != null)</span>
<span class="nc" id="L716">                    registerBackingFieldInfo(fmds[i], setter, assigned);</span>

<span class="nc bnc" id="L718" title="All 2 branches missed.">                if (assigned != returned)</span>
<span class="nc" id="L719">                    addViolation(&quot;property-setter-getter-mismatch&quot;, new Object[]</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">                        { fmds[i], assigned.getName(), (returned == null)</span>
<span class="nc" id="L721">                        ? null : returned.getName() }, false);</span>
            }
        }
<span class="nc" id="L724">    }</span>

    private void registerBackingFieldInfo(FieldMetaData fmd, BCMethod method,
        BCField field) {
<span class="nc bnc" id="L728" title="All 2 branches missed.">        if (_backingFields == null)</span>
<span class="nc" id="L729">            _backingFields = new HashMap();</span>
<span class="nc" id="L730">        _backingFields.put(method.getName(), field.getName());</span>

<span class="nc bnc" id="L732" title="All 2 branches missed.">        if (_attrsToFields == null)</span>
<span class="nc" id="L733">            _attrsToFields = new HashMap();</span>
<span class="nc" id="L734">        _attrsToFields.put(fmd.getName(), field.getName());</span>

<span class="nc bnc" id="L736" title="All 2 branches missed.">        if (_fieldsToAttrs == null)</span>
<span class="nc" id="L737">            _fieldsToAttrs = new HashMap();</span>
<span class="nc" id="L738">        _fieldsToAttrs.put(field.getName(), fmd.getName());</span>
<span class="nc" id="L739">    }</span>

    private void addAttributeTranslation() {

        // Get all field metadata
<span class="nc" id="L744">        ArrayList&lt;Integer&gt; propFmds = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L745">        FieldMetaData[] fmds = _meta.getFields();</span>

<span class="nc bnc" id="L747" title="All 2 branches missed.">        if (_meta.isMixedAccess()) {</span>
            // Stores indexes of property access fields to be used in
            //
<span class="nc" id="L750">            propFmds = new ArrayList&lt;&gt;();</span>

            // Determine which fields have property access and save their
            // indexes
<span class="nc bnc" id="L754" title="All 2 branches missed.">            for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">                if (isPropertyAccess(fmds[i]))</span>
<span class="nc" id="L756">                    propFmds.add(i);</span>
            }

            // if no fields have property access do not do attribute translation
<span class="nc bnc" id="L760" title="All 2 branches missed.">            if (propFmds.size() == 0)</span>
<span class="nc" id="L761">                return;</span>
        }

<span class="nc" id="L764">        _pc.declareInterface(AttributeTranslator.class);</span>
<span class="nc" id="L765">        BCMethod method = _pc.declareMethod(PRE + &quot;AttributeIndexToFieldName&quot;,</span>
            String.class, new Class[] { int.class });
<span class="nc" id="L767">        method.makePublic();</span>
<span class="nc" id="L768">        Code code = method.getCode(true);</span>

        // switch (val)
<span class="nc" id="L771">        code.iload().setParam(0);</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">        if (!_meta.isMixedAccess()) {</span>
            // if not mixed access use a table switch on all property-based fmd.
            // a table switch is more efficient with +1 incremental operations
<span class="nc" id="L775">            TableSwitchInstruction tabins = code.tableswitch();</span>

<span class="nc" id="L777">            tabins.setLow(0);</span>
<span class="nc" id="L778">            tabins.setHigh(fmds.length - 1);</span>

            // case i:
            //     return &lt;_attrsToFields.get(fmds[i].getName())&gt;
<span class="nc bnc" id="L782" title="All 2 branches missed.">            for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc" id="L783">                tabins.addTarget(code.constant().setValue(</span>
<span class="nc" id="L784">                    _attrsToFields.get(fmds[i].getName())));</span>
<span class="nc" id="L785">                code.areturn();</span>
            }
            // default: throw new IllegalArgumentException ()
<span class="nc" id="L788">            tabins.setDefaultTarget(throwException</span>
<span class="nc" id="L789">                (code, IllegalArgumentException.class));</span>
<span class="nc" id="L790">        }</span>
        else {
            // In mixed access mode, property indexes are not +1 incremental
            // a lookup switch must be used to do indexed lookup.
<span class="nc" id="L794">            LookupSwitchInstruction lookupins = code.lookupswitch();</span>

<span class="nc bnc" id="L796" title="All 2 branches missed.">            for (Integer i : propFmds) {</span>
<span class="nc" id="L797">                lookupins.addCase(i,</span>
<span class="nc" id="L798">                    code.constant().setValue(</span>
<span class="nc" id="L799">                    _attrsToFields.get(fmds[i].getName())));</span>
<span class="nc" id="L800">                code.areturn();</span>
<span class="nc" id="L801">            }</span>
            // default: throw new IllegalArgumentException ()
<span class="nc" id="L803">            lookupins.setDefaultTarget(throwException</span>
<span class="nc" id="L804">                (code, IllegalArgumentException.class));</span>
        }

<span class="nc" id="L807">        code.calculateMaxLocals();</span>
<span class="nc" id="L808">        code.calculateMaxStack();</span>
<span class="nc" id="L809">    }</span>

    /**
     * Return the name of the setter method for the given field.
     */
    private static String getSetterName(FieldMetaData fmd) {
<span class="nc" id="L815">        return fmd.getSetterName();</span>
    }

    /**
     * Return the field returned by the given method, or null if none.
     * Package-protected and static for testing.
     */
    static BCField getReturnedField(BCMethod meth) {
<span class="nc" id="L823">        return findField(meth, (AccessController.doPrivileged(</span>
<span class="nc" id="L824">            J2DoPrivHelper.newCodeAction())).xreturn()</span>
<span class="nc" id="L825">            .setType(meth.getReturnType()), false);</span>
    }

    /**
     * Return the field assigned in the given method, or null if none.
     * Package-protected and static for testing.
     */
    static BCField getAssignedField(BCMethod meth) {
<span class="nc" id="L833">        return findField(meth, (AccessController.doPrivileged(</span>
<span class="nc" id="L834">            J2DoPrivHelper.newCodeAction())).putfield(), true);</span>
    }

    /**
     * Return the field returned / assigned by &lt;code&gt;meth&lt;/code&gt;. Returns
     * null if non-fields (methods, literals, parameters, variables) are
     * returned, or if non-parameters are assigned to fields.
     */
    private static BCField findField(BCMethod meth, Instruction template,
        boolean findAccessed) {
        // ignore any static methods. OpenJPA only currently supports
        // non-static setters and getters
<span class="nc bnc" id="L846" title="All 2 branches missed.">        if (meth.isStatic())</span>
<span class="nc" id="L847">            return null;</span>

<span class="nc" id="L849">        Code code = meth.getCode(false);</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">        if (code == null)</span>
<span class="nc" id="L851">            return null;</span>
<span class="nc" id="L852">        code.beforeFirst();</span>

<span class="nc" id="L854">        BCField field = null, cur;</span>
        Instruction templateIns, prevIns, earlierIns;
<span class="nc bnc" id="L856" title="All 2 branches missed.">        while (code.searchForward(template)) {</span>
<span class="nc" id="L857">            int backupCount = 3;</span>
<span class="nc" id="L858">            templateIns = code.previous();</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            if (!code.hasPrevious())</span>
<span class="nc" id="L860">                return null;</span>
<span class="nc" id="L861">            prevIns = code.previous();</span>

<span class="nc bnc" id="L863" title="All 2 branches missed.">            if (prevIns instanceof ClassInstruction</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">                &amp;&amp; code.hasPrevious()) {</span>
<span class="nc" id="L865">                prevIns = code.previous();</span>
<span class="nc" id="L866">                backupCount++;</span>
            }

<span class="nc bnc" id="L869" title="All 2 branches missed.">            if (!code.hasPrevious())</span>
<span class="nc" id="L870">                return null;</span>
<span class="nc" id="L871">            earlierIns = code.previous();</span>

            // if the opcode two before the template was an aload_0, check
            // against the middle instruction based on what type of find
            // we're doing
<span class="nc bnc" id="L876" title="All 2 branches missed.">            if (!(earlierIns instanceof LoadInstruction)</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">                || !((LoadInstruction) earlierIns).isThis())</span>
<span class="nc" id="L878">                return null;</span>

            // if the middle instruction was a getfield, then it's the
            // field that's being accessed
<span class="nc bnc" id="L882" title="All 4 branches missed.">            if (!findAccessed &amp;&amp; prevIns instanceof GetFieldInstruction) {</span>
<span class="nc" id="L883">                final FieldInstruction fPrevIns = (FieldInstruction) prevIns;</span>
<span class="nc" id="L884">                cur = AccessController.doPrivileged(</span>
<span class="nc" id="L885">                    J2DoPrivHelper.getFieldInstructionFieldAction(fPrevIns));</span>
                // if the middle instruction was an xload_1, then the
                // matched instruction is the field that's being set.
<span class="nc bnc" id="L888" title="All 4 branches missed.">            } else if (findAccessed &amp;&amp; prevIns instanceof LoadInstruction</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">                &amp;&amp; ((LoadInstruction) prevIns).getParam() == 0) {</span>
<span class="nc" id="L890">                final FieldInstruction fTemplateIns =</span>
                    (FieldInstruction) templateIns;
<span class="nc" id="L892">                cur = AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc" id="L893">                    .getFieldInstructionFieldAction(fTemplateIns));</span>
<span class="nc" id="L894">            } else</span>
<span class="nc" id="L895">                return null;</span>

<span class="nc bnc" id="L897" title="All 4 branches missed.">            if (field != null &amp;&amp; cur != field)</span>
<span class="nc" id="L898">                return null;</span>
<span class="nc" id="L899">            field = cur;</span>

            // ready for next search iteration
<span class="nc bnc" id="L902" title="All 2 branches missed.">            while (backupCount &gt; 0) {</span>
<span class="nc" id="L903">                code.next();</span>
<span class="nc" id="L904">                backupCount--;</span>
            }
<span class="nc" id="L906">        }</span>
<span class="nc" id="L907">        return field;</span>
    }

    /**
     * Record a violation of the property access restrictions.
     */
    private void addViolation(String key, Object[] args, boolean fatal) {
<span class="nc bnc" id="L914" title="All 2 branches missed.">        if (_violations == null)</span>
<span class="nc" id="L915">            _violations = new HashSet();</span>
<span class="nc" id="L916">        _violations.add(_loc.get(key, args));</span>
<span class="nc" id="L917">        _fail |= fatal;</span>
<span class="nc" id="L918">    }</span>

    /**
     * Log / throw recorded property access violations.
     */
    private void processViolations() {
<span class="nc bnc" id="L924" title="All 2 branches missed.">        if (_violations == null)</span>
<span class="nc" id="L925">            return;</span>

<span class="nc" id="L927">        String sep = J2DoPrivHelper.getLineSeparator();</span>
<span class="nc" id="L928">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">        for (Iterator itr = _violations.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L930">            buf.append(itr.next());</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">            if (itr.hasNext())</span>
<span class="nc" id="L932">                buf.append(sep);</span>
        }
<span class="nc" id="L934">        Message msg = _loc.get(&quot;property-violations&quot;, buf);</span>

<span class="nc bnc" id="L936" title="All 2 branches missed.">        if (_fail)</span>
<span class="nc" id="L937">            throw new UserException(msg);</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">        if (_log.isWarnEnabled())</span>
<span class="nc" id="L939">            _log.warn(msg);</span>
<span class="nc" id="L940">    }</span>

    /**
     * Replaced all direct access to managed fields with the appropriate
     * pcGet/pcSet method. Note that this includes access to fields
     * owned by PersistenceCapable classes other than this one.
     */
    private void replaceAndValidateFieldAccess() throws NoSuchMethodException {
        // create template putfield/getfield instructions to search for
<span class="nc" id="L949">        Code template = AccessController.doPrivileged(</span>
<span class="nc" id="L950">            J2DoPrivHelper.newCodeAction());</span>
<span class="nc" id="L951">        Instruction put = template.putfield();</span>
<span class="nc" id="L952">        Instruction get = template.getfield();</span>
<span class="nc" id="L953">        Instruction stat = template.invokestatic();</span>

        // look through all methods; this is done before any methods are added
        // so we don't need to worry about excluding synthetic methods.
<span class="nc" id="L957">        BCMethod[] methods = _managedType.getDeclaredMethods();</span>
        Code code;
<span class="nc bnc" id="L959" title="All 2 branches missed.">        for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="nc" id="L960">            code = methods[i].getCode(false);</span>

            // don't modify the methods specified by the auxiliary enhancers
<span class="nc bnc" id="L963" title="All 4 branches missed.">            if (code != null &amp;&amp; !skipEnhance(methods[i])) {</span>
<span class="nc" id="L964">                replaceAndValidateFieldAccess(code, get, true, stat);</span>
<span class="nc" id="L965">                replaceAndValidateFieldAccess(code, put, false, stat);</span>
            }
        }
<span class="nc" id="L968">    }</span>

    /**
     * Replaces all instructions matching the given template in the given
     * code block with calls to the appropriate generated getter/setter.
     *
     * @param code the code block to modify; the code iterator will
     * be placed before the first instruction on method start,
     * and will be after the last instruction on method completion
     * @param ins the template instruction to search for; either a
     * getfield or putfield instruction
     * @param get boolean indicating if this is a get instruction
     * @param stat template invokestatic instruction to replace with
     */
    private void replaceAndValidateFieldAccess(Code code, Instruction ins,
        boolean get, Instruction stat) throws NoSuchMethodException {
<span class="nc" id="L984">        code.beforeFirst();</span>

        FieldInstruction fi;
        MethodInstruction mi;
        ClassMetaData owner;
        String name, typeName, methodName;
<span class="nc bnc" id="L990" title="All 2 branches missed.">        while (code.searchForward(ins)) {</span>
            // back up to the matched instruction
<span class="nc" id="L992">            fi = (FieldInstruction) code.previous();</span>
<span class="nc" id="L993">            name = fi.getFieldName();</span>
<span class="nc" id="L994">            typeName = fi.getFieldTypeName();</span>
<span class="nc" id="L995">            owner = getPersistenceCapableOwner(name, fi.getFieldDeclarerType());</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">            FieldMetaData fmd = owner == null ? null : owner.getField(name);</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">            if (isPropertyAccess(fmd)) {</span>
                // if we're directly accessing a field in another class
                // hierarchy that uses property access, something is wrong
<span class="nc bnc" id="L1000" title="All 6 branches missed.">                if (owner != _meta &amp;&amp; owner.getDeclaredField(name) != null &amp;&amp;</span>
<span class="nc" id="L1001">                    _meta != null &amp;&amp; !owner.getDescribedType()</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">                        .isAssignableFrom(_meta.getDescribedType()))</span>
<span class="nc" id="L1003">                    throw new UserException(_loc.get(&quot;property-field-access&quot;,</span>
                        new Object[]{ _meta, owner, name,
<span class="nc" id="L1005">                            code.getMethod().getName() }));</span>

                // if we're directly accessing a property-backing field outside
                // the property in our own class, notify user
<span class="nc bnc" id="L1009" title="All 2 branches missed.">                if (isBackingFieldOfAnotherProperty(name, code))</span>
<span class="nc" id="L1010">                    addViolation(&quot;property-field-access&quot;, new Object[]{ _meta,</span>
<span class="nc" id="L1011">                        owner, name, code.getMethod().getName() }, false);</span>
            }

<span class="nc bnc" id="L1014" title="All 2 branches missed.">            if (owner == null ||</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">                owner.getDeclaredField(fromBackingFieldName(name)) == null) {</span>
                // not persistent field?
<span class="nc" id="L1017">                code.next();</span>
<span class="nc" id="L1018">                continue;</span>
<span class="nc bnc" id="L1019" title="All 4 branches missed.">            } else if (!getRedefine() &amp;&amp; !getCreateSubclass()</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">                &amp;&amp; isFieldAccess(fmd)) {</span>
                // replace the instruction with a call to the generated access
                // method
<span class="nc" id="L1023">                mi = (MethodInstruction) code.set(stat);</span>

                // invoke the proper access method, whether getter or setter
<span class="nc bnc" id="L1026" title="All 2 branches missed.">                String prefix = (get) ? PRE + &quot;Get&quot; : PRE + &quot;Set&quot;;</span>
<span class="nc" id="L1027">                methodName = prefix + name;</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">                if (get) {</span>
<span class="nc" id="L1029">                    mi.setMethod(getType(owner).getName(),</span>
                        methodName, typeName, new String[]
<span class="nc" id="L1031">                        { getType(owner).getName() });</span>
                } else {
<span class="nc" id="L1033">                    mi.setMethod(getType(owner).getName(),</span>
                        methodName, &quot;void&quot;, new String[]
<span class="nc" id="L1035">                        { getType(owner).getName(), typeName });</span>
                }
<span class="nc" id="L1037">                code.next();</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">            } else if (getRedefine()) {</span>
<span class="nc" id="L1039">                name = fromBackingFieldName(name);</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">                if (get) {</span>
<span class="nc" id="L1041">                    addNotifyAccess(code, owner.getField(name));</span>
<span class="nc" id="L1042">                    code.next();</span>
                } else {
                    // insert the set operations after the field mutation, but
                    // first load the old value for use in the
                    // StateManager.settingXXX method.
<span class="nc" id="L1047">                    loadManagedInstance(code, false);</span>
<span class="nc" id="L1048">                    final FieldInstruction fFi = fi;</span>
<span class="nc" id="L1049">                    code.getfield().setField(</span>
<span class="nc" id="L1050">                        AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc" id="L1051">                            .getFieldInstructionFieldAction(fFi)));</span>
<span class="nc" id="L1052">                    int val = code.getNextLocalsIndex();</span>
<span class="nc" id="L1053">                    code.xstore().setLocal(val).setType(fi.getFieldType());</span>

                    // move past the putfield
<span class="nc" id="L1056">                    code.next();</span>
<span class="nc" id="L1057">                    addNotifyMutation(code, owner.getField(name), val, -1);</span>
<span class="nc" id="L1058">                }</span>
            } else {
<span class="nc" id="L1060">                code.next();</span>
            }
<span class="nc" id="L1062">            code.calculateMaxLocals();</span>
<span class="nc" id="L1063">            code.calculateMaxStack();</span>
<span class="nc" id="L1064">        }</span>
<span class="nc" id="L1065">    }</span>

    private void addNotifyAccess(Code code, FieldMetaData fmd) {
        // PCHelper.accessingField(this, &lt;absolute-index&gt;);
<span class="nc" id="L1069">        code.aload().setThis();</span>
<span class="nc" id="L1070">        code.constant().setValue(fmd.getIndex());</span>
<span class="nc" id="L1071">        code.invokestatic().setMethod(RedefinitionHelper.class,</span>
            &quot;accessingField&quot;, void.class,
            new Class[] { Object.class, int.class });
<span class="nc" id="L1074">    }</span>

    /**
     * This must be called after setting the value in the object.
     *
     * @param val the position in the local variable table where the
     * old value is stored
     * @param param the parameter position containing the new value, or
     * -1 if the new value is unavailable and should therefore be looked
     * up.
     * @throws NoSuchMethodException
     */
    private void addNotifyMutation(Code code, FieldMetaData fmd, int val,
        int param)
        throws NoSuchMethodException {
        // PCHelper.settingField(this, &lt;absolute-index&gt;, old, new);
<span class="nc" id="L1090">        code.aload().setThis();</span>
<span class="nc" id="L1091">        code.constant().setValue(fmd.getIndex());</span>
<span class="nc" id="L1092">        Class type = fmd.getDeclaredType();</span>
        // we only have special signatures for primitives and Strings
<span class="nc bnc" id="L1094" title="All 4 branches missed.">        if (!type.isPrimitive() &amp;&amp; type != String.class)</span>
<span class="nc" id="L1095">            type = Object.class;</span>
<span class="nc" id="L1096">        code.xload().setLocal(val).setType(type);</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">        if (param == -1) {</span>
<span class="nc" id="L1098">            loadManagedInstance(code, false);</span>
<span class="nc" id="L1099">            addGetManagedValueCode(code, fmd);</span>
        } else {
<span class="nc" id="L1101">            code.xload().setParam(param).setType(type);</span>
        }
<span class="nc" id="L1103">        code.invokestatic().setMethod(RedefinitionHelper.class, &quot;settingField&quot;,</span>
            void.class, new Class[] {
                Object.class, int.class, type, type
        });
<span class="nc" id="L1107">    }</span>

    /**
     * Return true if the given instruction accesses a field that is a backing
     * field of another property in this property-access class.
     */
    private boolean isBackingFieldOfAnotherProperty(String name, Code code) {
<span class="nc" id="L1114">        String methName = code.getMethod().getName();</span>
<span class="nc bnc" id="L1115" title="All 4 branches missed.">        return !&quot;&lt;init&gt;&quot;.equals(methName)</span>
            &amp;&amp; _backingFields != null
<span class="nc bnc" id="L1117" title="All 2 branches missed.">            &amp;&amp; !name.equals(_backingFields.get(methName))</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">            &amp;&amp; _backingFields.containsValue(name);</span>
    }

    /**
     * Helper method to return the declaring PersistenceCapable class of
     * the given field.
     *
     * @param fieldName the name of the field
     * @param owner the nominal owner of the field
     * @return the metadata for the PersistenceCapable type that
     * declares the field (and therefore has the static method), or null if none
     */
    private ClassMetaData getPersistenceCapableOwner(String fieldName,
        Class owner) {
        // find the actual ancestor class that declares the field, then
        // check if the class is persistent, and if the field is managed
<span class="nc" id="L1134">        Field f = Reflection.findField(owner, fieldName, false);</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        if (f == null)</span>
<span class="nc" id="L1136">            return null;</span>

        // managed interface
<span class="nc bnc" id="L1139" title="All 4 branches missed.">        if (_meta != null &amp;&amp; _meta.getDescribedType().isInterface())</span>
<span class="nc" id="L1140">            return _meta;</span>

<span class="nc" id="L1142">        return _repos.getMetaData(f.getDeclaringClass(), null, false);</span>
    }

    /**
     * Adds all synthetic methods to the bytecode by delegating to
     * the various addXXXMethods () functions in this class. Includes
     * all static field access methods.
     * Note that the 'stock' methods like &lt;code&gt;pcIsTransactional&lt;/code&gt;,
     * &lt;code&gt;pcFetchObjectId&lt;/code&gt;, etc are defined only in the
     * least-derived PersistenceCapable type.
     */
    private void addPCMethods()
        throws NoSuchMethodException {
<span class="nc" id="L1155">        addClearFieldsMethod();</span>
<span class="nc" id="L1156">        addNewInstanceMethod(true);</span>
<span class="nc" id="L1157">        addNewInstanceMethod(false);</span>
<span class="nc" id="L1158">        addManagedFieldCountMethod();</span>
<span class="nc" id="L1159">        addReplaceFieldsMethods();</span>
<span class="nc" id="L1160">        addProvideFieldsMethods();</span>
<span class="nc" id="L1161">        addCopyFieldsMethod();</span>

<span class="nc bnc" id="L1163" title="All 4 branches missed.">        if (_meta.getPCSuperclass() == null || getCreateSubclass()) {</span>
<span class="nc" id="L1164">            addStockMethods();</span>
<span class="nc" id="L1165">            addGetVersionMethod();</span>
<span class="nc" id="L1166">            addReplaceStateManagerMethod();</span>

<span class="nc bnc" id="L1168" title="All 2 branches missed.">            if (_meta.getIdentityType() != ClassMetaData.ID_APPLICATION)</span>
<span class="nc" id="L1169">                addNoOpApplicationIdentityMethods();</span>
        }

        // add the app id methods to each subclass rather
        // than just the superclass, since it is possible to have
        // a subclass with an app id hierarchy that matches the
        // persistent class inheritance hierarchy
<span class="nc bnc" id="L1176" title="All 2 branches missed.">        if (_meta.getIdentityType() == ClassMetaData.ID_APPLICATION</span>
<span class="nc bnc" id="L1177" title="All 4 branches missed.">            &amp;&amp; (_meta.getPCSuperclass() == null || getCreateSubclass() ||</span>
<span class="nc" id="L1178">                _meta.getObjectIdType() !=</span>
<span class="nc bnc" id="L1179" title="All 2 branches missed.">                    _meta.getPCSuperclassMetaData().getObjectIdType())) {</span>
<span class="nc" id="L1180">            addCopyKeyFieldsToObjectIdMethod(true);</span>
<span class="nc" id="L1181">            addCopyKeyFieldsToObjectIdMethod(false);</span>
<span class="nc" id="L1182">            addCopyKeyFieldsFromObjectIdMethod(true);</span>
<span class="nc" id="L1183">            addCopyKeyFieldsFromObjectIdMethod(false);</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">            if (_meta.hasAbstractPKField() == true) {</span>
<span class="nc" id="L1185">                addGetIDOwningClass();</span>
            }

<span class="nc bnc" id="L1188" title="All 4 branches missed.">            if (_meta.isEmbeddable() &amp;&amp; _meta.getIdentityType() == ClassMetaData.ID_APPLICATION) {</span>
<span class="nc" id="L1189">                _log.warn(_loc.get(&quot;ID-field-in-embeddable-unsupported&quot;, _meta.toString()));</span>
            }

<span class="nc" id="L1192">            addNewObjectIdInstanceMethod(true);</span>
<span class="nc" id="L1193">            addNewObjectIdInstanceMethod(false);</span>
        }
<span class="nc bnc" id="L1195" title="All 2 branches missed.">        else if (_meta.hasPKFieldsFromAbstractClass()){</span>
<span class="nc" id="L1196">            addGetIDOwningClass();</span>
        }
<span class="nc" id="L1198">    }</span>

    /**
     * Add a method to clear all persistent fields; we'll call this from
     * the new instance method to ensure that unloaded fields have
     * default values.
     */
    private void addClearFieldsMethod()
        throws NoSuchMethodException {
        // protected void pcClearFields ()
<span class="nc" id="L1208">        BCMethod method = _pc.declareMethod(PRE + &quot;ClearFields&quot;, void.class,</span>
            null);
<span class="nc" id="L1210">        method.makeProtected();</span>
<span class="nc" id="L1211">        Code code = method.getCode(true);</span>

        // super.pcClearFields ()
<span class="nc bnc" id="L1214" title="All 4 branches missed.">        if (_meta.getPCSuperclass() != null &amp;&amp; !getCreateSubclass()) {</span>
<span class="nc" id="L1215">            code.aload().setThis();</span>
<span class="nc" id="L1216">            code.invokespecial().setMethod(getType(_meta.</span>
<span class="nc" id="L1217">                getPCSuperclassMetaData()), PRE + &quot;ClearFields&quot;, void.class,</span>
                null);
        }

<span class="nc" id="L1221">        FieldMetaData[] fmds = _meta.getDeclaredFields();</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">            if (fmds[i].getManagement() != FieldMetaData.MANAGE_PERSISTENT)</span>
<span class="nc" id="L1224">                continue;</span>

<span class="nc" id="L1226">            loadManagedInstance(code, false);</span>
<span class="nc bnc" id="L1227" title="All 5 branches missed.">            switch (fmds[i].getDeclaredTypeCode()) {</span>
                case JavaTypes.BOOLEAN:
                case JavaTypes.BYTE:
                case JavaTypes.CHAR:
                case JavaTypes.INT:
                case JavaTypes.SHORT:
<span class="nc" id="L1233">                    code.constant().setValue(0);</span>
<span class="nc" id="L1234">                    break;</span>
                case JavaTypes.DOUBLE:
<span class="nc" id="L1236">                    code.constant().setValue(0D);</span>
<span class="nc" id="L1237">                    break;</span>
                case JavaTypes.FLOAT:
<span class="nc" id="L1239">                    code.constant().setValue(0F);</span>
<span class="nc" id="L1240">                    break;</span>
                case JavaTypes.LONG:
<span class="nc" id="L1242">                    code.constant().setValue(0L);</span>
<span class="nc" id="L1243">                    break;</span>
                default:
<span class="nc" id="L1245">                    code.constant().setNull();</span>
                    break;
            }

<span class="nc" id="L1249">            addSetManagedValueCode(code, fmds[i]);</span>
        }

<span class="nc" id="L1252">        code.vreturn();</span>
<span class="nc" id="L1253">        code.calculateMaxStack();</span>
<span class="nc" id="L1254">        code.calculateMaxLocals();</span>
<span class="nc" id="L1255">    }</span>

    /**
     * Adds the &lt;code&gt;pcNewInstance&lt;/code&gt; method to the bytecode.
     * These methods are used by the impl helper to create new
     * managed instances efficiently without reflection.
     *
     * @param oid set to true to mimic the method version that takes
     * an oid value as well as a state manager
     */
    private void addNewInstanceMethod(boolean oid) {
        // public PersistenceCapable pcNewInstance (...)
        Class[] args =
<span class="nc bnc" id="L1268" title="All 2 branches missed.">            (oid) ? new Class[]{ SMTYPE, Object.class, boolean.class }</span>
<span class="nc" id="L1269">                : new Class[]{ SMTYPE, boolean.class };</span>
<span class="nc" id="L1270">        BCMethod method = _pc.declareMethod(PRE + &quot;NewInstance&quot;, PCTYPE, args);</span>
<span class="nc" id="L1271">        Code code = method.getCode(true);</span>

        // if the type is abstract, throw a UserException
<span class="nc bnc" id="L1274" title="All 2 branches missed.">        if (_pc.isAbstract()) {</span>
<span class="nc" id="L1275">            throwException(code, USEREXCEP);</span>

<span class="nc" id="L1277">            code.calculateMaxStack();</span>
<span class="nc" id="L1278">            code.calculateMaxLocals();</span>
<span class="nc" id="L1279">            return;</span>
        }

        // XXX pc = new XXX ();
<span class="nc" id="L1283">        code.anew().setType(_pc);</span>
<span class="nc" id="L1284">        code.dup();</span>
<span class="nc" id="L1285">        code.invokespecial().setMethod(&quot;&lt;init&gt;&quot;, void.class, null);</span>
<span class="nc" id="L1286">        int inst = code.getNextLocalsIndex();</span>
<span class="nc" id="L1287">        code.astore().setLocal(inst);</span>

        // if (clear)
        //   pc.pcClearFields ();
<span class="nc bnc" id="L1291" title="All 2 branches missed.">        code.iload().setParam((oid) ? 2 : 1);</span>
<span class="nc" id="L1292">        JumpInstruction noclear = code.ifeq();</span>
<span class="nc" id="L1293">        code.aload().setLocal(inst);</span>
<span class="nc" id="L1294">        code.invokevirtual().setMethod(PRE + &quot;ClearFields&quot;, void.class, null);</span>

        // pc.pcStateManager = sm;
<span class="nc" id="L1297">        noclear.setTarget(code.aload().setLocal(inst));</span>
<span class="nc" id="L1298">        code.aload().setParam(0);</span>
<span class="nc" id="L1299">        code.putfield().setField(SM, SMTYPE);</span>

        // copy key fields from oid
<span class="nc bnc" id="L1302" title="All 2 branches missed.">        if (oid) {</span>
<span class="nc" id="L1303">            code.aload().setLocal(inst);</span>
<span class="nc" id="L1304">            code.aload().setParam(1);</span>
<span class="nc" id="L1305">            code.invokevirtual().setMethod(PRE + &quot;CopyKeyFieldsFromObjectId&quot;,</span>
                void.class, new Class[]{ Object.class });
        }

        // return pc;
<span class="nc" id="L1310">        code.aload().setLocal(inst);</span>
<span class="nc" id="L1311">        code.areturn();</span>

<span class="nc" id="L1313">        code.calculateMaxStack();</span>
<span class="nc" id="L1314">        code.calculateMaxLocals();</span>
<span class="nc" id="L1315">    }</span>

    /**
     * Adds the &lt;code&gt;protected static int pcGetManagedFieldCount ()&lt;/code&gt;
     * method to the bytecode, returning the inherited field count added
     * to the number of managed fields in the current PersistenceCapable class.
     */
    private void addManagedFieldCountMethod() {
        // protected static int pcGetManagedFieldCount ()
<span class="nc" id="L1324">        BCMethod method = _pc.declareMethod(PRE + &quot;GetManagedFieldCount&quot;,</span>
            int.class, null);
<span class="nc" id="L1326">        method.setStatic(true);</span>
<span class="nc" id="L1327">        method.makeProtected();</span>
<span class="nc" id="L1328">        Code code = method.getCode(true);</span>

        // return &lt;fields&gt; + pcInheritedFieldCount
        // awhite: the above should work, but I'm seeing a messed up situation
        // all of a sudden where when a subclass calls this method, it somehow
        // happens before &lt;clinit&gt; is ever invoked, and so our
        // pcInheritedFieldCount field isn't initialized!  so instead,
        // return &lt;fields&gt; + &lt;superclass&gt;.pcGetManagedFieldCount ()
<span class="nc" id="L1336">        code.constant().setValue(_meta.getDeclaredFields().length);</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">        if (_meta.getPCSuperclass() != null) {</span>
<span class="nc" id="L1338">            Class superClass = getType(_meta.getPCSuperclassMetaData());</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">            String superName = getCreateSubclass() ?</span>
<span class="nc" id="L1340">                PCEnhancer.toPCSubclassName(superClass) :</span>
<span class="nc" id="L1341">                superClass.getName();</span>
<span class="nc" id="L1342">            code.invokestatic().setMethod(superName,</span>
<span class="nc" id="L1343">                PRE + &quot;GetManagedFieldCount&quot;, int.class.getName(), null);</span>
<span class="nc" id="L1344">            code.iadd();</span>
        }
<span class="nc" id="L1346">        code.ireturn();</span>
<span class="nc" id="L1347">        code.calculateMaxStack();</span>
<span class="nc" id="L1348">    }</span>

    /**
     * Adds the {@link PersistenceCapable#pcProvideField} and
     * {@link PersistenceCapable#pcProvideFields} methods to the bytecode.
     */
    private void addProvideFieldsMethods()
        throws NoSuchMethodException {
        // public void pcProvideField (int fieldNumber)
<span class="nc" id="L1357">        BCMethod method = _pc.declareMethod(PRE + &quot;ProvideField&quot;, void.class,</span>
            new Class[]{ int.class });
<span class="nc" id="L1359">        Code code = method.getCode(true);</span>

        // adds everything through the switch ()
<span class="nc" id="L1362">        int relLocal = beginSwitchMethod(PRE + &quot;ProvideField&quot;, code);</span>

        // if no fields in this inst, just throw exception
<span class="nc bnc" id="L1365" title="All 2 branches missed.">        FieldMetaData[] fmds = getCreateSubclass() ? _meta.getFields()</span>
<span class="nc" id="L1366">            : _meta.getDeclaredFields();</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">        if (fmds.length == 0)</span>
<span class="nc" id="L1368">            throwException(code, IllegalArgumentException.class);</span>
        else {
            // switch (val)
<span class="nc" id="L1371">            code.iload().setLocal(relLocal);</span>
<span class="nc" id="L1372">            TableSwitchInstruction tabins = code.tableswitch();</span>
<span class="nc" id="L1373">            tabins.setLow(0);</span>
<span class="nc" id="L1374">            tabins.setHigh(fmds.length - 1);</span>

            // &lt;field&gt; = pcStateManager.provided&lt;type&gt;Field
            //     (this, fieldNumber);
<span class="nc bnc" id="L1378" title="All 2 branches missed.">            for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc" id="L1379">                tabins.addTarget(loadManagedInstance(code, false));</span>
<span class="nc" id="L1380">                code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1381">                loadManagedInstance(code, false);</span>
<span class="nc" id="L1382">                code.iload().setParam(0);</span>
<span class="nc" id="L1383">                loadManagedInstance(code, false);</span>
<span class="nc" id="L1384">                addGetManagedValueCode(code, fmds[i]);</span>
<span class="nc" id="L1385">                code.invokeinterface().setMethod(getStateManagerMethod</span>
<span class="nc" id="L1386">                    (fmds[i].getDeclaredType(), &quot;provided&quot;, false, false));</span>
<span class="nc" id="L1387">                code.vreturn();</span>
            }

            // default: throw new IllegalArgumentException ()
<span class="nc" id="L1391">            tabins.setDefaultTarget(throwException</span>
<span class="nc" id="L1392">                (code, IllegalArgumentException.class));</span>
        }

<span class="nc" id="L1395">        code.calculateMaxStack();</span>
<span class="nc" id="L1396">        code.calculateMaxLocals();</span>

<span class="nc" id="L1398">        addMultipleFieldsMethodVersion(method);</span>
<span class="nc" id="L1399">    }</span>

    /**
     * Adds the {@link PersistenceCapable#pcReplaceField} and
     * {@link PersistenceCapable#pcReplaceFields} methods to the bytecode.
     */
    private void addReplaceFieldsMethods()
        throws NoSuchMethodException {
        // public void pcReplaceField (int fieldNumber)
<span class="nc" id="L1408">        BCMethod method = _pc.declareMethod(PRE + &quot;ReplaceField&quot;, void.class,</span>
            new Class[]{ int.class });
<span class="nc" id="L1410">        Code code = method.getCode(true);</span>

        // adds everything through the switch ()
<span class="nc" id="L1413">        int relLocal = beginSwitchMethod(PRE + &quot;ReplaceField&quot;, code);</span>

        // if no fields in this inst, just throw exception
<span class="nc bnc" id="L1416" title="All 2 branches missed.">        FieldMetaData[] fmds = getCreateSubclass() ? _meta.getFields()</span>
<span class="nc" id="L1417">            : _meta.getDeclaredFields();</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">        if (fmds.length == 0)</span>
<span class="nc" id="L1419">            throwException(code, IllegalArgumentException.class);</span>
        else {
            // switch (val)
<span class="nc" id="L1422">            code.iload().setLocal(relLocal);</span>
<span class="nc" id="L1423">            TableSwitchInstruction tabins = code.tableswitch();</span>
<span class="nc" id="L1424">            tabins.setLow(0);</span>
<span class="nc" id="L1425">            tabins.setHigh(fmds.length - 1);</span>

            // &lt;field&gt; = pcStateManager.replace&lt;type&gt;Field
            //  (this, fieldNumber);
<span class="nc bnc" id="L1429" title="All 2 branches missed.">            for (int i = 0; i &lt; fmds.length; i++) {</span>
                // for the addSetManagedValueCode call below.
<span class="nc" id="L1431">                tabins.addTarget(loadManagedInstance(code, false, fmds[i]));</span>

<span class="nc" id="L1433">                loadManagedInstance(code, false, fmds[i]);</span>
<span class="nc" id="L1434">                code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1435">                loadManagedInstance(code, false, fmds[i]);</span>
<span class="nc" id="L1436">                code.iload().setParam(0);</span>
<span class="nc" id="L1437">                code.invokeinterface().setMethod(getStateManagerMethod</span>
<span class="nc" id="L1438">                    (fmds[i].getDeclaredType(), &quot;replace&quot;, true, false));</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">                if (!fmds[i].getDeclaredType().isPrimitive())</span>
<span class="nc" id="L1440">                    code.checkcast().setType(fmds[i].getDeclaredType());</span>

<span class="nc" id="L1442">                addSetManagedValueCode(code, fmds[i]);</span>
<span class="nc bnc" id="L1443" title="All 2 branches missed.">                if(_addVersionInitFlag){</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">                    if(fmds[i].isVersion()){</span>
                        // If this case is setting the version field
                        // pcVersionInit = true;
<span class="nc" id="L1447">                        loadManagedInstance(code, false);</span>
<span class="nc" id="L1448">                        code.constant().setValue(1);</span>
<span class="nc" id="L1449">                        putfield(code, null, VERSION_INIT_STR, boolean.class);</span>
                    }
                }
<span class="nc" id="L1452">                code.vreturn();</span>
            }

            // default: throw new IllegalArgumentException ()
<span class="nc" id="L1456">            tabins.setDefaultTarget(throwException</span>
<span class="nc" id="L1457">                (code, IllegalArgumentException.class));</span>
        }

<span class="nc" id="L1460">        code.calculateMaxStack();</span>
<span class="nc" id="L1461">        code.calculateMaxLocals();</span>

<span class="nc" id="L1463">        addMultipleFieldsMethodVersion(method);</span>
<span class="nc" id="L1464">    }</span>

    /**
     * Adds the {@link PersistenceCapable#pcCopyFields} method to the bytecode.
     */
    private void addCopyFieldsMethod()
        throws NoSuchMethodException {
        // public void pcCopyField (Object pc, int field)
<span class="nc" id="L1472">        BCMethod method = _pc.declareMethod(PRE + &quot;CopyField&quot;,</span>
<span class="nc" id="L1473">            void.class.getName(),</span>
<span class="nc" id="L1474">            new String[]{ _managedType.getName(), int.class.getName() });</span>
<span class="nc" id="L1475">        method.makeProtected();</span>
<span class="nc" id="L1476">        Code code = method.getCode(true);</span>

        // adds everything through the switch ()
<span class="nc" id="L1479">        int relLocal = beginSwitchMethod(PRE + &quot;CopyField&quot;, code);</span>

        // if no fields in this inst, just throw exception
<span class="nc bnc" id="L1482" title="All 2 branches missed.">        FieldMetaData[] fmds = getCreateSubclass() ? _meta.getFields()</span>
<span class="nc" id="L1483">            : _meta.getDeclaredFields();</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">        if (fmds.length == 0)</span>
<span class="nc" id="L1485">            throwException(code, IllegalArgumentException.class);</span>
        else {
            // switch (val)
<span class="nc" id="L1488">            code.iload().setLocal(relLocal);</span>
<span class="nc" id="L1489">            TableSwitchInstruction tabins = code.tableswitch();</span>
<span class="nc" id="L1490">            tabins.setLow(0);</span>
<span class="nc" id="L1491">            tabins.setHigh(fmds.length - 1);</span>

<span class="nc bnc" id="L1493" title="All 2 branches missed.">            for (int i = 0; i &lt; fmds.length; i++) {</span>
                // &lt;field&gt; = other.&lt;field&gt;;
                // or set&lt;field&gt; (other.get&lt;field&gt;);
<span class="nc" id="L1496">                tabins.addTarget(loadManagedInstance(code, false, fmds[i]));</span>
<span class="nc" id="L1497">                code.aload().setParam(0);</span>
<span class="nc" id="L1498">                addGetManagedValueCode(code, fmds[i], false);</span>
<span class="nc" id="L1499">                addSetManagedValueCode(code, fmds[i]);</span>

                // break;
<span class="nc" id="L1502">                code.vreturn();</span>
            }

            // default: throw new IllegalArgumentException ()
<span class="nc" id="L1506">            tabins.setDefaultTarget(throwException</span>
<span class="nc" id="L1507">                (code, IllegalArgumentException.class));</span>
        }

<span class="nc" id="L1510">        code.calculateMaxStack();</span>
<span class="nc" id="L1511">        code.calculateMaxLocals();</span>

<span class="nc" id="L1513">        addMultipleFieldsMethodVersion(method);</span>
<span class="nc" id="L1514">    }</span>

    /**
     * Helper method to add the code common to the beginning of both the
     * pcReplaceField method and the pcProvideField method. This includes
     * calculating the relative field number of the desired field and calling
     * the superclass if necessary.
     *
     * @return the index in which the local variable holding the relative
     * field number is stored
     */
    private int beginSwitchMethod(String name, Code code) {
<span class="nc" id="L1526">        boolean copy = (PRE + &quot;CopyField&quot;).equals(name);</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">        int fieldNumber = (copy) ? 1 : 0;</span>

<span class="nc" id="L1529">        int relLocal = code.getNextLocalsIndex();</span>
<span class="nc bnc" id="L1530" title="All 2 branches missed.">        if (getCreateSubclass()) {</span>
<span class="nc" id="L1531">            code.iload().setParam(fieldNumber);</span>
<span class="nc" id="L1532">            code.istore().setLocal(relLocal);</span>
<span class="nc" id="L1533">            return relLocal;</span>
        }

        // int rel = fieldNumber - pcInheritedFieldCount
<span class="nc" id="L1537">        code.iload().setParam(fieldNumber);</span>
<span class="nc" id="L1538">        code.getstatic().setField(INHERIT, int.class);</span>
<span class="nc" id="L1539">        code.isub();</span>
<span class="nc" id="L1540">        code.istore().setLocal(relLocal);</span>
<span class="nc" id="L1541">        code.iload().setLocal(relLocal);</span>

        // super: if (rel &lt; 0) super.pcReplaceField (fieldNumber); return;
        // no super: if (rel &lt; 0) throw new IllegalArgumentException ();
<span class="nc" id="L1545">        JumpInstruction ifins = code.ifge();</span>
<span class="nc bnc" id="L1546" title="All 2 branches missed.">        if (_meta.getPCSuperclass() != null) {</span>
<span class="nc" id="L1547">            loadManagedInstance(code, false);</span>
            String[] args;
<span class="nc bnc" id="L1549" title="All 2 branches missed.">            if (copy) {</span>
<span class="nc" id="L1550">                args = new String[]{ getType(_meta.getPCSuperclassMetaData()).</span>
<span class="nc" id="L1551">                    getName(), int.class.getName() };</span>
<span class="nc" id="L1552">                code.aload().setParam(0);</span>
            } else
<span class="nc" id="L1554">                args = new String[]{ int.class.getName() };</span>
<span class="nc" id="L1555">            code.iload().setParam(fieldNumber);</span>
<span class="nc" id="L1556">            code.invokespecial().setMethod(getType(_meta.</span>
<span class="nc" id="L1557">                getPCSuperclassMetaData()).getName(), name,</span>
<span class="nc" id="L1558">                void.class.getName(), args);</span>
<span class="nc" id="L1559">            code.vreturn();</span>
<span class="nc" id="L1560">        } else</span>
<span class="nc" id="L1561">            throwException(code, IllegalArgumentException.class);</span>

<span class="nc" id="L1563">        ifins.setTarget(code.nop());</span>
<span class="nc" id="L1564">        return relLocal;</span>
    }

    /**
     * This helper method, given the pcReplaceField or pcProvideField
     * method, adds the bytecode for the corresponding 'plural' version
     * of the method -- the version that takes an int[] of fields to
     * to access rather than a single field. The multiple fields version
     * simply loops through the provided indexes and delegates to the
     * singular version for each one.
     */
    private void addMultipleFieldsMethodVersion(BCMethod single) {
<span class="nc" id="L1576">        boolean copy = (PRE + &quot;CopyField&quot;).equals(single.getName());</span>

        // public void &lt;method&gt;s (int[] fields)
<span class="nc bnc" id="L1579" title="All 2 branches missed.">        Class[] args = (copy) ? new Class[]{ Object.class, int[].class }</span>
<span class="nc" id="L1580">            : new Class[]{ int[].class };</span>
<span class="nc" id="L1581">        BCMethod method = _pc.declareMethod(single.getName() + &quot;s&quot;,</span>
            void.class, args);
<span class="nc" id="L1583">        Code code = method.getCode(true);</span>

<span class="nc" id="L1585">        int fieldNumbers = 0;</span>
<span class="nc" id="L1586">        int inst = 0;</span>
<span class="nc bnc" id="L1587" title="All 2 branches missed.">        if (copy) {</span>
<span class="nc" id="L1588">            fieldNumbers = 1;</span>

<span class="nc bnc" id="L1590" title="All 2 branches missed.">            if (getCreateSubclass()) {</span>
                // get the managed instance into the local variable table
<span class="nc" id="L1592">                code.aload().setParam(0);</span>
<span class="nc" id="L1593">                code.invokestatic().setMethod(ImplHelper.class,</span>
                    &quot;getManagedInstance&quot;, Object.class,
                    new Class[] { Object.class });
<span class="nc" id="L1596">                code.checkcast().setType(_managedType);</span>
<span class="nc" id="L1597">                inst = code.getNextLocalsIndex();</span>
<span class="nc" id="L1598">                code.astore().setLocal(inst);</span>

                // there might be a difference between the classes of 'this'
                // vs 'other' in this context; use the PC methods to get the SM
<span class="nc" id="L1602">                code.aload().setParam(0);</span>
<span class="nc" id="L1603">                code.aload().setThis();</span>
<span class="nc" id="L1604">                code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1605">                code.invokestatic().setMethod(ImplHelper.class,</span>
                    &quot;toPersistenceCapable&quot;, PersistenceCapable.class,
                    new Class[] { Object.class, Object.class });
<span class="nc" id="L1608">                code.invokeinterface().setMethod(PersistenceCapable.class,</span>
                    &quot;pcGetStateManager&quot;, StateManager.class, null);
            } else {
                // XXX other = (XXX) pc;
<span class="nc" id="L1612">                code.aload().setParam(0);</span>
<span class="nc" id="L1613">                code.checkcast().setType(_pc);</span>
<span class="nc" id="L1614">                inst = code.getNextLocalsIndex();</span>
<span class="nc" id="L1615">                code.astore().setLocal(inst);</span>

                // access the other's sm field directly
<span class="nc" id="L1618">                code.aload().setLocal(inst);</span>
<span class="nc" id="L1619">                code.getfield().setField(SM, SMTYPE);</span>
            }

            // if (other.pcStateManager != pcStateManager)
            //	throw new IllegalArgumentException

<span class="nc" id="L1625">            loadManagedInstance(code, false);</span>
<span class="nc" id="L1626">            code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1627">            JumpInstruction ifins = code.ifacmpeq();</span>
<span class="nc" id="L1628">            throwException(code, IllegalArgumentException.class);</span>
<span class="nc" id="L1629">            ifins.setTarget(code.nop());</span>

            // if (pcStateManager == null)
            //  throw new IllegalStateException
<span class="nc" id="L1633">            loadManagedInstance(code, false);</span>
<span class="nc" id="L1634">            code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1635">            ifins = code.ifnonnull();</span>
<span class="nc" id="L1636">            throwException(code, IllegalStateException.class);</span>
<span class="nc" id="L1637">            ifins.setTarget(code.nop());</span>
        }

        // for (int i = 0;
<span class="nc" id="L1641">        code.constant().setValue(0);</span>
<span class="nc" id="L1642">        int idx = code.getNextLocalsIndex();</span>
<span class="nc" id="L1643">        code.istore().setLocal(idx);</span>
<span class="nc" id="L1644">        JumpInstruction testins = code.go2();</span>

        // &lt;method&gt; (fields[i]);
<span class="nc" id="L1647">        Instruction bodyins = loadManagedInstance(code, false);</span>
<span class="nc bnc" id="L1648" title="All 2 branches missed.">        if (copy)</span>
<span class="nc" id="L1649">            code.aload().setLocal(inst);</span>
<span class="nc" id="L1650">        code.aload().setParam(fieldNumbers);</span>
<span class="nc" id="L1651">        code.iload().setLocal(idx);</span>
<span class="nc" id="L1652">        code.iaload();</span>
<span class="nc" id="L1653">        code.invokevirtual().setMethod(single);</span>

        // i++;
<span class="nc" id="L1656">        code.iinc().setIncrement(1).setLocal(idx);</span>

        // i &lt; fields.length
<span class="nc" id="L1659">        testins.setTarget(code.iload().setLocal(idx));</span>
<span class="nc" id="L1660">        code.aload().setParam(fieldNumbers);</span>
<span class="nc" id="L1661">        code.arraylength();</span>
<span class="nc" id="L1662">        code.ificmplt().setTarget(bodyins);</span>
<span class="nc" id="L1663">        code.vreturn();</span>

<span class="nc" id="L1665">        code.calculateMaxStack();</span>
<span class="nc" id="L1666">        code.calculateMaxLocals();</span>
<span class="nc" id="L1667">    }</span>

    /**
     * Adds the 'stock' methods to the bytecode; these include methods
     * like {@link PersistenceCapable#pcFetchObjectId}
     * and {@link PersistenceCapable#pcIsTransactional}.
     */
    private void addStockMethods()
        throws NoSuchMethodException {
        try {
            // pcGetGenericContext
<span class="nc" id="L1678">            translateFromStateManagerMethod(</span>
<span class="nc" id="L1679">                AccessController.doPrivileged(</span>
<span class="nc" id="L1680">                    J2DoPrivHelper.getDeclaredMethodAction(</span>
                        SMTYPE, &quot;get&quot; + CONTEXTNAME, (Class[]) null)), false);

            // pcFetchObjectId
<span class="nc" id="L1684">            translateFromStateManagerMethod(</span>
<span class="nc" id="L1685">                AccessController.doPrivileged(</span>
<span class="nc" id="L1686">                    J2DoPrivHelper.getDeclaredMethodAction(</span>
                        SMTYPE, &quot;fetchObjectId&quot;, (Class[]) null)), false);

            // pcIsDeleted
<span class="nc" id="L1690">            translateFromStateManagerMethod(</span>
<span class="nc" id="L1691">                AccessController.doPrivileged(</span>
<span class="nc" id="L1692">                    J2DoPrivHelper.getDeclaredMethodAction(</span>
                        SMTYPE, &quot;isDeleted&quot;, (Class[]) null)), false);

            // pcIsDirty
<span class="nc" id="L1696">            translateFromStateManagerMethod(</span>
<span class="nc" id="L1697">                AccessController.doPrivileged(</span>
<span class="nc" id="L1698">                    J2DoPrivHelper.getDeclaredMethodAction(</span>
                        SMTYPE, &quot;isDirty&quot;, (Class[]) null)), true);

            // pcIsNew
<span class="nc" id="L1702">            translateFromStateManagerMethod(</span>
<span class="nc" id="L1703">                AccessController.doPrivileged(</span>
<span class="nc" id="L1704">                    J2DoPrivHelper.getDeclaredMethodAction(</span>
                        SMTYPE, &quot;isNew&quot;, (Class[]) null)), false);

            // pcIsPersistent
<span class="nc" id="L1708">            translateFromStateManagerMethod(</span>
<span class="nc" id="L1709">                AccessController.doPrivileged(</span>
<span class="nc" id="L1710">                    J2DoPrivHelper.getDeclaredMethodAction(</span>
                        SMTYPE, &quot;isPersistent&quot;, (Class[]) null)), false);

            // pcIsTransactional
<span class="nc" id="L1714">            translateFromStateManagerMethod(</span>
<span class="nc" id="L1715">                AccessController.doPrivileged(</span>
<span class="nc" id="L1716">                    J2DoPrivHelper.getDeclaredMethodAction(</span>
                        SMTYPE, &quot;isTransactional&quot;, (Class[]) null)), false);

            // pcSerializing
<span class="nc" id="L1720">            translateFromStateManagerMethod(</span>
<span class="nc" id="L1721">                AccessController.doPrivileged(</span>
<span class="nc" id="L1722">                    J2DoPrivHelper.getDeclaredMethodAction(</span>
                        SMTYPE, &quot;serializing&quot;, (Class[]) null)), false);

            // pcDirty
<span class="nc" id="L1726">            translateFromStateManagerMethod(</span>
<span class="nc" id="L1727">                AccessController.doPrivileged(</span>
<span class="nc" id="L1728">                    J2DoPrivHelper.getDeclaredMethodAction(</span>
                        SMTYPE, &quot;dirty&quot;, new Class[]{ String.class })), false);

            // pcGetStateManager
<span class="nc" id="L1732">            BCMethod meth = _pc.declareMethod(PRE + &quot;GetStateManager&quot;,</span>
                StateManager.class, null);
<span class="nc" id="L1734">            Code code = meth.getCode(true);</span>
<span class="nc" id="L1735">            loadManagedInstance(code, false);</span>
<span class="nc" id="L1736">            code.getfield().setField(SM, StateManager.class);</span>
<span class="nc" id="L1737">            code.areturn();</span>
<span class="nc" id="L1738">            code.calculateMaxStack();</span>
<span class="nc" id="L1739">            code.calculateMaxLocals();</span>
<span class="nc" id="L1740">        } catch (PrivilegedActionException pae) {</span>
<span class="nc" id="L1741">             throw (NoSuchMethodException) pae.getException();</span>
<span class="nc" id="L1742">        }</span>
<span class="nc" id="L1743">    }</span>

    /**
     * Helper method to add a stock method to the bytecode. Each
     * stock method simply delegates to a corresponding StateManager method.
     * Given the StateManager method, then, this function translates it into
     * the wrapper method that should be added to the bytecode.
     */
    private void translateFromStateManagerMethod(Method m,
        boolean isDirtyCheckMethod) {
        // form the name of the method by prepending 'pc' to the sm method
<span class="nc" id="L1754">        String name = PRE + StringUtil.capitalize(m.getName());</span>
<span class="nc" id="L1755">        Class[] params = m.getParameterTypes();</span>
<span class="nc" id="L1756">        Class returnType = m.getReturnType();</span>

        // add the method to the pc
<span class="nc" id="L1759">        BCMethod method = _pc.declareMethod(name, returnType, params);</span>
<span class="nc" id="L1760">        Code code = method.getCode(true);</span>

        // if (pcStateManager == null) return &lt;default&gt;;
<span class="nc" id="L1763">        loadManagedInstance(code, false);</span>
<span class="nc" id="L1764">        code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1765">        JumpInstruction ifins = code.ifnonnull();</span>
<span class="nc bnc" id="L1766" title="All 2 branches missed.">        if (returnType.equals(boolean.class))</span>
<span class="nc" id="L1767">            code.constant().setValue(false);</span>
<span class="nc bnc" id="L1768" title="All 2 branches missed.">        else if (!returnType.equals(void.class))</span>
<span class="nc" id="L1769">            code.constant().setNull();</span>
<span class="nc" id="L1770">        code.xreturn().setType(returnType);</span>

        // if this is the dirty-check method and we're subclassing but not
        // redefining, hook into PCHelper to do the dirty check
<span class="nc bnc" id="L1774" title="All 4 branches missed.">        if (isDirtyCheckMethod &amp;&amp; !getRedefine()) {</span>
            // RedefinitionHelper.dirtyCheck(sm);
<span class="nc" id="L1776">            ifins.setTarget(loadManagedInstance(code, false));</span>
<span class="nc" id="L1777">            code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1778">            code.dup(); // for the return statement below</span>
<span class="nc" id="L1779">            code.invokestatic().setMethod(RedefinitionHelper.class,</span>
                &quot;dirtyCheck&quot;, void.class, new Class[] { SMTYPE });
        } else {
<span class="nc" id="L1782">            ifins.setTarget(loadManagedInstance(code, false));</span>
<span class="nc" id="L1783">            code.getfield().setField(SM, SMTYPE);</span>
        }

        // return pcStateManager.&lt;method&gt; (&lt;args&gt;);
        // managed instance loaded above in if-else block
<span class="nc bnc" id="L1788" title="All 2 branches missed.">        for (int i = 0; i &lt; params.length; i++)</span>
<span class="nc" id="L1789">            code.xload().setParam(i);</span>
<span class="nc" id="L1790">        code.invokeinterface().setMethod(m);</span>
<span class="nc" id="L1791">        code.xreturn().setType(returnType);</span>

<span class="nc" id="L1793">        code.calculateMaxStack();</span>
<span class="nc" id="L1794">        code.calculateMaxLocals();</span>
<span class="nc" id="L1795">    }</span>

    /**
     * Adds the {@link PersistenceCapable#pcGetVersion} method to the bytecode.
     */
    private void addGetVersionMethod()
        throws NoSuchMethodException {
<span class="nc" id="L1802">        BCMethod method = _pc.declareMethod(PRE + &quot;GetVersion&quot;, Object.class,</span>
            null);
<span class="nc" id="L1804">        Code code = method.getCode(true);</span>

        // if (pcStateManager == null)
<span class="nc" id="L1807">        loadManagedInstance(code, false);</span>
<span class="nc" id="L1808">        code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1809">        JumpInstruction ifins = code.ifnonnull();</span>
<span class="nc" id="L1810">        FieldMetaData versionField = _meta.getVersionField();</span>

<span class="nc bnc" id="L1812" title="All 2 branches missed.">        if (versionField == null)</span>
<span class="nc" id="L1813">            code.constant().setNull(); // return null;</span>
        else {
            // return &lt;versionField&gt;;
<span class="nc" id="L1816">            Class wrapper = toPrimitiveWrapper(versionField);</span>
<span class="nc bnc" id="L1817" title="All 2 branches missed.">            if (wrapper != versionField.getDeclaredType()) {</span>
<span class="nc" id="L1818">                code.anew().setType(wrapper);</span>
<span class="nc" id="L1819">                code.dup();</span>
            }
<span class="nc" id="L1821">            loadManagedInstance(code, false);</span>
<span class="nc" id="L1822">            addGetManagedValueCode(code, versionField);</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">            if (wrapper != versionField.getDeclaredType())</span>
<span class="nc" id="L1824">                code.invokespecial().setMethod(wrapper, &quot;&lt;init&gt;&quot;, void.class,</span>
<span class="nc" id="L1825">                    new Class[]{ versionField.getDeclaredType() });</span>
        }
<span class="nc" id="L1827">        code.areturn();</span>

        // return pcStateManager.getVersion ();
<span class="nc" id="L1830">        ifins.setTarget(loadManagedInstance(code, false));</span>
<span class="nc" id="L1831">        code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1832">        code.invokeinterface().setMethod(SMTYPE, &quot;getVersion&quot;, Object.class,</span>
            null);
<span class="nc" id="L1834">        code.areturn();</span>

<span class="nc" id="L1836">        code.calculateMaxStack();</span>
<span class="nc" id="L1837">        code.calculateMaxLocals();</span>
<span class="nc" id="L1838">    }</span>

    /**
     * Return the version field type as a primitive wrapper, or null if
     * the version field is not primitive.
     */
    private Class toPrimitiveWrapper(FieldMetaData fmd) {
<span class="nc bnc" id="L1845" title="All 9 branches missed.">        switch (fmd.getDeclaredTypeCode()) {</span>
            case JavaTypes.BOOLEAN:
<span class="nc" id="L1847">                return Boolean.class;</span>
            case JavaTypes.BYTE:
<span class="nc" id="L1849">                return Byte.class;</span>
            case JavaTypes.CHAR:
<span class="nc" id="L1851">                return Character.class;</span>
            case JavaTypes.DOUBLE:
<span class="nc" id="L1853">                return Double.class;</span>
            case JavaTypes.FLOAT:
<span class="nc" id="L1855">                return Float.class;</span>
            case JavaTypes.INT:
<span class="nc" id="L1857">                return Integer.class;</span>
            case JavaTypes.LONG:
<span class="nc" id="L1859">                return Long.class;</span>
            case JavaTypes.SHORT:
<span class="nc" id="L1861">                return Short.class;</span>
        }
<span class="nc" id="L1863">        return fmd.getDeclaredType();</span>
    }

    /**
     * Adds the {@link PersistenceCapable#pcReplaceStateManager}
     * method to the bytecode.
     */
    private void addReplaceStateManagerMethod() {
        // public void pcReplaceStateManager (StateManager sm)
<span class="nc" id="L1872">        BCMethod method = _pc.declareMethod(PRE + &quot;ReplaceStateManager&quot;,</span>
            void.class, new Class[]{ SMTYPE });
<span class="nc" id="L1874">        method.getExceptions(true).addException(SecurityException.class);</span>
<span class="nc" id="L1875">        Code code = method.getCode(true);</span>

        // if (pcStateManager != null)
        //	pcStateManager = pcStateManager.replaceStateManager(sm);
<span class="nc" id="L1879">        loadManagedInstance(code, false);</span>
<span class="nc" id="L1880">        code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1881">        JumpInstruction ifins = code.ifnull();</span>
<span class="nc" id="L1882">        loadManagedInstance(code, false);</span>
<span class="nc" id="L1883">        loadManagedInstance(code, false);</span>
<span class="nc" id="L1884">        code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1885">        code.aload().setParam(0);</span>
<span class="nc" id="L1886">        code.invokeinterface().setMethod(SMTYPE, &quot;replaceStateManager&quot;,</span>
            SMTYPE, new Class[]{ SMTYPE });
<span class="nc" id="L1888">        code.putfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1889">        code.vreturn();</span>

        // SecurityManager sec = System.getSecurityManager ();
        // if (sec != null)
        //		sec.checkPermission (Permission.SET_STATE_MANAGER);
<span class="nc" id="L1894">        ifins.setTarget(code.invokestatic().setMethod(System.class,</span>
            &quot;getSecurityManager&quot;, SecurityManager.class, null));

        // pcStateManager = sm;
<span class="nc" id="L1898">        ifins.setTarget(loadManagedInstance(code, false));</span>
<span class="nc" id="L1899">        code.aload().setParam(0);</span>
<span class="nc" id="L1900">        code.putfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L1901">        code.vreturn();</span>

<span class="nc" id="L1903">        code.calculateMaxStack();</span>
<span class="nc" id="L1904">        code.calculateMaxLocals();</span>
<span class="nc" id="L1905">    }</span>

    /**
     * Creates the PersistenceCapable methods dealing with application
     * identity and gives them no-op implementations.
     */
    private void addNoOpApplicationIdentityMethods() {
        // public void pcCopyKeyFieldsToObjectId (ObjectIdFieldSupplier fs,
        // 	Object oid)
<span class="nc" id="L1914">        BCMethod method = _pc.declareMethod(PRE + &quot;CopyKeyFieldsToObjectId&quot;,</span>
            void.class, new Class[]{ OIDFSTYPE, Object.class });
<span class="nc" id="L1916">        Code code = method.getCode(true);</span>
<span class="nc" id="L1917">        code.vreturn();</span>
<span class="nc" id="L1918">        code.calculateMaxLocals();</span>

        // public void pcCopyKeyFieldsToObjectId (Object oid)
<span class="nc" id="L1921">        method = _pc.declareMethod(PRE + &quot;CopyKeyFieldsToObjectId&quot;,</span>
            void.class, new Class[]{ Object.class });
<span class="nc" id="L1923">        code = method.getCode(true);</span>
<span class="nc" id="L1924">        code.vreturn();</span>
<span class="nc" id="L1925">        code.calculateMaxLocals();</span>

        // public void pcCopyKeyFieldsFromObjectId (ObjectIdFieldConsumer fc,
        //	Object oid)
<span class="nc" id="L1929">        method = _pc.declareMethod(PRE + &quot;CopyKeyFieldsFromObjectId&quot;,</span>
            void.class, new Class[]{ OIDFCTYPE, Object.class });
<span class="nc" id="L1931">        code = method.getCode(true);</span>
<span class="nc" id="L1932">        code.vreturn();</span>
<span class="nc" id="L1933">        code.calculateMaxLocals();</span>

        // public void pcCopyKeyFieldsFromObjectId (Object oid)
<span class="nc" id="L1936">        method = _pc.declareMethod(PRE + &quot;CopyKeyFieldsFromObjectId&quot;,</span>
            void.class, new Class[]{ Object.class });
<span class="nc" id="L1938">        code = method.getCode(true);</span>
<span class="nc" id="L1939">        code.vreturn();</span>
<span class="nc" id="L1940">        code.calculateMaxLocals();</span>

        // public Object pcNewObjectIdInstance ()
<span class="nc" id="L1943">        method = _pc.declareMethod(PRE + &quot;NewObjectIdInstance&quot;,</span>
            Object.class, null);
<span class="nc" id="L1945">        code = method.getCode(true);</span>
<span class="nc" id="L1946">        code.constant().setNull();</span>
<span class="nc" id="L1947">        code.areturn();</span>
<span class="nc" id="L1948">        code.calculateMaxStack();</span>
<span class="nc" id="L1949">        code.calculateMaxLocals();</span>

        // public Object pcNewObjectIdInstance (Object obj)
<span class="nc" id="L1952">        method = _pc.declareMethod(PRE + &quot;NewObjectIdInstance&quot;,</span>
            Object.class, new Class[]{ Object.class });
<span class="nc" id="L1954">        code = method.getCode(true);</span>
<span class="nc" id="L1955">        code.constant().setNull();</span>
<span class="nc" id="L1956">        code.areturn();</span>
<span class="nc" id="L1957">        code.calculateMaxStack();</span>
<span class="nc" id="L1958">        code.calculateMaxLocals();</span>
<span class="nc" id="L1959">    }</span>

    /**
     * Adds the &lt;code&gt;pcCopyKeyFieldsToObjectId&lt;/code&gt; methods
     * to classes using application identity.
     */
    private void addCopyKeyFieldsToObjectIdMethod(boolean fieldManager)
        throws NoSuchMethodException {
        // public void pcCopyKeyFieldsToObjectId (ObjectIdFieldSupplier fs,
        //	Object oid)
<span class="nc bnc" id="L1969" title="All 2 branches missed.">        String[] args = (fieldManager) ?</span>
<span class="nc" id="L1970">            new String[]{ OIDFSTYPE.getName(), Object.class.getName() }</span>
<span class="nc" id="L1971">            : new String[]{ Object.class.getName() };</span>
<span class="nc" id="L1972">        BCMethod method = _pc.declareMethod(PRE + &quot;CopyKeyFieldsToObjectId&quot;,</span>
<span class="nc" id="L1973">            void.class.getName(), args);</span>
<span class="nc" id="L1974">        Code code = method.getCode(true);</span>

        // single field identity always throws exception
<span class="nc bnc" id="L1977" title="All 2 branches missed.">        if (_meta.isOpenJPAIdentity()) {</span>
<span class="nc" id="L1978">            throwException(code, INTERNEXCEP);</span>

<span class="nc" id="L1980">            code.calculateMaxStack();</span>
<span class="nc" id="L1981">            code.calculateMaxLocals();</span>
<span class="nc" id="L1982">            return;</span>
        }

        // call superclass method
<span class="nc bnc" id="L1986" title="All 4 branches missed.">        if (_meta.getPCSuperclass() != null &amp;&amp; !getCreateSubclass()) {</span>
<span class="nc" id="L1987">            loadManagedInstance(code, false);</span>
<span class="nc bnc" id="L1988" title="All 2 branches missed.">            for (int i = 0; i &lt; args.length; i++)</span>
<span class="nc" id="L1989">                code.aload().setParam(i);</span>
<span class="nc" id="L1990">            code.invokespecial().setMethod(getType(_meta.</span>
<span class="nc" id="L1991">                getPCSuperclassMetaData()).getName(),</span>
<span class="nc" id="L1992">                PRE + &quot;CopyKeyFieldsToObjectId&quot;, void.class.getName(), args);</span>
        }

        // Object id = oid;
<span class="nc bnc" id="L1996" title="All 2 branches missed.">        if (fieldManager)</span>
<span class="nc" id="L1997">            code.aload().setParam(1);</span>
        else
<span class="nc" id="L1999">            code.aload().setParam(0);</span>

<span class="nc bnc" id="L2001" title="All 2 branches missed.">        if (_meta.isObjectIdTypeShared()) {</span>
            // oid = ((ObjectId) id).getId ();
<span class="nc" id="L2003">            code.checkcast().setType(ObjectId.class);</span>
<span class="nc" id="L2004">            code.invokevirtual().setMethod(ObjectId.class, &quot;getId&quot;,</span>
                Object.class, null);
        }

        // &lt;oid type&gt; id = (&lt;oid type&gt;) oid;
<span class="nc" id="L2009">        int id = code.getNextLocalsIndex();</span>
<span class="nc" id="L2010">        Class oidType = _meta.getObjectIdType();</span>
<span class="nc" id="L2011">        code.checkcast().setType(oidType);</span>
<span class="nc" id="L2012">        code.astore().setLocal(id);</span>

        // int inherited = pcInheritedFieldCount;
<span class="nc" id="L2015">        int inherited = 0;</span>
<span class="nc bnc" id="L2016" title="All 2 branches missed.">        if (fieldManager) {</span>
<span class="nc" id="L2017">            code.getstatic().setField(INHERIT, int.class);</span>
<span class="nc" id="L2018">            inherited = code.getNextLocalsIndex();</span>
<span class="nc" id="L2019">            code.istore().setLocal(inherited);</span>
        }

        // id.&lt;field&gt; = fs.fetch&lt;type&gt;Field (&lt;index&gt;); or...
        // id.&lt;field&gt; = pc.&lt;field&gt;;
<span class="nc bnc" id="L2024" title="All 2 branches missed.">        FieldMetaData[] fmds = getCreateSubclass() ? _meta.getFields()</span>
<span class="nc" id="L2025">            : _meta.getDeclaredFields();</span>
        Class&lt;?&gt; type;
        String name;
        Field field;
        Method setter;
        boolean reflect;
        // If optimizeIdCopy is enabled and not a field manager method, try to
        // optimize the copyTo by using a public constructor instead of reflection
<span class="nc bnc" id="L2033" title="All 2 branches missed.">        if (_optimizeIdCopy) {</span>
<span class="nc" id="L2034">            ArrayList&lt;Integer&gt; pkfields = optimizeIdCopy(oidType, fmds);</span>
<span class="nc bnc" id="L2035" title="All 2 branches missed.">            if (pkfields != null) {</span>
                // search for a constructor on the IdClass that can be used
                // to construct the IdClass
<span class="nc" id="L2038">                int parmOrder[] = getIdClassConstructorParmOrder(oidType, pkfields, fmds);</span>
<span class="nc bnc" id="L2039" title="All 2 branches missed.">                if (parmOrder != null) {</span>
                    // If using a field manager, values must be loaded into locals so they can be properly ordered
                    // as constructor parameters.
<span class="nc" id="L2042">                    int[] localIndexes = new int[fmds.length];</span>
<span class="nc bnc" id="L2043" title="All 2 branches missed.">                    if (fieldManager) {</span>
<span class="nc bnc" id="L2044" title="All 2 branches missed.">                        for (int k = 0; k &lt; fmds.length; k++) {</span>
<span class="nc bnc" id="L2045" title="All 2 branches missed.">                            if (!fmds[k].isPrimaryKey())</span>
<span class="nc" id="L2046">                                continue;</span>
<span class="nc" id="L2047">                            code.aload().setParam(0);</span>
<span class="nc" id="L2048">                            code.constant().setValue(k);</span>
<span class="nc" id="L2049">                            code.iload().setLocal(inherited);</span>
<span class="nc" id="L2050">                            code.iadd();</span>
<span class="nc" id="L2051">                            code.invokeinterface().setMethod(getFieldSupplierMethod(fmds[k].getObjectIdFieldType()));</span>
<span class="nc" id="L2052">                            localIndexes[k] = code.getNextLocalsIndex();</span>
<span class="nc" id="L2053">                            storeLocalValue(code, localIndexes[k], fmds[k].getObjectIdFieldTypeCode());</span>
                        }
                    }

                    // found a matching constructor.  parm array is constructor parm order
<span class="nc" id="L2058">                    code.anew().setType(oidType);</span>
<span class="nc" id="L2059">                    code.dup();</span>
                    // build the parm list in order
<span class="nc" id="L2061">                    Class&lt;?&gt;[] clsArgs = new Class&lt;?&gt;[parmOrder.length];</span>
<span class="nc bnc" id="L2062" title="All 2 branches missed.">                    for (int i = 0; i &lt; clsArgs.length; i++) {</span>
<span class="nc" id="L2063">                        int parmIndex = parmOrder[i];</span>
<span class="nc" id="L2064">                        clsArgs[i] = fmds[parmIndex].getObjectIdFieldType();</span>
<span class="nc bnc" id="L2065" title="All 2 branches missed.">                        if (!fieldManager) {</span>
<span class="nc" id="L2066">                            loadManagedInstance(code, false);</span>
<span class="nc" id="L2067">                            addGetManagedValueCode(code, fmds[parmIndex]);</span>
                        } else {
                            // Load constructor parameters in appropriate order
<span class="nc" id="L2070">                            loadLocalValue(code, localIndexes[parmIndex], fmds[parmIndex].getObjectIdFieldTypeCode());</span>
<span class="nc bnc" id="L2071" title="All 2 branches missed.">                            if (fmds[parmIndex].getObjectIdFieldTypeCode() == JavaTypes.OBJECT &amp;&amp;</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">                                !fmds[parmIndex].getDeclaredType().isEnum()) {</span>
<span class="nc" id="L2073">                                code.checkcast().setType(ObjectId.class);</span>
<span class="nc" id="L2074">                                code.invokevirtual().setMethod(ObjectId.class, &quot;getId&quot;,</span>
                                    Object.class, null);
                            }
                            // if the type of this field meta data is
                            // non-primitive and non-string, be sure to cast
                            // to the appropriate type.
<span class="nc bnc" id="L2080" title="All 2 branches missed.">                            if (!clsArgs[i].isPrimitive()</span>
<span class="nc bnc" id="L2081" title="All 2 branches missed.">                                &amp;&amp; !clsArgs[i].getName().equals(String.class.getName()))</span>
<span class="nc" id="L2082">                                code.checkcast().setType(clsArgs[i]);</span>
                        }
                    }
                    // invoke the public constructor to create a new local id
<span class="nc" id="L2086">                    code.invokespecial().setMethod(oidType, &quot;&lt;init&gt;&quot;, void.class, clsArgs);</span>
<span class="nc" id="L2087">                    int ret = code.getNextLocalsIndex();</span>
<span class="nc" id="L2088">                    code.astore().setLocal(ret);</span>

                    // swap out the app id with the new one
<span class="nc bnc" id="L2091" title="All 2 branches missed.">                    code.aload().setLocal( fieldManager ? 2 : 1);</span>
<span class="nc" id="L2092">                    code.checkcast().setType(ObjectId.class);</span>
<span class="nc" id="L2093">                    code.aload().setLocal(ret);</span>
<span class="nc" id="L2094">                    code.invokestatic().setMethod(ApplicationIds.class,</span>
                            &quot;setAppId&quot;, void.class, new Class[] { ObjectId.class,
                            Object.class });
<span class="nc" id="L2097">                    code.vreturn();</span>

<span class="nc" id="L2099">                    code.calculateMaxStack();</span>
<span class="nc" id="L2100">                    code.calculateMaxLocals();</span>
<span class="nc" id="L2101">                    return;</span>
                }
            }
        }

<span class="nc bnc" id="L2106" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L2107" title="All 2 branches missed.">            if (!fmds[i].isPrimaryKey())</span>
<span class="nc" id="L2108">                continue;</span>
<span class="nc" id="L2109">            code.aload().setLocal(id);</span>

<span class="nc" id="L2111">            name = fmds[i].getName();</span>
<span class="nc" id="L2112">            type = fmds[i].getObjectIdFieldType();</span>
<span class="nc bnc" id="L2113" title="All 2 branches missed.">            if (isFieldAccess(fmds[i])) {</span>
<span class="nc" id="L2114">                setter = null;</span>
<span class="nc" id="L2115">                field = Reflection.findField(oidType, name, true);</span>
<span class="nc bnc" id="L2116" title="All 2 branches missed.">                reflect = !Modifier.isPublic(field.getModifiers());</span>
<span class="nc bnc" id="L2117" title="All 2 branches missed.">                if (reflect) {</span>
<span class="nc" id="L2118">                    code.classconstant().setClass(oidType);</span>
<span class="nc" id="L2119">                    code.constant().setValue(name);</span>
<span class="nc" id="L2120">                    code.constant().setValue(true);</span>
<span class="nc" id="L2121">                    code.invokestatic().setMethod(Reflection.class,</span>
                        &quot;findField&quot;, Field.class, new Class[] { Class.class,
                        String.class, boolean.class });
                }
            } else {
<span class="nc" id="L2126">                field = null;</span>
<span class="nc" id="L2127">                setter = Reflection.findSetter(oidType, name, type, true);</span>
<span class="nc bnc" id="L2128" title="All 2 branches missed.">                reflect = !Modifier.isPublic(setter.getModifiers());</span>
<span class="nc bnc" id="L2129" title="All 2 branches missed.">                if (reflect) {</span>
<span class="nc" id="L2130">                    code.classconstant().setClass(oidType);</span>
<span class="nc" id="L2131">                    code.constant().setValue(name);</span>
<span class="nc" id="L2132">                    code.classconstant().setClass(type);</span>
<span class="nc" id="L2133">                    code.constant().setValue(true);</span>
<span class="nc" id="L2134">                    code.invokestatic().setMethod(Reflection.class,</span>
                        &quot;findSetter&quot;, Method.class, new Class[] { Class.class,
                        String.class, Class.class, boolean.class });
                }
            }

<span class="nc bnc" id="L2140" title="All 2 branches missed.">            if (fieldManager) {</span>
<span class="nc" id="L2141">                code.aload().setParam(0);</span>
<span class="nc" id="L2142">                code.constant().setValue(i);</span>
<span class="nc" id="L2143">                code.iload().setLocal(inherited);</span>
<span class="nc" id="L2144">                code.iadd();</span>
<span class="nc" id="L2145">                code.invokeinterface().setMethod</span>
<span class="nc" id="L2146">                    (getFieldSupplierMethod(type));</span>
<span class="nc bnc" id="L2147" title="All 2 branches missed.">                if (fmds[i].getObjectIdFieldTypeCode() == JavaTypes.OBJECT &amp;&amp;</span>
<span class="nc bnc" id="L2148" title="All 2 branches missed.">                    !fmds[i].getDeclaredType().isEnum()) {</span>
<span class="nc" id="L2149">                	code.checkcast().setType(ObjectId.class);</span>
<span class="nc" id="L2150">                	code.invokevirtual().setMethod(ObjectId.class, &quot;getId&quot;,</span>
            			Object.class, null);
                }

                // if the type of this field meta data is
                // non-primitive and non-string, be sure to cast
                // to the appropriate type.
<span class="nc bnc" id="L2157" title="All 4 branches missed.">                if (!reflect &amp;&amp; !type.isPrimitive()</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">                    &amp;&amp; !type.getName().equals(String.class.getName()))</span>
<span class="nc" id="L2159">                    code.checkcast().setType(type);</span>
            } else {
<span class="nc" id="L2161">                loadManagedInstance(code, false);</span>
<span class="nc" id="L2162">                addGetManagedValueCode(code, fmds[i]);</span>

                // get id/pk from pc instance
<span class="nc bnc" id="L2165" title="All 2 branches missed.">                if (fmds[i].getDeclaredTypeCode() == JavaTypes.PC)</span>
<span class="nc" id="L2166">                    addExtractObjectIdFieldValueCode(code, fmds[i]);</span>
            }

<span class="nc bnc" id="L2169" title="All 4 branches missed.">            if (reflect &amp;&amp; field != null) {</span>
<span class="nc" id="L2170">                code.invokestatic().setMethod(Reflection.class, &quot;set&quot;,</span>
                    void.class, new Class[] { Object.class, Field.class,
<span class="nc bnc" id="L2172" title="All 2 branches missed.">                    (type.isPrimitive()) ? type : Object.class });</span>
<span class="nc bnc" id="L2173" title="All 2 branches missed.">            } else if (reflect) {</span>
<span class="nc" id="L2174">                code.invokestatic().setMethod(Reflection.class, &quot;set&quot;,</span>
                    void.class, new Class[] { Object.class, Method.class,
<span class="nc bnc" id="L2176" title="All 2 branches missed.">                    (type.isPrimitive()) ? type : Object.class });</span>
<span class="nc bnc" id="L2177" title="All 2 branches missed.">            } else if (field != null)</span>
<span class="nc" id="L2178">                code.putfield().setField(field);</span>
            else
<span class="nc" id="L2180">                code.invokevirtual().setMethod(setter);</span>
        }
<span class="nc" id="L2182">        code.vreturn();</span>

<span class="nc" id="L2184">        code.calculateMaxStack();</span>
<span class="nc" id="L2185">        code.calculateMaxLocals();</span>
<span class="nc" id="L2186">    }</span>

    /**
     * Adds the appropriate load method for the given type and local
     * index.
     */
    private void loadLocalValue(Code code, int locidx, int typeCode) {
<span class="nc bnc" id="L2193" title="All 5 branches missed.">        switch (typeCode) {</span>
            case JavaTypes.CHAR:
            case JavaTypes.BYTE:
            case JavaTypes.SHORT:
            case JavaTypes.INT:
<span class="nc" id="L2198">                code.iload().setLocal(locidx);</span>
<span class="nc" id="L2199">                break;</span>
            case JavaTypes.DOUBLE:
<span class="nc" id="L2201">                code.dload().setLocal(locidx);</span>
<span class="nc" id="L2202">                break;</span>
            case JavaTypes.FLOAT:
<span class="nc" id="L2204">                code.fload().setLocal(locidx);</span>
<span class="nc" id="L2205">                break;</span>
            case JavaTypes.LONG:
<span class="nc" id="L2207">                code.lload().setLocal(locidx);</span>
<span class="nc" id="L2208">                break;</span>
            default:
<span class="nc" id="L2210">                code.aload().setLocal(locidx);</span>
                break;
        }
<span class="nc" id="L2213">    }</span>

    /**
     * Adds the appropriate store method for the given type and local
     * index.
     */
    private void storeLocalValue(Code code, int locidx, int typeCode) {
<span class="nc bnc" id="L2220" title="All 5 branches missed.">        switch (typeCode) {</span>
            case JavaTypes.CHAR:
            case JavaTypes.BYTE:
            case JavaTypes.SHORT:
            case JavaTypes.INT:
<span class="nc" id="L2225">                code.istore().setLocal(locidx);</span>
<span class="nc" id="L2226">                break;</span>
            case JavaTypes.DOUBLE:
<span class="nc" id="L2228">                code.dstore().setLocal(locidx);</span>
<span class="nc" id="L2229">                break;</span>
            case JavaTypes.FLOAT:
<span class="nc" id="L2231">                code.fstore().setLocal(locidx);</span>
<span class="nc" id="L2232">                break;</span>
            case JavaTypes.LONG:
<span class="nc" id="L2234">                code.lstore().setLocal(locidx);</span>
<span class="nc" id="L2235">                break;</span>
            default:
<span class="nc" id="L2237">                code.astore().setLocal(locidx);</span>
                break;
        }
<span class="nc" id="L2240">    }</span>

    /**
     * Add code to extract the id of the given primary key relation field for
     * setting into an objectid instance.
     */
    private void addExtractObjectIdFieldValueCode(Code code, FieldMetaData pk) {
        // if (val != null)
        //  val = ((PersistenceCapable) val).pcFetchObjectId();
<span class="nc" id="L2249">        int pc = code.getNextLocalsIndex();</span>
<span class="nc" id="L2250">        code.astore().setLocal(pc);</span>
<span class="nc" id="L2251">        code.aload().setLocal(pc);</span>
<span class="nc" id="L2252">        JumpInstruction ifnull1 = code.ifnull();</span>
<span class="nc" id="L2253">        code.aload().setLocal(pc);</span>
<span class="nc" id="L2254">        code.checkcast().setType(PersistenceCapable.class);</span>
<span class="nc bnc" id="L2255" title="All 2 branches missed.">        if (!pk.getTypeMetaData().isOpenJPAIdentity())</span>
<span class="nc" id="L2256">            code.invokeinterface().setMethod(PersistenceCapable.class,</span>
                PRE + &quot;FetchObjectId&quot;, Object.class, null);
        else
<span class="nc" id="L2259">            code.invokeinterface().setMethod(PersistenceCapable.class,</span>
                PRE + &quot;NewObjectIdInstance&quot;, Object.class, null);

<span class="nc" id="L2262">        int oid = code.getNextLocalsIndex();</span>
<span class="nc" id="L2263">        code.astore().setLocal(oid);</span>
<span class="nc" id="L2264">        code.aload().setLocal(oid);</span>
<span class="nc" id="L2265">        JumpInstruction ifnull2 = code.ifnull();</span>

        // for datastore / single-field identity:
        // if (val != null)
        //   val = ((OpenJPAId) val).getId();
<span class="nc" id="L2270">        ClassMetaData pkmeta = pk.getDeclaredTypeMetaData();</span>
<span class="nc" id="L2271">        int pkcode = pk.getObjectIdFieldTypeCode();</span>
<span class="nc" id="L2272">        Class pktype = pk.getObjectIdFieldType();</span>
<span class="nc bnc" id="L2273" title="All 4 branches missed.">        if (pkmeta.getIdentityType() == ClassMetaData.ID_DATASTORE</span>
            &amp;&amp; pkcode == JavaTypes.LONG) {
<span class="nc" id="L2275">            code.aload().setLocal(oid);</span>
<span class="nc" id="L2276">            code.checkcast().setType(Id.class);</span>
<span class="nc" id="L2277">            code.invokevirtual().setMethod(Id.class, &quot;getId&quot;,</span>
                long.class, null);
<span class="nc bnc" id="L2279" title="All 2 branches missed.">        } else if (pkmeta.getIdentityType() == ClassMetaData.ID_DATASTORE) {</span>
<span class="nc" id="L2280">            code.aload().setLocal(oid);</span>
<span class="nc bnc" id="L2281" title="All 2 branches missed.">        } else if (pkmeta.isOpenJPAIdentity()) {</span>
<span class="nc bnc" id="L2282" title="All 19 branches missed.">            switch (pkcode) {</span>
                case JavaTypes.BYTE_OBJ:
<span class="nc" id="L2284">                    code.anew().setType(Byte.class);</span>
<span class="nc" id="L2285">                    code.dup();</span>
                    // no break
                case JavaTypes.BYTE:
<span class="nc" id="L2288">                    code.aload().setLocal(oid);</span>
<span class="nc" id="L2289">                    code.checkcast().setType(ByteId.class);</span>
<span class="nc" id="L2290">                    code.invokevirtual().setMethod(ByteId.class, &quot;getId&quot;,</span>
                        byte.class, null);
<span class="nc bnc" id="L2292" title="All 2 branches missed.">                    if (pkcode == JavaTypes.BYTE_OBJ)</span>
<span class="nc" id="L2293">                        code.invokespecial().setMethod(Byte.class, &quot;&lt;init&gt;&quot;,</span>
                            void.class, new Class[] {byte.class});
                    break;
                case JavaTypes.CHAR_OBJ:
<span class="nc" id="L2297">                    code.anew().setType(Character.class);</span>
<span class="nc" id="L2298">                    code.dup();</span>
                    // no break
                case JavaTypes.CHAR:
<span class="nc" id="L2301">                    code.aload().setLocal(oid);</span>
<span class="nc" id="L2302">                    code.checkcast().setType(CharId.class);</span>
<span class="nc" id="L2303">                    code.invokevirtual().setMethod(CharId.class, &quot;getId&quot;,</span>
                        char.class, null);
<span class="nc bnc" id="L2305" title="All 2 branches missed.">                    if (pkcode == JavaTypes.CHAR_OBJ)</span>
<span class="nc" id="L2306">                        code.invokespecial().setMethod(Character.class,</span>
                            &quot;&lt;init&gt;&quot;, void.class, new Class[] {char.class});
                    break;
                case JavaTypes.DOUBLE_OBJ:
<span class="nc" id="L2310">                    code.anew().setType(Double.class);</span>
<span class="nc" id="L2311">                    code.dup();</span>
                    // no break
                case JavaTypes.DOUBLE:
<span class="nc" id="L2314">                    code.aload().setLocal(oid);</span>
<span class="nc" id="L2315">                    code.checkcast().setType(DoubleId.class);</span>
<span class="nc" id="L2316">                    code.invokevirtual().setMethod(DoubleId.class, &quot;getId&quot;,</span>
                        double.class, null);
<span class="nc bnc" id="L2318" title="All 2 branches missed.">                    if (pkcode == JavaTypes.DOUBLE_OBJ)</span>
<span class="nc" id="L2319">                        code.invokespecial().setMethod(Double.class, &quot;&lt;init&gt;&quot;,</span>
                            void.class, new Class[]{double.class});
                    break;
                case JavaTypes.FLOAT_OBJ:
<span class="nc" id="L2323">                    code.anew().setType(Float.class);</span>
<span class="nc" id="L2324">                    code.dup();</span>
                    // no break
                case JavaTypes.FLOAT:
<span class="nc" id="L2327">                    code.aload().setLocal(oid);</span>
<span class="nc" id="L2328">                    code.checkcast().setType(FloatId.class);</span>
<span class="nc" id="L2329">                    code.invokevirtual().setMethod(FloatId.class, &quot;getId&quot;,</span>
                        float.class, null);
<span class="nc bnc" id="L2331" title="All 2 branches missed.">                    if (pkcode == JavaTypes.FLOAT_OBJ)</span>
<span class="nc" id="L2332">                        code.invokespecial().setMethod(Float.class, &quot;&lt;init&gt;&quot;,</span>
                            void.class, new Class[]{float.class});
                    break;
                case JavaTypes.INT_OBJ:
<span class="nc" id="L2336">                    code.anew().setType(Integer.class);</span>
<span class="nc" id="L2337">                    code.dup();</span>
                    // no break
                case JavaTypes.INT:
<span class="nc" id="L2340">                    code.aload().setLocal(oid);</span>
<span class="nc" id="L2341">                    code.checkcast().setType(IntId.class);</span>
<span class="nc" id="L2342">                    code.invokevirtual().setMethod(IntId.class, &quot;getId&quot;,</span>
                        int.class, null);
<span class="nc bnc" id="L2344" title="All 2 branches missed.">                    if (pkcode == JavaTypes.INT_OBJ)</span>
<span class="nc" id="L2345">                        code.invokespecial().setMethod(Integer.class, &quot;&lt;init&gt;&quot;,</span>
                            void.class, new Class[] {int.class});
                    break;
                case JavaTypes.LONG_OBJ:
<span class="nc" id="L2349">                    code.anew().setType(Long.class);</span>
<span class="nc" id="L2350">                    code.dup();</span>
                    // no break
                case JavaTypes.LONG:
<span class="nc" id="L2353">                    code.aload().setLocal(oid);</span>
<span class="nc" id="L2354">                    code.checkcast().setType(LongId.class);</span>
<span class="nc" id="L2355">                    code.invokevirtual().setMethod(LongId.class, &quot;getId&quot;,</span>
                        long.class, null);
<span class="nc bnc" id="L2357" title="All 2 branches missed.">                    if (pkcode == JavaTypes.LONG_OBJ)</span>
<span class="nc" id="L2358">                        code.invokespecial().setMethod(Long.class, &quot;&lt;init&gt;&quot;,</span>
                            void.class, new Class[] {long.class});
                    break;
                case JavaTypes.SHORT_OBJ:
<span class="nc" id="L2362">                    code.anew().setType(Short.class);</span>
<span class="nc" id="L2363">                    code.dup();</span>
                    // no break
                case JavaTypes.SHORT:
<span class="nc" id="L2366">                    code.aload().setLocal(oid);</span>
<span class="nc" id="L2367">                    code.checkcast().setType(ShortId.class);</span>
<span class="nc" id="L2368">                    code.invokevirtual().setMethod(ShortId.class, &quot;getId&quot;,</span>
                        short.class, null);
<span class="nc bnc" id="L2370" title="All 2 branches missed.">                    if (pkcode == JavaTypes.SHORT_OBJ)</span>
<span class="nc" id="L2371">                        code.invokespecial().setMethod(Short.class, &quot;&lt;init&gt;&quot;,</span>
                            void.class, new Class[]{short.class});
                    break;
                case JavaTypes.DATE:
<span class="nc" id="L2375">                    code.aload().setLocal(oid);</span>
<span class="nc" id="L2376">                    code.checkcast().setType(DateId.class);</span>
<span class="nc" id="L2377">                    code.invokevirtual().setMethod(DateId.class, &quot;getId&quot;,</span>
                        Date.class, null);
<span class="nc bnc" id="L2379" title="All 2 branches missed.">                    if (pktype != Date.class) {</span>
                        // java.sql.Date.class
<span class="nc" id="L2381">                        code.checkcast().setType(pktype);</span>
                    }
                    break;
                case JavaTypes.STRING:
<span class="nc" id="L2385">                    code.aload().setLocal(oid);</span>
<span class="nc" id="L2386">                    code.checkcast().setType(StringId.class);</span>
<span class="nc" id="L2387">                    code.invokevirtual().setMethod(StringId.class, &quot;getId&quot;,</span>
                        String.class, null);
<span class="nc" id="L2389">                    break;</span>
                case JavaTypes.BIGDECIMAL:
<span class="nc" id="L2391">                    code.aload().setLocal(oid);</span>
<span class="nc" id="L2392">                    code.checkcast().setType(BigDecimalId.class);</span>
<span class="nc" id="L2393">                    code.invokevirtual().setMethod(BigDecimalId.class, &quot;getId&quot;,</span>
                        BigDecimal.class, null);
<span class="nc" id="L2395">                    break;</span>
                case JavaTypes.BIGINTEGER:
<span class="nc" id="L2397">                    code.aload().setLocal(oid);</span>
<span class="nc" id="L2398">                    code.checkcast().setType(BigIntegerId.class);</span>
<span class="nc" id="L2399">                    code.invokevirtual().setMethod(BigIntegerId.class, &quot;getId&quot;,</span>
                        BigInteger.class, null);
<span class="nc" id="L2401">                    break;</span>
                default:
<span class="nc" id="L2403">                    code.aload().setLocal(oid);</span>
<span class="nc" id="L2404">                    code.checkcast().setType(ObjectId.class);</span>
<span class="nc" id="L2405">                    code.invokevirtual().setMethod(ObjectId.class, &quot;getId&quot;,</span>
                        Object.class, null);
            }
<span class="nc bnc" id="L2408" title="All 2 branches missed.">        } else if (pkmeta.getObjectIdType() != null) {</span>
<span class="nc" id="L2409">            code.aload().setLocal(oid);</span>
<span class="nc bnc" id="L2410" title="All 2 branches missed.">            if (pkcode == JavaTypes.OBJECT) {</span>
<span class="nc" id="L2411">                code.checkcast().setType(ObjectId.class);</span>
<span class="nc" id="L2412">                code.invokevirtual().setMethod(ObjectId.class, &quot;getId&quot;,</span>
            			Object.class, null);
            }
<span class="nc" id="L2415">            code.checkcast().setType(pktype);</span>
        } else
<span class="nc" id="L2417">            code.aload().setLocal(oid);</span>
<span class="nc" id="L2418">        JumpInstruction go2 = code.go2();</span>

        // if (val == null)
        //   val = &lt;default&gt;;
        Instruction def;
<span class="nc bnc" id="L2423" title="All 9 branches missed.">        switch (pkcode) {</span>
            case JavaTypes.BOOLEAN:
<span class="nc" id="L2425">                def = code.constant().setValue(false);</span>
<span class="nc" id="L2426">                break;</span>
            case JavaTypes.BYTE:
<span class="nc" id="L2428">                def = code.constant().setValue((byte) 0);</span>
<span class="nc" id="L2429">                break;</span>
            case JavaTypes.CHAR:
<span class="nc" id="L2431">                def = code.constant().setValue((char) 0);</span>
<span class="nc" id="L2432">                break;</span>
            case JavaTypes.DOUBLE:
<span class="nc" id="L2434">                def = code.constant().setValue(0D);</span>
<span class="nc" id="L2435">                break;</span>
            case JavaTypes.FLOAT:
<span class="nc" id="L2437">                def = code.constant().setValue(0F);</span>
<span class="nc" id="L2438">                break;</span>
            case JavaTypes.INT:
<span class="nc" id="L2440">                def = code.constant().setValue(0);</span>
<span class="nc" id="L2441">                break;</span>
            case JavaTypes.LONG:
<span class="nc" id="L2443">                def = code.constant().setValue(0L);</span>
<span class="nc" id="L2444">                break;</span>
            case JavaTypes.SHORT:
<span class="nc" id="L2446">                def = code.constant().setValue((short) 0);</span>
<span class="nc" id="L2447">                break;</span>
            default:
<span class="nc" id="L2449">                def = code.constant().setNull();</span>
        }
<span class="nc" id="L2451">        ifnull1.setTarget(def);</span>
<span class="nc" id="L2452">        ifnull2.setTarget(def);</span>
<span class="nc" id="L2453">        go2.setTarget(code.nop());</span>
<span class="nc" id="L2454">    }</span>

    /**
     * Adds the &lt;code&gt;pcCopyKeyFieldsFromObjectId&lt;/code&gt; methods
     * to classes using application identity.
     */
    private void addCopyKeyFieldsFromObjectIdMethod(boolean fieldManager)
        throws NoSuchMethodException {
        // public void pcCopyKeyFieldsFromObjectId (ObjectIdFieldConsumer fc,
        //	Object oid)
<span class="nc bnc" id="L2464" title="All 2 branches missed.">        String[] args = (fieldManager)</span>
<span class="nc" id="L2465">            ?  new String[]{ OIDFCTYPE.getName(), Object.class.getName() }</span>
<span class="nc" id="L2466">            : new String[]{ Object.class.getName() };</span>
<span class="nc" id="L2467">        BCMethod method = _pc.declareMethod(PRE + &quot;CopyKeyFieldsFromObjectId&quot;,</span>
<span class="nc" id="L2468">            void.class.getName(), args);</span>
<span class="nc" id="L2469">        Code code = method.getCode(true);</span>

        // call superclass method
<span class="nc bnc" id="L2472" title="All 4 branches missed.">        if (_meta.getPCSuperclass() != null &amp;&amp; !getCreateSubclass()) {</span>
<span class="nc" id="L2473">            loadManagedInstance(code, false);</span>
<span class="nc bnc" id="L2474" title="All 2 branches missed.">            for (int i = 0; i &lt; args.length; i++)</span>
<span class="nc" id="L2475">                code.aload().setParam(i);</span>
<span class="nc" id="L2476">            code.invokespecial().setMethod(getType(_meta.</span>
<span class="nc" id="L2477">                getPCSuperclassMetaData()).getName(),</span>
<span class="nc" id="L2478">                PRE + &quot;CopyKeyFieldsFromObjectId&quot;, void.class.getName(), args);</span>
        }

<span class="nc bnc" id="L2481" title="All 2 branches missed.">        if (fieldManager)</span>
<span class="nc" id="L2482">            code.aload().setParam(1);</span>
        else
<span class="nc" id="L2484">            code.aload().setParam(0);</span>

<span class="nc bnc" id="L2486" title="All 4 branches missed.">        if (!_meta.isOpenJPAIdentity() &amp;&amp; _meta.isObjectIdTypeShared()) {</span>
            // oid = ((ObjectId) id).getId ();
<span class="nc" id="L2488">            code.checkcast().setType(ObjectId.class);</span>
<span class="nc" id="L2489">            code.invokevirtual().setMethod(ObjectId.class, &quot;getId&quot;,</span>
                Object.class, null);
        }

        // &lt;oid type&gt; cast = (&lt;oid type&gt;) oid;
<span class="nc" id="L2494">        int id = code.getNextLocalsIndex();</span>
<span class="nc" id="L2495">        Class oidType = _meta.getObjectIdType();</span>
<span class="nc" id="L2496">        code.checkcast().setType(oidType);</span>
<span class="nc" id="L2497">        code.astore().setLocal(id);</span>

        // fs.store&lt;type&gt;Field (&lt;index&gt;, id.&lt;field&gt;); or...
        // this.&lt;field&gt; = id.&lt;field&gt;
        // or for single field identity: id.getId ()
<span class="nc bnc" id="L2502" title="All 2 branches missed.">        FieldMetaData[] fmds = getCreateSubclass() ? _meta.getFields()</span>
<span class="nc" id="L2503">            : _meta.getDeclaredFields();</span>
        String name;
        Class type;
        Class unwrapped;
        Field field;
        Method getter;
<span class="nc bnc" id="L2509" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L2510" title="All 2 branches missed.">            if (!fmds[i].isPrimaryKey())</span>
<span class="nc" id="L2511">                continue;</span>

<span class="nc" id="L2513">            name = fmds[i].getName();</span>
<span class="nc" id="L2514">            type = fmds[i].getObjectIdFieldType();</span>
<span class="nc bnc" id="L2515" title="All 2 branches missed.">            if (!fieldManager</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">                &amp;&amp; fmds[i].getDeclaredTypeCode() == JavaTypes.PC) {</span>
                // if (sm == null) return;
<span class="nc" id="L2518">                loadManagedInstance(code, false);</span>
<span class="nc" id="L2519">                code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L2520">                JumpInstruction ifins = code.ifnonnull();</span>
<span class="nc" id="L2521">                code.vreturn();</span>
                // sm.getPCPrimaryKey(oid, i + pcInheritedFieldCount);
<span class="nc" id="L2523">                ifins.setTarget(loadManagedInstance(code, false));</span>
<span class="nc" id="L2524">                code.dup(); // leave orig on stack to set value into</span>
<span class="nc" id="L2525">                code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L2526">                code.aload().setLocal(id);</span>
<span class="nc" id="L2527">                code.constant().setValue(i);</span>
<span class="nc" id="L2528">                code.getstatic().setField(INHERIT, int.class);</span>
<span class="nc" id="L2529">                code.iadd();</span>
<span class="nc" id="L2530">                code.invokeinterface().setMethod(StateManager.class,</span>
                    &quot;getPCPrimaryKey&quot;, Object.class,
                    new Class[] { Object.class, int.class });
<span class="nc" id="L2533">                code.checkcast().setType(fmds[i].getDeclaredType());</span>
<span class="nc" id="L2534">            } else {</span>
<span class="nc bnc" id="L2535" title="All 2 branches missed.">                unwrapped = (fmds[i].getDeclaredTypeCode() == JavaTypes.PC)</span>
<span class="nc" id="L2536">                    ? type : unwrapSingleFieldIdentity(fmds[i]);</span>
<span class="nc bnc" id="L2537" title="All 2 branches missed.">                if (fieldManager) {</span>
<span class="nc" id="L2538">                    code.aload().setParam(0);</span>
<span class="nc" id="L2539">                    code.constant().setValue(i);</span>
<span class="nc" id="L2540">                    code.getstatic().setField(INHERIT, int.class);</span>
<span class="nc" id="L2541">                    code.iadd();</span>
                } else
<span class="nc" id="L2543">                    loadManagedInstance(code, false);</span>

<span class="nc bnc" id="L2545" title="All 2 branches missed.">                if (unwrapped != type) {</span>
<span class="nc" id="L2546">                    code.anew().setType(type);</span>
<span class="nc" id="L2547">                    code.dup();</span>
                }
<span class="nc" id="L2549">                code.aload().setLocal(id);</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">                if (_meta.isOpenJPAIdentity()) {</span>
<span class="nc bnc" id="L2551" title="All 2 branches missed.">                    if (oidType == ObjectId.class) {</span>
<span class="nc" id="L2552">                        code.invokevirtual().setMethod(oidType, &quot;getId&quot;,</span>
                            Object.class, null);
<span class="nc bnc" id="L2554" title="All 4 branches missed.">                        if (!fieldManager &amp;&amp; type != Object.class)</span>
<span class="nc" id="L2555">                            code.checkcast().setType(fmds[i].getDeclaredType());</span>
<span class="nc bnc" id="L2556" title="All 2 branches missed.">                    } else if (oidType == DateId.class) {</span>
<span class="nc" id="L2557">                        code.invokevirtual().setMethod(oidType, &quot;getId&quot;,</span>
                            Date.class, null);
<span class="nc bnc" id="L2559" title="All 4 branches missed.">                        if (!fieldManager &amp;&amp; type != Date.class)</span>
<span class="nc" id="L2560">                            code.checkcast().setType(fmds[i].getDeclaredType());</span>
                    } else {
<span class="nc" id="L2562">                        code.invokevirtual().setMethod(oidType, &quot;getId&quot;,</span>
                            unwrapped, null);
<span class="nc bnc" id="L2564" title="All 2 branches missed.">                        if (unwrapped != type)</span>
<span class="nc" id="L2565">                            code.invokespecial().setMethod(type, &quot;&lt;init&gt;&quot;,</span>
                                void.class, new Class[]{ unwrapped });
                    }
<span class="nc bnc" id="L2568" title="All 2 branches missed.">                } else if (isFieldAccess(fmds[i])) {</span>
<span class="nc" id="L2569">                    field = Reflection.findField(oidType, name, true);</span>
<span class="nc bnc" id="L2570" title="All 2 branches missed.">                    if (Modifier.isPublic(field.getModifiers()))</span>
<span class="nc" id="L2571">                        code.getfield().setField(field);</span>
                    else {
<span class="nc" id="L2573">                        boolean usedFastOid = false;</span>
<span class="nc bnc" id="L2574" title="All 2 branches missed.">                        if (_optimizeIdCopy) {</span>
                            // If fastOids, ignore access type and try to use a public getter
<span class="nc" id="L2576">                            getter = Reflection.findGetter(oidType, name, false);</span>
<span class="nc bnc" id="L2577" title="All 4 branches missed.">                            if (getter != null &amp;&amp; Modifier.isPublic(getter.getModifiers())) {</span>
<span class="nc" id="L2578">                                usedFastOid = true;</span>
<span class="nc" id="L2579">                                code.invokevirtual().setMethod(getter);</span>
                            }
                        }
<span class="nc bnc" id="L2582" title="All 2 branches missed.">                        if (!usedFastOid) {</span>
                            // Reflection.getXXX(oid, Reflection.findField(...));
<span class="nc" id="L2584">                            code.classconstant().setClass(oidType);</span>
<span class="nc" id="L2585">                            code.constant().setValue(name);</span>
<span class="nc" id="L2586">                            code.constant().setValue(true);</span>
<span class="nc" id="L2587">                            code.invokestatic().setMethod(Reflection.class,</span>
                                &quot;findField&quot;, Field.class, new Class[] {
                                Class.class, String.class, boolean.class });
<span class="nc" id="L2590">                            code.invokestatic().setMethod</span>
<span class="nc" id="L2591">                                (getReflectionGetterMethod(type, Field.class));</span>
<span class="nc bnc" id="L2592" title="All 4 branches missed.">                            if (!type.isPrimitive() &amp;&amp; type != Object.class)</span>
<span class="nc" id="L2593">                                code.checkcast().setType(type);</span>
                        }
<span class="nc" id="L2595">                    }</span>
                } else {
<span class="nc" id="L2597">                    getter = Reflection.findGetter(oidType, name, true);</span>
<span class="nc bnc" id="L2598" title="All 2 branches missed.">                    if (Modifier.isPublic(getter.getModifiers()))</span>
<span class="nc" id="L2599">                        code.invokevirtual().setMethod(getter);</span>
                    else {
                        // Reflection.getXXX(oid, Reflection.findGetter(...));
<span class="nc" id="L2602">                        code.classconstant().setClass(oidType);</span>
<span class="nc" id="L2603">                        code.constant().setValue(name);</span>
<span class="nc" id="L2604">                        code.constant().setValue(true);</span>
<span class="nc" id="L2605">                        code.invokestatic().setMethod(Reflection.class,</span>
                            &quot;findGetter&quot;, Method.class, new Class[] {
                            Class.class, String.class, boolean.class });
<span class="nc" id="L2608">                        code.invokestatic().setMethod</span>
<span class="nc" id="L2609">                            (getReflectionGetterMethod(type, Method.class));</span>
<span class="nc bnc" id="L2610" title="All 4 branches missed.">                        if (!type.isPrimitive() &amp;&amp; type != Object.class)</span>
<span class="nc" id="L2611">                            code.checkcast().setType(type);</span>
                    }
                }
            }

<span class="nc bnc" id="L2616" title="All 2 branches missed.">            if (fieldManager)</span>
<span class="nc" id="L2617">                code.invokeinterface().setMethod(getFieldConsumerMethod(type));</span>
            else
<span class="nc" id="L2619">                addSetManagedValueCode(code, fmds[i]);</span>
        }
<span class="nc" id="L2621">        code.vreturn();</span>

<span class="nc" id="L2623">        code.calculateMaxStack();</span>
<span class="nc" id="L2624">        code.calculateMaxLocals();</span>
<span class="nc" id="L2625">    }</span>

    /**
     * Return if the class uses the Class/String constructor
     * instead of just String.
     */
    private Boolean usesClassStringIdConstructor() {
<span class="nc bnc" id="L2632" title="All 2 branches missed.">        if (_meta.getIdentityType() != ClassMetaData.ID_APPLICATION)</span>
<span class="nc" id="L2633">            return Boolean.FALSE;</span>

<span class="nc bnc" id="L2635" title="All 2 branches missed.">        if (_meta.isOpenJPAIdentity()) {</span>
<span class="nc bnc" id="L2636" title="All 2 branches missed.">            if (_meta.getObjectIdType() == ObjectId.class)</span>
<span class="nc" id="L2637">                return null;</span>
<span class="nc" id="L2638">            return Boolean.TRUE;</span>
        }

<span class="nc" id="L2641">        Class oidType = _meta.getObjectIdType();</span>
        try {
<span class="nc" id="L2643">            oidType.getConstructor(new Class[]{ Class.class, String.class });</span>
<span class="nc" id="L2644">            return Boolean.TRUE;</span>
<span class="nc" id="L2645">        } catch (Throwable t) {</span>
        }
        try {
<span class="nc" id="L2648">            oidType.getConstructor(new Class[]{ String.class });</span>
<span class="nc" id="L2649">            return Boolean.FALSE;</span>
<span class="nc" id="L2650">        } catch (Throwable t) {</span>
        }
<span class="nc" id="L2652">        return null;</span>
    }

    /**
     * If the given field is a wrapper-type single field identity primary key,
     * return its corresponding primitive class. Else return the field type.
     */
    private Class unwrapSingleFieldIdentity(FieldMetaData fmd) {
<span class="nc bnc" id="L2660" title="All 2 branches missed.">        if (!fmd.getDefiningMetaData().isOpenJPAIdentity())</span>
<span class="nc" id="L2661">            return fmd.getDeclaredType();</span>

<span class="nc bnc" id="L2663" title="All 8 branches missed.">        switch (fmd.getDeclaredTypeCode()) {</span>
            case JavaTypes.BYTE_OBJ:
<span class="nc" id="L2665">                return byte.class;</span>
            case JavaTypes.CHAR_OBJ:
<span class="nc" id="L2667">                return char.class;</span>
            case JavaTypes.DOUBLE_OBJ:
<span class="nc" id="L2669">                return double.class;</span>
            case JavaTypes.FLOAT_OBJ:
<span class="nc" id="L2671">                return float.class;</span>
            case JavaTypes.INT_OBJ:
<span class="nc" id="L2673">                return int.class;</span>
            case JavaTypes.SHORT_OBJ:
<span class="nc" id="L2675">                return short.class;</span>
            case JavaTypes.LONG_OBJ:
<span class="nc" id="L2677">                return long.class;</span>
            default:
<span class="nc" id="L2679">                return fmd.getDeclaredType();</span>
        }
    }

    /**
     * Return the proper getter method of the {@link Reflection} helper for
     * a field or getter method of the given type.
     */
    private Method getReflectionGetterMethod(Class type, Class argType)
        throws NoSuchMethodException {
<span class="nc" id="L2689">        String name = &quot;get&quot;;</span>
<span class="nc bnc" id="L2690" title="All 2 branches missed.">        if (type.isPrimitive())</span>
<span class="nc" id="L2691">            name += StringUtil.capitalize(type.getName());</span>
<span class="nc" id="L2692">        return Reflection.class.getMethod(name, new Class[] { Object.class,</span>
            argType });
    }

    /**
     * Return the proper fetch method of the ObjectIdFieldSupplier for
     * a field of the given type.
     */
    private Method getFieldSupplierMethod(Class type)
        throws NoSuchMethodException {
<span class="nc" id="L2702">        return getMethod(OIDFSTYPE, type, &quot;fetch&quot;, true, false, false);</span>
    }

    /**
     * Return the proper fetch method of the ObjectIdFieldConsumer for
     * a field of the given type.
     */
    private Method getFieldConsumerMethod(Class type)
        throws NoSuchMethodException {
<span class="nc" id="L2711">        return getMethod(OIDFCTYPE, type, &quot;store&quot;, false, false, false);</span>
    }

    /**
     * Adds the pcNewObjectIdInstance method to classes using
     * application identity.
     */
    private void addNewObjectIdInstanceMethod(boolean obj)
        throws NoSuchMethodException {
        // public Object pcNewObjectIdInstance ()
<span class="nc bnc" id="L2721" title="All 2 branches missed.">        Class[] args = (obj) ? new Class[]{ Object.class } : null;</span>
<span class="nc" id="L2722">        BCMethod method = _pc.declareMethod(PRE + &quot;NewObjectIdInstance&quot;,</span>
            Object.class, args);
<span class="nc" id="L2724">        Code code = method.getCode(true);</span>

<span class="nc" id="L2726">        Boolean usesClsString = usesClassStringIdConstructor();</span>
<span class="nc" id="L2727">        Class oidType = _meta.getObjectIdType();</span>
<span class="nc bnc" id="L2728" title="All 4 branches missed.">        if (obj &amp;&amp; usesClsString == null) {</span>
            // throw new IllegalArgumentException (...);
<span class="nc" id="L2730">            String msg = _loc.get(&quot;str-cons&quot;, oidType,</span>
<span class="nc" id="L2731">                _meta.getDescribedType()).getMessage();</span>
<span class="nc" id="L2732">            code.anew().setType(IllegalArgumentException.class);</span>
<span class="nc" id="L2733">            code.dup();</span>
<span class="nc" id="L2734">            code.constant().setValue(msg);</span>
<span class="nc" id="L2735">            code.invokespecial().setMethod(IllegalArgumentException.class,</span>
                &quot;&lt;init&gt;&quot;, void.class, new Class[]{ String.class });
<span class="nc" id="L2737">            code.athrow();</span>

<span class="nc" id="L2739">            code.calculateMaxStack();</span>
<span class="nc" id="L2740">            code.calculateMaxLocals();</span>
<span class="nc" id="L2741">            return;</span>
        }

<span class="nc bnc" id="L2744" title="All 4 branches missed.">        if (!_meta.isOpenJPAIdentity() &amp;&amp; _meta.isObjectIdTypeShared()) {</span>
            // new ObjectId (cls, oid)
<span class="nc" id="L2746">            code.anew().setType(ObjectId.class);</span>
<span class="nc" id="L2747">            code.dup();</span>
<span class="nc bnc" id="L2748" title="All 4 branches missed.">            if(_meta.isEmbeddedOnly() || _meta.hasAbstractPKField() == true) {</span>
<span class="nc" id="L2749">                code.aload().setThis();</span>
<span class="nc" id="L2750">                code.invokevirtual().setMethod(PRE + &quot;GetIDOwningClass&quot;,</span>
                    Class.class, null);
            } else {
<span class="nc" id="L2753">                code.classconstant().setClass(getType(_meta));</span>
            }
        }

        // new &lt;oid class&gt; ();
<span class="nc" id="L2758">        code.anew().setType(oidType);</span>
<span class="nc" id="L2759">        code.dup();</span>
<span class="nc bnc" id="L2760" title="All 6 branches missed.">        if (_meta.isOpenJPAIdentity() || (obj &amp;&amp; usesClsString == Boolean.TRUE)) {</span>
<span class="nc bnc" id="L2761" title="All 2 branches missed.">            if ((_meta.isEmbeddedOnly()</span>
<span class="nc bnc" id="L2762" title="All 4 branches missed.">                &amp;&amp; !(_meta.isEmbeddable() &amp;&amp; _meta.getIdentityType() == ClassMetaData.ID_APPLICATION))</span>
<span class="nc bnc" id="L2763" title="All 2 branches missed.">                || _meta.hasAbstractPKField() == true) {</span>
<span class="nc" id="L2764">                code.aload().setThis();</span>
<span class="nc" id="L2765">                code.invokevirtual().setMethod(PRE + &quot;GetIDOwningClass&quot;, Class.class, null);</span>
            } else {
<span class="nc" id="L2767">                code.classconstant().setClass(getType(_meta));</span>
            }
        }
<span class="nc bnc" id="L2770" title="All 2 branches missed.">        if (obj) {</span>
<span class="nc" id="L2771">            code.aload().setParam(0);</span>
<span class="nc" id="L2772">            code.checkcast().setType(String.class);</span>
<span class="nc bnc" id="L2773" title="All 2 branches missed.">            if (usesClsString == Boolean.TRUE)</span>
<span class="nc" id="L2774">                args = new Class[]{ Class.class, String.class };</span>
<span class="nc bnc" id="L2775" title="All 2 branches missed.">            else if (usesClsString == Boolean.FALSE)</span>
<span class="nc" id="L2776">                args = new Class[]{ String.class };</span>
<span class="nc bnc" id="L2777" title="All 2 branches missed.">        } else if (_meta.isOpenJPAIdentity()) {</span>
            // new &lt;type&gt;Identity (XXX.class, &lt;pk&gt;);
<span class="nc" id="L2779">            loadManagedInstance(code, false);</span>
<span class="nc" id="L2780">            FieldMetaData pk = _meta.getPrimaryKeyFields()[0];</span>
<span class="nc" id="L2781">            addGetManagedValueCode(code, pk);</span>
<span class="nc bnc" id="L2782" title="All 2 branches missed.">            if (pk.getDeclaredTypeCode() == JavaTypes.PC)</span>
<span class="nc" id="L2783">                addExtractObjectIdFieldValueCode(code, pk);</span>
<span class="nc bnc" id="L2784" title="All 2 branches missed.">            if (_meta.getObjectIdType() == ObjectId.class)</span>
<span class="nc" id="L2785">                args = new Class[]{ Class.class, Object.class };</span>
<span class="nc bnc" id="L2786" title="All 2 branches missed.">            else if (_meta.getObjectIdType() == Date.class)</span>
<span class="nc" id="L2787">                args = new Class[]{ Class.class, Date.class };</span>
            else
<span class="nc" id="L2789">                args = new Class[]{ Class.class, pk.getObjectIdFieldType() };</span>
        }

<span class="nc" id="L2792">        code.invokespecial().setMethod(oidType, &quot;&lt;init&gt;&quot;, void.class, args);</span>
<span class="nc bnc" id="L2793" title="All 4 branches missed.">        if (!_meta.isOpenJPAIdentity() &amp;&amp; _meta.isObjectIdTypeShared())</span>
<span class="nc" id="L2794">            code.invokespecial().setMethod(ObjectId.class, &quot;&lt;init&gt;&quot;,</span>
                void.class, new Class[]{ Class.class, Object.class });
<span class="nc" id="L2796">        code.areturn();</span>

<span class="nc" id="L2798">        code.calculateMaxStack();</span>
<span class="nc" id="L2799">        code.calculateMaxLocals();</span>
<span class="nc" id="L2800">    }</span>

    /**
     * When communicating with the StateManager, many methods are used
     * depending on the class of state being passed. This method,
     * given the type of information being passed and the prefix
     * ('provided', 'replace', etc) of the method to
     * call, returns the StateManager method that should be used.
     *
     * @param type the type of state being passed
     * @param prefix the prefix of the method to call; all methods
     * end in '[state type]Field'; only the prefix varies
     * @param get true if receiving information from the
     * StateManager, false if passing it to the SM
     * @param curValue true if the current state value is passed to
     * the StateManager as an extra argument
     */
    private Method getStateManagerMethod(Class type, String prefix,
        boolean get, boolean curValue)
        throws NoSuchMethodException {
<span class="nc" id="L2820">        return getMethod(SMTYPE, type, prefix, get, true, curValue);</span>
    }

    /**
     * Return the method of the given owner type matching the given criteria.
     *
     * @param type the type of state being passed
     * @param prefix the prefix of the method to call; all methods
     * end in '[state type]Field'; only the prefix varies
     * @param get true if receiving information from the
     * owner, false if passing it to the owner
     * @param haspc true if the pc is passed as an extra argument
     * @param curValue true if the current state value is passed to
     * the owner as an extra argument
     */
    private Method getMethod(Class owner, Class type, String prefix,
        boolean get, boolean haspc, boolean curValue)
        throws NoSuchMethodException {
        // all methods end in [field type]Field, where the field type
        // can be any of the primitve types (but capitalized), 'String',
        // or 'Object'; figure out what type to use
<span class="nc" id="L2841">        String typeName = type.getName();</span>
<span class="nc bnc" id="L2842" title="All 2 branches missed.">        if (type.isPrimitive())</span>
<span class="nc" id="L2843">            typeName = typeName.substring(0, 1).toUpperCase(Locale.ENGLISH)</span>
<span class="nc" id="L2844">                + typeName.substring(1);</span>
<span class="nc bnc" id="L2845" title="All 2 branches missed.">        else if (type.equals(String.class))</span>
<span class="nc" id="L2846">            typeName = &quot;String&quot;;</span>
        else {
<span class="nc" id="L2848">            typeName = &quot;Object&quot;;</span>
<span class="nc" id="L2849">            type = Object.class;</span>
        }

        // the field index is always passed as an arg; the pc instance and
        // the current value may be passed; if setting the new value is
        // also passed
<span class="nc" id="L2855">        List plist = new ArrayList(4);</span>
<span class="nc bnc" id="L2856" title="All 2 branches missed.">        if (haspc)</span>
<span class="nc" id="L2857">            plist.add(PCTYPE);</span>
<span class="nc" id="L2858">        plist.add(int.class);</span>
<span class="nc bnc" id="L2859" title="All 4 branches missed.">        if (!get || curValue)</span>
<span class="nc" id="L2860">            plist.add(type);</span>
<span class="nc bnc" id="L2861" title="All 4 branches missed.">        if (!get &amp;&amp; curValue) {</span>
<span class="nc" id="L2862">            plist.add(type);</span>
<span class="nc" id="L2863">            plist.add(int.class);</span>
        }

        // use reflection to return the right method
<span class="nc" id="L2867">        String name = prefix + typeName + &quot;Field&quot;;</span>
<span class="nc" id="L2868">        Class[] params = (Class[]) plist.toArray(new Class[plist.size()]);</span>

        try {
<span class="nc" id="L2871">            return AccessController.doPrivileged(</span>
<span class="nc" id="L2872">                J2DoPrivHelper.getDeclaredMethodAction(owner, name, params));</span>
<span class="nc" id="L2873">        } catch (PrivilegedActionException pae) {</span>
<span class="nc" id="L2874">             throw (NoSuchMethodException) pae.getException();</span>
        }
    }

    /**
     * Helper method to add the code necessary to throw the given
     * exception type, sans message.
     */
    private Instruction throwException(Code code, Class type) {
<span class="nc" id="L2883">        Instruction ins = code.anew().setType(type);</span>
<span class="nc" id="L2884">        code.dup();</span>
<span class="nc" id="L2885">        code.invokespecial().setMethod(type, &quot;&lt;init&gt;&quot;, void.class, null);</span>
<span class="nc" id="L2886">        code.athrow();</span>
<span class="nc" id="L2887">        return ins;</span>
    }

    /**
     * Adds the PersistenceCapable interface to the class being
     * enhanced, and adds a default constructor for use by OpenJPA
     * if it is not already present.
     */
    private void enhanceClass() {
        // make the class implement PersistenceCapable
<span class="nc" id="L2897">        _pc.declareInterface(PCTYPE);</span>

        // add a version stamp
<span class="nc" id="L2900">        addGetEnhancementContractVersionMethod();</span>

        // find the default constructor
<span class="nc" id="L2903">        BCMethod method = _pc.getDeclaredMethod(&quot;&lt;init&gt;&quot;, (String[]) null);</span>

        // a default constructor is required
<span class="nc bnc" id="L2906" title="All 2 branches missed.">        if (method == null) {</span>
<span class="nc" id="L2907">            String name = _pc.getName();</span>
<span class="nc bnc" id="L2908" title="All 2 branches missed.">            if (!_defCons)</span>
<span class="nc" id="L2909">                throw new UserException(_loc.get(&quot;enhance-defaultconst&quot;, name));</span>

<span class="nc" id="L2911">            method = _pc.addDefaultConstructor();</span>
            String access;
<span class="nc bnc" id="L2913" title="All 2 branches missed.">            if (_meta.isDetachable()) {</span>
                // externalizable requires that the constructor
                // be public, so make the added constructor public
<span class="nc" id="L2916">                method.makePublic();</span>
<span class="nc" id="L2917">                access = &quot;public&quot;;</span>
<span class="nc bnc" id="L2918" title="All 2 branches missed.">            } else if (_pc.isFinal()) {</span>
<span class="nc" id="L2919">                method.makePrivate();</span>
<span class="nc" id="L2920">                access = &quot;private&quot;;</span>
            } else {
<span class="nc" id="L2922">                method.makeProtected();</span>
<span class="nc" id="L2923">                access = &quot;protected&quot;;</span>
            }
<span class="nc bnc" id="L2925" title="All 4 branches missed.">            if (!(_meta.getDescribedType().isInterface() || getCreateSubclass())</span>
<span class="nc bnc" id="L2926" title="All 2 branches missed.">                &amp;&amp; _log.isWarnEnabled())</span>
<span class="nc" id="L2927">                _log.warn(_loc.get(&quot;enhance-adddefaultconst&quot;, name, access));</span>
        }
<span class="nc" id="L2929">    }</span>

    /**
     * Adds the following fields to the PersistenceCapable instance:
     * &lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;private static int pcInheritedFieldCount&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;private static Class pcPCSuperclass&lt;/code&gt;
     * &lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;private static String[] pcFieldNames&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;private static Class[] pcFieldTypes&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;private static byte[] pcFieldFlags&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;protected transient StateManager pcStateManager&lt;/code&gt;
     * if no PersistenceCapable superclass present)&lt;/li&gt;
     * &lt;/ul&gt;
     */
    private void addFields() {
<span class="nc" id="L2945">        _pc.declareField(INHERIT, int.class).setStatic(true);</span>
<span class="nc" id="L2946">        _pc.declareField(PRE + &quot;FieldNames&quot;, String[].class).setStatic(true);</span>
<span class="nc" id="L2947">        _pc.declareField(PRE + &quot;FieldTypes&quot;, Class[].class).setStatic(true);</span>
<span class="nc" id="L2948">        _pc.declareField(PRE + &quot;FieldFlags&quot;, byte[].class).setStatic(true);</span>
<span class="nc" id="L2949">        _pc.declareField(SUPER, Class.class).setStatic(true);</span>
<span class="nc bnc" id="L2950" title="All 4 branches missed.">        if (_addVersionInitFlag &amp;&amp; _meta.getVersionField() != null) {</span>
            // protected transient boolean pcVersionInit;
<span class="nc" id="L2952">            BCField field = _pc.declareField(VERSION_INIT_STR, boolean.class);</span>
<span class="nc" id="L2953">            field.makeProtected();</span>
<span class="nc" id="L2954">            field.setTransient(true);</span>
        }
<span class="nc bnc" id="L2956" title="All 4 branches missed.">        if (_meta.getPCSuperclass() == null || getCreateSubclass()) {</span>
<span class="nc" id="L2957">            BCField field = _pc.declareField(SM, SMTYPE);</span>
<span class="nc" id="L2958">            field.makeProtected();</span>
<span class="nc" id="L2959">            field.setTransient(true);</span>
        }
<span class="nc" id="L2961">    }</span>

    /**
     * Modifies the class initialization method (creating one if necessary)
     * to initialize the static fields of the PersistenceCapable instance and
     * to register it with the impl helper.
     */
    private void addStaticInitializer() {
<span class="nc" id="L2969">        Code code = getOrCreateClassInitCode(true);</span>
<span class="nc bnc" id="L2970" title="All 2 branches missed.">        if (_meta.getPCSuperclass() != null) {</span>
<span class="nc bnc" id="L2971" title="All 2 branches missed.">            if (getCreateSubclass()) {</span>
<span class="nc" id="L2972">                code.constant().setValue(0);</span>
<span class="nc" id="L2973">                code.putstatic().setField(INHERIT, int.class);</span>
            } else {
                // pcInheritedFieldCount = &lt;superClass&gt;.pcGetManagedFieldCount()
<span class="nc" id="L2976">                code.invokestatic().setMethod(getType(_meta.</span>
<span class="nc" id="L2977">                    getPCSuperclassMetaData()).getName(),</span>
<span class="nc" id="L2978">                    PRE + &quot;GetManagedFieldCount&quot;, int.class.getName(), null);</span>
<span class="nc" id="L2979">                code.putstatic().setField(INHERIT, int.class);</span>
            }

            // pcPCSuperclass = &lt;superClass&gt;;
            // this intentionally calls getDescribedType() directly
            // instead of PCEnhancer.getType()
<span class="nc" id="L2985">            code.classconstant().setClass(</span>
<span class="nc" id="L2986">                _meta.getPCSuperclassMetaData().getDescribedType());</span>
<span class="nc" id="L2987">            code.putstatic().setField(SUPER, Class.class);</span>
        }

        // pcFieldNames = new String[] { &quot;&lt;name1&gt;&quot;, &quot;&lt;name2&gt;&quot;, ... };
<span class="nc" id="L2991">        FieldMetaData[] fmds = _meta.getDeclaredFields();</span>
<span class="nc" id="L2992">        code.constant().setValue(fmds.length);</span>
<span class="nc" id="L2993">        code.anewarray().setType(String.class);</span>
<span class="nc bnc" id="L2994" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc" id="L2995">            code.dup();</span>
<span class="nc" id="L2996">            code.constant().setValue(i);</span>
<span class="nc" id="L2997">            code.constant().setValue(fmds[i].getName());</span>
<span class="nc" id="L2998">            code.aastore();</span>
        }
<span class="nc" id="L3000">        code.putstatic().setField(PRE + &quot;FieldNames&quot;, String[].class);</span>

        // pcFieldTypes = new Class[] { &lt;type1&gt;.class, &lt;type2&gt;.class, ... };
<span class="nc" id="L3003">        code.constant().setValue(fmds.length);</span>
<span class="nc" id="L3004">        code.anewarray().setType(Class.class);</span>
<span class="nc bnc" id="L3005" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc" id="L3006">            code.dup();</span>
<span class="nc" id="L3007">            code.constant().setValue(i);</span>
<span class="nc" id="L3008">            code.classconstant().setClass(fmds[i].getDeclaredType());</span>
<span class="nc" id="L3009">            code.aastore();</span>
        }
<span class="nc" id="L3011">        code.putstatic().setField(PRE + &quot;FieldTypes&quot;, Class[].class);</span>

        // pcFieldFlags = new byte[] { &lt;flag1&gt;, &lt;flag2&gt;, ... };
<span class="nc" id="L3014">        code.constant().setValue(fmds.length);</span>
<span class="nc" id="L3015">        code.newarray().setType(byte.class);</span>
<span class="nc bnc" id="L3016" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc" id="L3017">            code.dup();</span>
<span class="nc" id="L3018">            code.constant().setValue(i);</span>
<span class="nc" id="L3019">            code.constant().setValue(getFieldFlag(fmds[i]));</span>
<span class="nc" id="L3020">            code.bastore();</span>
        }
<span class="nc" id="L3022">        code.putstatic().setField(PRE + &quot;FieldFlags&quot;, byte[].class);</span>

        // PCRegistry.register (cls,
        //	pcFieldNames, pcFieldTypes, pcFieldFlags,
        //  pcPCSuperclass, alias, new XXX ());
<span class="nc" id="L3027">        code.classconstant().setClass(_meta.getDescribedType());</span>
<span class="nc" id="L3028">        code.getstatic().setField(PRE + &quot;FieldNames&quot;, String[].class);</span>
<span class="nc" id="L3029">        code.getstatic().setField(PRE + &quot;FieldTypes&quot;, Class[].class);</span>
<span class="nc" id="L3030">        code.getstatic().setField(PRE + &quot;FieldFlags&quot;, byte[].class);</span>
<span class="nc" id="L3031">        code.getstatic().setField(SUPER, Class.class);</span>

<span class="nc bnc" id="L3033" title="All 4 branches missed.">        if (_meta.isMapped() || _meta.isAbstract())</span>
<span class="nc" id="L3034">            code.constant().setValue(_meta.getTypeAlias());</span>
        else
<span class="nc" id="L3036">            code.constant().setNull();</span>

<span class="nc bnc" id="L3038" title="All 2 branches missed.">        if (_pc.isAbstract())</span>
<span class="nc" id="L3039">            code.constant().setNull();</span>
        else {
<span class="nc" id="L3041">            code.anew().setType(_pc);</span>
<span class="nc" id="L3042">            code.dup();</span>
<span class="nc" id="L3043">            code.invokespecial().setMethod(&quot;&lt;init&gt;&quot;, void.class, null);</span>
        }

<span class="nc" id="L3046">        code.invokestatic().setMethod(HELPERTYPE, &quot;register&quot;, void.class,</span>
            new Class[]{ Class.class, String[].class, Class[].class,
                byte[].class, Class.class, String.class, PCTYPE });

<span class="nc" id="L3050">        code.vreturn();</span>
<span class="nc" id="L3051">        code.calculateMaxStack();</span>
<span class="nc" id="L3052">    }</span>

    /**
     * Return the flag for the given field.
     */
    private static byte getFieldFlag(FieldMetaData fmd) {
<span class="nc bnc" id="L3058" title="All 2 branches missed.">        if (fmd.getManagement() == FieldMetaData.MANAGE_NONE)</span>
<span class="nc" id="L3059">            return -1;</span>

<span class="nc" id="L3061">        byte flags = 0;</span>
<span class="nc bnc" id="L3062" title="All 2 branches missed.">        if (fmd.getDeclaredType().isPrimitive()</span>
<span class="nc bnc" id="L3063" title="All 2 branches missed.">            || Serializable.class.isAssignableFrom(fmd.getDeclaredType()))</span>
<span class="nc" id="L3064">            flags = PersistenceCapable.SERIALIZABLE;</span>

<span class="nc bnc" id="L3066" title="All 2 branches missed.">        if (fmd.getManagement() == FieldMetaData.MANAGE_TRANSACTIONAL)</span>
<span class="nc" id="L3067">            flags |= PersistenceCapable.CHECK_WRITE;</span>
<span class="nc bnc" id="L3068" title="All 4 branches missed.">        else if (!fmd.isPrimaryKey() &amp;&amp; !fmd.isInDefaultFetchGroup())</span>
<span class="nc" id="L3069">            flags |= PersistenceCapable.CHECK_WRITE</span>
                | PersistenceCapable.CHECK_READ;
        else
<span class="nc" id="L3072">            flags |= PersistenceCapable.MEDIATE_WRITE</span>
                | PersistenceCapable.MEDIATE_READ;
<span class="nc" id="L3074">        return flags;</span>
    }

    /**
     * Adds the code to properly handle PersistenceCapable serialization
     * to the bytecode. This includes creating and initializing the
     * static &lt;code&gt;serialVersionUID&lt;/code&gt; constant if not already defined,
     * as well as creating a custom &lt;code&gt;writeObject&lt;/code&gt; method if the
     * class is Serializable and does not define them.
     */
    private void addSerializationCode() {
<span class="nc bnc" id="L3085" title="All 2 branches missed.">        if (externalizeDetached()</span>
<span class="nc bnc" id="L3086" title="All 2 branches missed.">            || !Serializable.class.isAssignableFrom(_meta.getDescribedType()))</span>
<span class="nc" id="L3087">            return;</span>

<span class="nc bnc" id="L3089" title="All 2 branches missed.">        if (getCreateSubclass()) {</span>
            // ##### what should happen if a type is Externalizable? It looks
            // ##### like Externalizable classes will not be serialized as PCs
            // ##### based on this logic.
<span class="nc bnc" id="L3093" title="All 2 branches missed.">            if (!Externalizable.class.isAssignableFrom(</span>
<span class="nc" id="L3094">                _meta.getDescribedType()))</span>
<span class="nc" id="L3095">                addSubclassSerializationCode();</span>
<span class="nc" id="L3096">            return;</span>
        }

        // if not already present, add a serialVersionUID field; if the instance
        // is detachable and uses detached state without a declared field,
        // can't add a serial version UID because we'll be adding extra fields
        // to the enhanced version
<span class="nc" id="L3103">        BCField field = _pc.getDeclaredField(&quot;serialVersionUID&quot;);</span>
<span class="nc bnc" id="L3104" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L3105">            Long uid = null;</span>
            try {
<span class="nc" id="L3107">                uid = ObjectStreamClass.lookup</span>
<span class="nc" id="L3108">                    (_meta.getDescribedType()).getSerialVersionUID();</span>
<span class="nc" id="L3109">            } catch (Throwable t) {</span>
                // last-chance catch for bug #283 (which can happen
                // in a variety of ClassLoading environments)
<span class="nc bnc" id="L3112" title="All 2 branches missed.">                if (_log.isTraceEnabled())</span>
<span class="nc" id="L3113">                    _log.warn(_loc.get(&quot;enhance-uid-access&quot;, _meta), t);</span>
                else
<span class="nc" id="L3115">                    _log.warn(_loc.get(&quot;enhance-uid-access&quot;, _meta));</span>
<span class="nc" id="L3116">            }</span>

            // if we couldn't access the serialVersionUID, we will have to
            // skip the override of that field and not be serialization
            // compatible with non-enhanced classes
<span class="nc bnc" id="L3121" title="All 2 branches missed.">            if (uid != null) {</span>
<span class="nc" id="L3122">                field = _pc.declareField(&quot;serialVersionUID&quot;, long.class);</span>
<span class="nc" id="L3123">                field.makePrivate();</span>
<span class="nc" id="L3124">                field.setStatic(true);</span>
<span class="nc" id="L3125">                field.setFinal(true);</span>

<span class="nc" id="L3127">                Code code = getOrCreateClassInitCode(false);</span>
<span class="nc" id="L3128">                code.beforeFirst();</span>
<span class="nc" id="L3129">                code.constant().setValue(uid.longValue());</span>
<span class="nc" id="L3130">                code.putstatic().setField(field);</span>

<span class="nc" id="L3132">                code.calculateMaxStack();</span>
            }
        }

        // add write object method
<span class="nc" id="L3137">        BCMethod write = _pc.getDeclaredMethod(&quot;writeObject&quot;,</span>
            new Class[]{ ObjectOutputStream.class });
<span class="nc bnc" id="L3139" title="All 2 branches missed.">        boolean full = write == null;</span>
<span class="nc bnc" id="L3140" title="All 2 branches missed.">        if (full) {</span>
            // private void writeObject (ObjectOutputStream out)
<span class="nc" id="L3142">            write = _pc.declareMethod(&quot;writeObject&quot;, void.class,</span>
                new Class[]{ ObjectOutputStream.class });
<span class="nc" id="L3144">            write.getExceptions(true).addException(IOException.class);</span>
<span class="nc" id="L3145">            write.makePrivate();</span>
        }
<span class="nc" id="L3147">        modifyWriteObjectMethod(write, full);</span>

        // and read object
<span class="nc" id="L3150">        BCMethod read = _pc.getDeclaredMethod(&quot;readObject&quot;,</span>
            new Class[]{ ObjectInputStream.class });
<span class="nc bnc" id="L3152" title="All 2 branches missed.">        full = read == null;</span>
<span class="nc bnc" id="L3153" title="All 2 branches missed.">        if (full) {</span>
            // private void readObject (ObjectInputStream in)
<span class="nc" id="L3155">            read = _pc.declareMethod(&quot;readObject&quot;, void.class,</span>
                new Class[]{ ObjectInputStream.class });
<span class="nc" id="L3157">            read.getExceptions(true).addException(IOException.class);</span>
<span class="nc" id="L3158">            read.getExceptions(true).addException</span>
<span class="nc" id="L3159">                (ClassNotFoundException.class);</span>
<span class="nc" id="L3160">            read.makePrivate();</span>
        }
<span class="nc" id="L3162">        modifyReadObjectMethod(read, full);</span>
<span class="nc" id="L3163">    }</span>

    private void addSubclassSerializationCode() {
        // for generated subclasses, serialization must write an instance of
        // the superclass instead of the subclass, so that the client VM can
        // deserialize successfully.

        // private Object writeReplace() throws ObjectStreamException
<span class="nc" id="L3171">        BCMethod method = _pc.declareMethod(&quot;writeReplace&quot;, Object.class, null);</span>
<span class="nc" id="L3172">        method.getExceptions(true).addException(ObjectStreamException.class);</span>
<span class="nc" id="L3173">        Code code = method.getCode(true);</span>

        // Object o = new &lt;managed-type&gt;()
<span class="nc" id="L3176">        code.anew().setType(_managedType); // for return</span>
<span class="nc" id="L3177">        code.dup(); // for post-&lt;init&gt; work</span>
<span class="nc" id="L3178">        code.dup(); // for &lt;init&gt;</span>
<span class="nc" id="L3179">        code.invokespecial().setMethod(_managedType.getType(), &quot;&lt;init&gt;&quot;,</span>
            void.class, null);

        // copy all the fields.
        // ##### limiting to JPA @Transient limitations
<span class="nc" id="L3184">        FieldMetaData[] fmds = _meta.getFields();</span>
<span class="nc bnc" id="L3185" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L3186" title="All 2 branches missed.">            if (fmds[i].isTransient())</span>
<span class="nc" id="L3187">                continue;</span>
            // o.&lt;field&gt; = this.&lt;field&gt; (or reflective analog)
<span class="nc" id="L3189">            code.dup(); // for putfield</span>
<span class="nc" id="L3190">            code.aload().setThis(); // for getfield</span>
<span class="nc" id="L3191">            getfield(code, _managedType, fmds[i].getName());</span>
<span class="nc" id="L3192">            putfield(code, _managedType, fmds[i].getName(),</span>
<span class="nc" id="L3193">                fmds[i].getDeclaredType());</span>
        }

<span class="nc" id="L3196">        code.areturn().setType(Object.class);</span>

<span class="nc" id="L3198">        code.calculateMaxLocals();</span>
<span class="nc" id="L3199">        code.calculateMaxStack();</span>
<span class="nc" id="L3200">    }</span>

    /**
     * Whether the class being enhanced should externalize to a detached
     * instance rather than serialize.
     */
    private boolean externalizeDetached() {
<span class="nc bnc" id="L3207" title="All 2 branches missed.">        return ClassMetaData.SYNTHETIC.equals(_meta.getDetachedState())</span>
<span class="nc bnc" id="L3208" title="All 2 branches missed.">            &amp;&amp; Serializable.class.isAssignableFrom(_meta.getDescribedType())</span>
<span class="nc" id="L3209">            &amp;&amp; !_repos.getConfiguration().getDetachStateInstance().</span>
<span class="nc bnc" id="L3210" title="All 2 branches missed.">            isDetachedStateTransient();</span>
    }

    /**
     * Adds a custom writeObject method that delegates to the
     * {@link ObjectOutputStream#defaultWriteObject} method,
     * but only after calling the internal &lt;code&gt;pcSerializing&lt;/code&gt; method.
     */
    private void modifyWriteObjectMethod(BCMethod method, boolean full) {
<span class="nc" id="L3219">        Code code = method.getCode(true);</span>
<span class="nc" id="L3220">        code.beforeFirst();</span>

        // bool clear = pcSerializing ();
<span class="nc" id="L3223">        loadManagedInstance(code, false);</span>
<span class="nc" id="L3224">        code.invokevirtual().setMethod(PRE + &quot;Serializing&quot;,</span>
            boolean.class, null);
<span class="nc" id="L3226">        int clear = code.getNextLocalsIndex();</span>
<span class="nc" id="L3227">        code.istore().setLocal(clear);</span>

<span class="nc bnc" id="L3229" title="All 2 branches missed.">        if (full) {</span>
            // out.defaultWriteObject ();
<span class="nc" id="L3231">            code.aload().setParam(0);</span>
<span class="nc" id="L3232">            code.invokevirtual().setMethod(ObjectOutputStream.class,</span>
                &quot;defaultWriteObject&quot;, void.class, null);
<span class="nc" id="L3234">            code.vreturn();</span>
        }

<span class="nc" id="L3237">        Instruction tmplate = (AccessController.doPrivileged(</span>
<span class="nc" id="L3238">            J2DoPrivHelper.newCodeAction())).vreturn();</span>
        JumpInstruction toret;
        Instruction ret;
<span class="nc" id="L3241">        code.beforeFirst();</span>
<span class="nc bnc" id="L3242" title="All 2 branches missed.">        while (code.searchForward(tmplate)) {</span>
<span class="nc" id="L3243">            ret = code.previous();</span>
            // if (clear) pcSetDetachedState (null);
<span class="nc" id="L3245">            code.iload().setLocal(clear);</span>
<span class="nc" id="L3246">            toret = code.ifeq();</span>
<span class="nc" id="L3247">            loadManagedInstance(code, false);</span>
<span class="nc" id="L3248">            code.constant().setNull();</span>
<span class="nc" id="L3249">            code.invokevirtual().setMethod(PRE + &quot;SetDetachedState&quot;,</span>
                void.class, new Class[]{ Object.class });
<span class="nc" id="L3251">            toret.setTarget(ret);</span>
<span class="nc" id="L3252">            code.next(); // jump over return</span>
        }
<span class="nc" id="L3254">        code.calculateMaxStack();</span>
<span class="nc" id="L3255">        code.calculateMaxLocals();</span>
<span class="nc" id="L3256">    }</span>

    /**
     * Adds a custom readObject method that delegates to the
     * {@link ObjectInputStream#readObject} method.
     */
    private void modifyReadObjectMethod(BCMethod method, boolean full) {
<span class="nc" id="L3263">        Code code = method.getCode(true);</span>
<span class="nc" id="L3264">        code.beforeFirst();</span>

        // if this instance uses synthetic detached state, note that it has
        // been deserialized
<span class="nc bnc" id="L3268" title="All 2 branches missed.">        if (ClassMetaData.SYNTHETIC.equals(_meta.getDetachedState())) {</span>
<span class="nc" id="L3269">            loadManagedInstance(code, false);</span>
<span class="nc" id="L3270">            code.getstatic().setField(PersistenceCapable.class,</span>
                &quot;DESERIALIZED&quot;, Object.class);
<span class="nc" id="L3272">            code.invokevirtual().setMethod(PRE + &quot;SetDetachedState&quot;,</span>
                void.class, new Class[]{ Object.class });
        }

<span class="nc bnc" id="L3276" title="All 2 branches missed.">        if (full) {</span>
            // in.defaultReadObject ();
<span class="nc" id="L3278">            code.aload().setParam(0);</span>
<span class="nc" id="L3279">            code.invokevirtual().setMethod(ObjectInputStream.class,</span>
                &quot;defaultReadObject&quot;, void.class, null);
<span class="nc" id="L3281">            code.vreturn();</span>
        }

<span class="nc" id="L3284">        code.calculateMaxStack();</span>
<span class="nc" id="L3285">        code.calculateMaxLocals();</span>
<span class="nc" id="L3286">    }</span>

    /**
     * Creates the pcIsDetached() method to determine if an instance
     * is detached.
     */
    private void addIsDetachedMethod()
        throws NoSuchMethodException {
        // public boolean pcIsDetached()
<span class="nc" id="L3295">        BCMethod method = _pc.declareMethod(PRE + &quot;IsDetached&quot;,</span>
            Boolean.class, null);
<span class="nc" id="L3297">        method.makePublic();</span>
<span class="nc" id="L3298">        Code code = method.getCode(true);</span>
<span class="nc" id="L3299">        boolean needsDefinitiveMethod = writeIsDetachedMethod(code);</span>
<span class="nc" id="L3300">        code.calculateMaxStack();</span>
<span class="nc" id="L3301">        code.calculateMaxLocals();</span>
<span class="nc bnc" id="L3302" title="All 2 branches missed.">        if (!needsDefinitiveMethod)</span>
<span class="nc" id="L3303">            return;</span>

        // private boolean pcIsDetachedStateDefinitive()
        //   return false;
        // auxilliary enhancers may change the return value of this method
        // if their specs consider detached state definitive
<span class="nc" id="L3309">        method = _pc.declareMethod(ISDETACHEDSTATEDEFINITIVE, boolean.class,</span>
            null);
<span class="nc" id="L3311">        method.makePrivate();</span>
<span class="nc" id="L3312">        code = method.getCode(true);</span>
<span class="nc" id="L3313">        code.constant().setValue(false);</span>
<span class="nc" id="L3314">        code.ireturn();</span>
<span class="nc" id="L3315">        code.calculateMaxStack();</span>
<span class="nc" id="L3316">        code.calculateMaxLocals();</span>
<span class="nc" id="L3317">    }</span>

    /**
     * Creates the body of the pcIsDetached() method to determine if an
     * instance is detached.
     *
     * @return true if we need a pcIsDetachedStateDefinitive method, false
     * otherwise
     */
    private boolean writeIsDetachedMethod(Code code)
        throws NoSuchMethodException {
        // not detachable: return Boolean.FALSE
<span class="nc bnc" id="L3329" title="All 2 branches missed.">        if (!_meta.isDetachable()) {</span>
<span class="nc" id="L3330">            code.getstatic().setField(Boolean.class, &quot;FALSE&quot;, Boolean.class);</span>
<span class="nc" id="L3331">            code.areturn();</span>
<span class="nc" id="L3332">            return false;</span>
        }

        // if (sm != null)
        //     return (sm.isDetached ()) ? Boolean.TRUE : Boolean.FALSE;
<span class="nc" id="L3337">        loadManagedInstance(code, false);</span>
<span class="nc" id="L3338">        code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L3339">        JumpInstruction ifins = code.ifnull();</span>
<span class="nc" id="L3340">        loadManagedInstance(code, false);</span>
<span class="nc" id="L3341">        code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L3342">        code.invokeinterface().setMethod(SMTYPE, &quot;isDetached&quot;,</span>
            boolean.class, null);
<span class="nc" id="L3344">        JumpInstruction iffalse = code.ifeq();</span>
<span class="nc" id="L3345">        code.getstatic().setField(Boolean.class, &quot;TRUE&quot;, Boolean.class);</span>
<span class="nc" id="L3346">        code.areturn();</span>
<span class="nc" id="L3347">        iffalse.setTarget(code.getstatic().setField(Boolean.class, &quot;FALSE&quot;,</span>
            Boolean.class));
<span class="nc" id="L3349">        code.areturn();</span>

        // if we use detached state:
        // if (pcGetDetachedState () != null
        //     &amp;&amp; pcGetDetachedState != DESERIALIZED)
        //     return Boolean.TRUE;
<span class="nc" id="L3355">        Boolean state = _meta.usesDetachedState();</span>
<span class="nc" id="L3356">        JumpInstruction notdeser = null;</span>
        Instruction target;
<span class="nc bnc" id="L3358" title="All 2 branches missed.">        if (state != Boolean.FALSE) {</span>
<span class="nc" id="L3359">            ifins.setTarget(loadManagedInstance(code, false));</span>
<span class="nc" id="L3360">            code.invokevirtual().setMethod(PRE + &quot;GetDetachedState&quot;,</span>
                Object.class, null);
<span class="nc" id="L3362">            ifins = code.ifnull();</span>
<span class="nc" id="L3363">            loadManagedInstance(code, false);</span>
<span class="nc" id="L3364">            code.invokevirtual().setMethod(PRE + &quot;GetDetachedState&quot;,</span>
                Object.class, null);
<span class="nc" id="L3366">            code.getstatic().setField(PersistenceCapable.class,</span>
                &quot;DESERIALIZED&quot;, Object.class);
<span class="nc" id="L3368">            notdeser = code.ifacmpeq();</span>
<span class="nc" id="L3369">            code.getstatic().setField(Boolean.class, &quot;TRUE&quot;, Boolean.class);</span>
<span class="nc" id="L3370">            code.areturn();</span>

<span class="nc bnc" id="L3372" title="All 2 branches missed.">            if (state == Boolean.TRUE) {</span>
                // if we have to use detached state:
                // return Boolean.FALSE;
<span class="nc" id="L3375">                target = code.getstatic().setField(Boolean.class, &quot;FALSE&quot;,</span>
                    Boolean.class);
<span class="nc" id="L3377">                ifins.setTarget(target);</span>
<span class="nc" id="L3378">                notdeser.setTarget(target);</span>
<span class="nc" id="L3379">                code.areturn();</span>
<span class="nc" id="L3380">                return false;</span>
            }
        }

        // create artificial target to simplify
<span class="nc" id="L3385">        target = code.nop();</span>
<span class="nc" id="L3386">        ifins.setTarget(target);</span>
<span class="nc bnc" id="L3387" title="All 2 branches missed.">        if (notdeser != null)</span>
<span class="nc" id="L3388">            notdeser.setTarget(target);</span>

        // allow users with version or auto-assigned pk fields to manually
        // construct a &quot;detached&quot; instance, so check these before taking into
        // account non-existent detached state

        // consider detached if version is non-default
<span class="nc" id="L3395">        FieldMetaData version = _meta.getVersionField();</span>
<span class="nc bnc" id="L3396" title="All 4 branches missed.">        if (state != Boolean.TRUE &amp;&amp; version != null) {</span>
            // if (&lt;version&gt; != &lt;default&gt;)
            //		return true;
<span class="nc" id="L3399">            loadManagedInstance(code, false);</span>
<span class="nc" id="L3400">            addGetManagedValueCode(code, version);</span>
<span class="nc" id="L3401">            ifins = ifDefaultValue(code, version);</span>
<span class="nc" id="L3402">            code.getstatic().setField(Boolean.class, &quot;TRUE&quot;, Boolean.class);</span>
<span class="nc" id="L3403">            code.areturn();</span>
<span class="nc bnc" id="L3404" title="All 2 branches missed.">            if (!_addVersionInitFlag){</span>
                // else return false;
<span class="nc" id="L3406">                ifins.setTarget(code.getstatic().setField(Boolean.class, &quot;FALSE&quot;, Boolean.class));</span>
            }else{
                // noop
<span class="nc" id="L3409">                ifins.setTarget(code.nop());</span>
                // if (pcVersionInit != false)
                // return true
                // else return null; //  (returning null because we don't know the correct answer)
<span class="nc" id="L3413">                loadManagedInstance(code, false);</span>
<span class="nc" id="L3414">                getfield(code, null, VERSION_INIT_STR);</span>
<span class="nc" id="L3415">                ifins = code.ifeq();</span>
<span class="nc" id="L3416">                code.getstatic().setField(Boolean.class, &quot;TRUE&quot;, Boolean.class);</span>
<span class="nc" id="L3417">                code.areturn();</span>
<span class="nc" id="L3418">                ifins.setTarget(code.nop());</span>
<span class="nc" id="L3419">                code.constant().setNull();</span>
            }
<span class="nc" id="L3421">            code.areturn();</span>
<span class="nc" id="L3422">            return false;</span>
        }

        // consider detached if auto-genned primary keys are non-default
<span class="nc" id="L3426">        ifins = null;</span>
<span class="nc" id="L3427">        JumpInstruction ifins2 = null;</span>
<span class="nc" id="L3428">        boolean hasAutoAssignedPK = false;</span>
<span class="nc bnc" id="L3429" title="All 2 branches missed.">        if (state != Boolean.TRUE</span>
<span class="nc bnc" id="L3430" title="All 2 branches missed.">            &amp;&amp; _meta.getIdentityType() == ClassMetaData.ID_APPLICATION) {</span>
            // for each pk field:
            // if (&lt;pk&gt; != &lt;default&gt; [&amp;&amp; !&quot;&quot;.equals (&lt;pk&gt;)])
            //		return Boolean.TRUE;
<span class="nc" id="L3434">            FieldMetaData[] pks = _meta.getPrimaryKeyFields();</span>
<span class="nc bnc" id="L3435" title="All 2 branches missed.">            for (int i = 0; i &lt; pks.length; i++) {</span>
<span class="nc bnc" id="L3436" title="All 2 branches missed.">                if (pks[i].getValueStrategy() == ValueStrategies.NONE)</span>
<span class="nc" id="L3437">                    continue;</span>

<span class="nc" id="L3439">                target = loadManagedInstance(code, false);</span>
<span class="nc bnc" id="L3440" title="All 2 branches missed.">                if (ifins != null)</span>
<span class="nc" id="L3441">                    ifins.setTarget(target);</span>
<span class="nc bnc" id="L3442" title="All 2 branches missed.">                if (ifins2 != null)</span>
<span class="nc" id="L3443">                    ifins2.setTarget(target);</span>
<span class="nc" id="L3444">                ifins2 = null;</span>

<span class="nc" id="L3446">                addGetManagedValueCode(code, pks[i]);</span>
<span class="nc" id="L3447">                ifins = ifDefaultValue(code, pks[i]);</span>
<span class="nc bnc" id="L3448" title="All 2 branches missed.">                if (pks[i].getDeclaredTypeCode() == JavaTypes.STRING) {</span>
<span class="nc" id="L3449">                    code.constant().setValue(&quot;&quot;);</span>
<span class="nc" id="L3450">                    loadManagedInstance(code, false);</span>
<span class="nc" id="L3451">                    addGetManagedValueCode(code, pks[i]);</span>
<span class="nc" id="L3452">                    code.invokevirtual().setMethod(String.class, &quot;equals&quot;,</span>
                        boolean.class, new Class[]{ Object.class });
<span class="nc" id="L3454">                    ifins2 = code.ifne();</span>
                }
<span class="nc" id="L3456">                code.getstatic().setField(Boolean.class, &quot;TRUE&quot;,</span>
                    Boolean.class);
<span class="nc" id="L3458">                code.areturn();</span>
            }
        }

        // create artificial target to simplify
<span class="nc" id="L3463">        target = code.nop();</span>
<span class="nc bnc" id="L3464" title="All 2 branches missed.">        if (ifins != null)</span>
<span class="nc" id="L3465">            ifins.setTarget(target);</span>
<span class="nc bnc" id="L3466" title="All 2 branches missed.">        if (ifins2 != null)</span>
<span class="nc" id="L3467">            ifins2.setTarget(target);</span>

        // if has auto-assigned pk and we get to this point, must have default
        // value, so must be new instance
<span class="nc bnc" id="L3471" title="All 2 branches missed.">        if (hasAutoAssignedPK) {</span>
<span class="nc" id="L3472">            code.getstatic().setField(Boolean.class, &quot;FALSE&quot;, Boolean.class);</span>
<span class="nc" id="L3473">            code.areturn();</span>
<span class="nc" id="L3474">            return false;</span>
        }

        // if detached state is not definitive, just give up now and return
        // null so that the runtime will perform a DB lookup to determine
        // whether we're detached or new
<span class="nc" id="L3480">        code.aload().setThis();</span>
<span class="nc" id="L3481">        code.invokespecial().setMethod(ISDETACHEDSTATEDEFINITIVE, boolean.class,</span>
            null);
<span class="nc" id="L3483">        ifins = code.ifne();</span>
<span class="nc" id="L3484">        code.constant().setNull();</span>
<span class="nc" id="L3485">        code.areturn();</span>
<span class="nc" id="L3486">        ifins.setTarget(code.nop());</span>

        // no detached state: if instance uses detached state and it's not
        // synthetic or the instance is not serializable or the state isn't
        // transient, must not be detached
<span class="nc bnc" id="L3491" title="All 2 branches missed.">        if (state == null</span>
<span class="nc bnc" id="L3492" title="All 2 branches missed.">            &amp;&amp; (!ClassMetaData.SYNTHETIC.equals(_meta.getDetachedState())</span>
<span class="nc bnc" id="L3493" title="All 2 branches missed.">            || !Serializable.class.isAssignableFrom(_meta.getDescribedType())</span>
<span class="nc" id="L3494">            || !_repos.getConfiguration().getDetachStateInstance().</span>
<span class="nc bnc" id="L3495" title="All 2 branches missed.">            isDetachedStateTransient())) {</span>
            // return Boolean.FALSE
<span class="nc" id="L3497">            code.getstatic().setField(Boolean.class, &quot;FALSE&quot;, Boolean.class);</span>
<span class="nc" id="L3498">            code.areturn();</span>
<span class="nc" id="L3499">            return true;</span>
        }

        // no detached state: if instance uses detached state (and must be
        // synthetic and transient in serializable instance at this point),
        // not detached if state not set to DESERIALIZED
<span class="nc bnc" id="L3505" title="All 2 branches missed.">        if (state == null) {</span>
            // if (pcGetDetachedState () == null) // instead of DESERIALIZED
            //     return Boolean.FALSE;
<span class="nc" id="L3508">            loadManagedInstance(code, false);</span>
<span class="nc" id="L3509">            code.invokevirtual().setMethod(PRE + &quot;GetDetachedState&quot;,</span>
                Object.class, null);
<span class="nc" id="L3511">            ifins = code.ifnonnull();</span>
<span class="nc" id="L3512">            code.getstatic().setField(Boolean.class, &quot;FALSE&quot;, Boolean.class);</span>
<span class="nc" id="L3513">            code.areturn();</span>
<span class="nc" id="L3514">            ifins.setTarget(code.nop());</span>
        }

        // give up; we just don't know
<span class="nc" id="L3518">        code.constant().setNull();</span>
<span class="nc" id="L3519">        code.areturn();</span>
<span class="nc" id="L3520">        return true;</span>
    }

    /**
     * Compare the given field to its Java default, returning the
     * comparison instruction. The field value will already be on the stack.
     */
    private static JumpInstruction ifDefaultValue(Code code,
        FieldMetaData fmd) {
<span class="nc bnc" id="L3529" title="All 5 branches missed.">        switch (fmd.getDeclaredTypeCode()) {</span>
            case JavaTypes.BOOLEAN:
            case JavaTypes.BYTE:
            case JavaTypes.CHAR:
            case JavaTypes.INT:
            case JavaTypes.SHORT:
<span class="nc" id="L3535">                return code.ifeq();</span>
            case JavaTypes.DOUBLE:
<span class="nc" id="L3537">                code.constant().setValue(0D);</span>
<span class="nc" id="L3538">                code.dcmpl();</span>
<span class="nc" id="L3539">                return code.ifeq();</span>
            case JavaTypes.FLOAT:
<span class="nc" id="L3541">                code.constant().setValue(0F);</span>
<span class="nc" id="L3542">                code.fcmpl();</span>
<span class="nc" id="L3543">                return code.ifeq();</span>
            case JavaTypes.LONG:
<span class="nc" id="L3545">                code.constant().setValue(0L);</span>
<span class="nc" id="L3546">                code.lcmp();</span>
<span class="nc" id="L3547">                return code.ifeq();</span>
            default:
<span class="nc" id="L3549">                return code.ifnull();</span>
        }
    }

    /**
     * Helper method to get the code for the class initializer method,
     * creating the method if it does not already exist.
     */
    private Code getOrCreateClassInitCode(boolean replaceLast) {
<span class="nc" id="L3558">        BCMethod clinit = _pc.getDeclaredMethod(&quot;&lt;clinit&gt;&quot;);</span>
        Code code;
<span class="nc bnc" id="L3560" title="All 2 branches missed.">        if (clinit != null) {</span>
<span class="nc" id="L3561">            code = clinit.getCode(true);</span>
<span class="nc bnc" id="L3562" title="All 2 branches missed.">            if (replaceLast) {</span>
<span class="nc" id="L3563">                Code template = AccessController.doPrivileged(</span>
<span class="nc" id="L3564">                    J2DoPrivHelper.newCodeAction());</span>
<span class="nc" id="L3565">                code.searchForward(template.vreturn());</span>
<span class="nc" id="L3566">                code.previous();</span>
<span class="nc" id="L3567">                code.set(template.nop());</span>
<span class="nc" id="L3568">                code.next();</span>
            }
<span class="nc" id="L3570">            return code;</span>
        }

        // add static initializer method if non exists
<span class="nc" id="L3574">        clinit = _pc.declareMethod(&quot;&lt;clinit&gt;&quot;, void.class, null);</span>
<span class="nc" id="L3575">        clinit.makePackage();</span>
<span class="nc" id="L3576">        clinit.setStatic(true);</span>
<span class="nc" id="L3577">        clinit.setFinal(true);</span>

<span class="nc" id="L3579">        code = clinit.getCode(true);</span>
<span class="nc bnc" id="L3580" title="All 2 branches missed.">        if (!replaceLast) {</span>
<span class="nc" id="L3581">            code.vreturn();</span>
<span class="nc" id="L3582">            code.previous();</span>
        }
<span class="nc" id="L3584">        return code;</span>
    }

    /**
     * Adds bytecode modifying the cloning behavior of the class being
     * enhanced to correctly replace the &lt;code&gt;pcStateManager&lt;/code&gt;
     * instance fields of any clone created with their default values.
     * Also, if this class is the base PC type and does not declared
     * a clone method, one will be added. Also, if _pc is a synthetic
     * subclass, create the clone() method that clears the state manager
     * that may have been initialized in a super's clone() method.
     */
    private void addCloningCode() {
<span class="nc bnc" id="L3597" title="All 4 branches missed.">        if (_meta.getPCSuperclass() != null &amp;&amp; !getCreateSubclass())</span>
<span class="nc" id="L3598">            return;</span>

        // add the clone method if necessary
<span class="nc" id="L3601">        BCMethod clone = _pc.getDeclaredMethod(&quot;clone&quot;,</span>
            (String[]) null);
<span class="nc" id="L3603">        String superName = _managedType.getSuperclassName();</span>
<span class="nc" id="L3604">        Code code = null;</span>
<span class="nc bnc" id="L3605" title="All 2 branches missed.">        if (clone == null) {</span>
            // add clone support for base classes
            // which also implement cloneable
<span class="nc" id="L3608">            boolean isCloneable = Cloneable.class.isAssignableFrom(</span>
<span class="nc" id="L3609">                _managedType.getType());</span>
<span class="nc" id="L3610">            boolean extendsObject =</span>
<span class="nc" id="L3611">                superName.equals(Object.class.getName());</span>
<span class="nc bnc" id="L3612" title="All 6 branches missed.">            if (!isCloneable || (!extendsObject &amp;&amp; !getCreateSubclass()))</span>
<span class="nc" id="L3613">                return;</span>

<span class="nc bnc" id="L3615" title="All 2 branches missed.">            if (!getCreateSubclass())</span>
<span class="nc bnc" id="L3616" title="All 2 branches missed.">                if (_log.isTraceEnabled())</span>
<span class="nc" id="L3617">                    _log.trace(</span>
<span class="nc" id="L3618">                        _loc.get(&quot;enhance-cloneable&quot;, _managedType.getName()));</span>

            // add clone method
            // protected Object clone () throws CloneNotSupportedException
<span class="nc" id="L3622">            clone = _pc.declareMethod(&quot;clone&quot;, Object.class, null);</span>
<span class="nc bnc" id="L3623" title="All 2 branches missed.">            if (!setVisibilityToSuperMethod(clone))</span>
<span class="nc" id="L3624">                clone.makeProtected();</span>
<span class="nc" id="L3625">            clone.getExceptions(true).addException</span>
<span class="nc" id="L3626">                (CloneNotSupportedException.class);</span>
<span class="nc" id="L3627">            code = clone.getCode(true);</span>

            // return super.clone ();
<span class="nc" id="L3630">            loadManagedInstance(code, false);</span>
<span class="nc" id="L3631">            code.invokespecial().setMethod(superName, &quot;clone&quot;,</span>
<span class="nc" id="L3632">                Object.class.getName(), null);</span>
<span class="nc" id="L3633">            code.areturn();</span>
<span class="nc" id="L3634">        } else {</span>
            // get the clone method code
<span class="nc" id="L3636">            code = clone.getCode(false);</span>
<span class="nc bnc" id="L3637" title="All 2 branches missed.">            if (code == null)</span>
<span class="nc" id="L3638">                return;</span>
        }

        // create template super.clone () instruction to match against
<span class="nc" id="L3642">        Instruction template = (AccessController.doPrivileged(</span>
<span class="nc" id="L3643">            J2DoPrivHelper.newCodeAction())).invokespecial()</span>
<span class="nc" id="L3644">            .setMethod(superName, &quot;clone&quot;, Object.class.getName(), null);</span>

        // find calls to the template instruction; on match
        // clone will be on stack
<span class="nc" id="L3648">        code.beforeFirst();</span>
<span class="nc bnc" id="L3649" title="All 2 branches missed.">        if (code.searchForward(template)) {</span>
            // ((&lt;type&gt;) clone).pcStateManager = null;
<span class="nc" id="L3651">            code.dup();</span>
<span class="nc" id="L3652">            code.checkcast().setType(_pc);</span>
<span class="nc" id="L3653">            code.constant().setNull();</span>
<span class="nc" id="L3654">            code.putfield().setField(SM, SMTYPE);</span>

            // if modified, increase stack
<span class="nc" id="L3657">            code.calculateMaxStack();</span>
<span class="nc" id="L3658">            code.calculateMaxLocals();</span>
        }
<span class="nc" id="L3660">    }</span>

    /**
     * Gets the auxiliary enhancers registered as {@link Services services}.
     */
    public AuxiliaryEnhancer[] getAuxiliaryEnhancers() {
<span class="nc" id="L3666">		return _auxEnhancers;</span>
    }

    /**
     * Allow any registered auxiliary code generators to run.
     */
    private void runAuxiliaryEnhancers() {
<span class="nc bnc" id="L3673" title="All 2 branches missed.">    	for (int i = 0; i &lt; _auxEnhancers.length; i++)</span>
<span class="nc" id="L3674">    		_auxEnhancers[i].run(_pc, _meta);</span>
<span class="nc" id="L3675">    }</span>

    /**
     * Affirms if the given method be skipped.
     *
     * @param method method to be skipped or not
     * @return true if any of the auxiliary enhancers skips the given method,
     * or if the method is a constructor
     */
    private boolean skipEnhance(BCMethod method) {
<span class="nc bnc" id="L3685" title="All 2 branches missed.">        if (&quot;&lt;init&gt;&quot;.equals(method.getName()))</span>
<span class="nc" id="L3686">            return true;</span>

<span class="nc bnc" id="L3688" title="All 2 branches missed.">        for (int i = 0; i &lt; _auxEnhancers.length; i++)</span>
<span class="nc bnc" id="L3689" title="All 2 branches missed.">    		if (_auxEnhancers[i].skipEnhance(method))</span>
<span class="nc" id="L3690">    			return true;</span>

<span class="nc" id="L3692">        return false;</span>
    }

    /**
     * Adds synthetic field access methods that will replace all direct
     * field accesses.
     */
    private void addAccessors()
        throws NoSuchMethodException {
<span class="nc bnc" id="L3701" title="All 2 branches missed.">        FieldMetaData[] fmds = getCreateSubclass() ? _meta.getFields()</span>
<span class="nc" id="L3702">            : _meta.getDeclaredFields();</span>
<span class="nc bnc" id="L3703" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L3704" title="All 2 branches missed.">            if (getCreateSubclass()) {</span>
<span class="nc bnc" id="L3705" title="All 4 branches missed.">                if (!getRedefine() &amp;&amp; isPropertyAccess(fmds[i])) {</span>
<span class="nc" id="L3706">                    addSubclassSetMethod(fmds[i]);</span>
<span class="nc" id="L3707">                    addSubclassGetMethod(fmds[i]);</span>
                }
            } else {
<span class="nc" id="L3710">                addGetMethod(i, fmds[i]);</span>
<span class="nc" id="L3711">                addSetMethod(i, fmds[i]);</span>
            }
        }
<span class="nc" id="L3714">    }</span>

    /**
     * Adds a non-static setter that delegates to the super methods, and
     * performs any necessary field tracking.
     */
    private void addSubclassSetMethod(FieldMetaData fmd)
        throws NoSuchMethodException {
<span class="nc" id="L3722">        Class propType = fmd.getDeclaredType();</span>
<span class="nc" id="L3723">        String setterName = getSetterName(fmd);</span>
<span class="nc" id="L3724">        BCMethod setter = _pc.declareMethod(setterName, void.class,</span>
            new Class[] { propType });
<span class="nc" id="L3726">        setVisibilityToSuperMethod(setter);</span>
<span class="nc" id="L3727">        Code code = setter.getCode(true);</span>

        // not necessary if we're already tracking access via redefinition
<span class="nc bnc" id="L3730" title="All 2 branches missed.">        if (!getRedefine()) {</span>
            // get the orig value onto stack
<span class="nc" id="L3732">            code.aload().setThis();</span>
<span class="nc" id="L3733">            addGetManagedValueCode(code, fmd);</span>
<span class="nc" id="L3734">            int val = code.getNextLocalsIndex();</span>
<span class="nc" id="L3735">            code.xstore().setLocal(val).setType(fmd.getDeclaredType());</span>
<span class="nc" id="L3736">            addNotifyMutation(code, fmd, val, 0);</span>
        }

        // ##### test case: B extends A. Methods defined in A. What
        // ##### happens?
        // super.setXXX(...)
<span class="nc" id="L3742">        code.aload().setThis();</span>
<span class="nc" id="L3743">        code.xload().setParam(0).setType(propType);</span>
<span class="nc" id="L3744">        code.invokespecial().setMethod(_managedType.getType(),</span>
            setterName, void.class, new Class[] { propType });

<span class="nc" id="L3747">        code.vreturn();</span>
<span class="nc" id="L3748">        code.calculateMaxLocals();</span>
<span class="nc" id="L3749">        code.calculateMaxStack();</span>
<span class="nc" id="L3750">    }</span>

    private boolean setVisibilityToSuperMethod(BCMethod method) {
<span class="nc" id="L3753">        BCMethod[] methods = _managedType.getMethods(method.getName(),</span>
<span class="nc" id="L3754">            method.getParamTypes());</span>
<span class="nc bnc" id="L3755" title="All 2 branches missed.">        if (methods.length == 0)</span>
<span class="nc" id="L3756">            throw new UserException(_loc.get(&quot;no-accessor&quot;,</span>
<span class="nc" id="L3757">                _managedType.getName(), method.getName()));</span>
<span class="nc" id="L3758">        BCMethod superMeth = methods[0];</span>
<span class="nc bnc" id="L3759" title="All 2 branches missed.">        if (superMeth.isPrivate()) {</span>
<span class="nc" id="L3760">            method.makePrivate();</span>
<span class="nc" id="L3761">            return true;</span>
<span class="nc bnc" id="L3762" title="All 2 branches missed.">        } else if (superMeth.isPackage()) {</span>
<span class="nc" id="L3763">            method.makePackage();</span>
<span class="nc" id="L3764">            return true;</span>
<span class="nc bnc" id="L3765" title="All 2 branches missed.">        } else if (superMeth.isProtected()) {</span>
<span class="nc" id="L3766">            method.makeProtected();</span>
<span class="nc" id="L3767">            return true;</span>
<span class="nc bnc" id="L3768" title="All 2 branches missed.">        } else if (superMeth.isPublic()) {</span>
<span class="nc" id="L3769">            method.makePublic();</span>
<span class="nc" id="L3770">            return true;</span>
        }
<span class="nc" id="L3772">        return false;</span>
    }

    /**
     * Adds a non-static getter that delegates to the super methods, and
     * performs any necessary field tracking.
     */
    private void addSubclassGetMethod(FieldMetaData fmd) {
<span class="nc" id="L3780">        String methName = &quot;get&quot; + StringUtil.capitalize(fmd.getName());</span>
<span class="nc bnc" id="L3781" title="All 2 branches missed.">        if (_managedType.getMethods(methName, new Class[0]).length == 0)</span>
<span class="nc" id="L3782">            methName = &quot;is&quot; + StringUtil.capitalize(fmd.getName());</span>
<span class="nc" id="L3783">        BCMethod getter = _pc.declareMethod(methName, fmd.getDeclaredType(),</span>
            null);
<span class="nc" id="L3785">        setVisibilityToSuperMethod(getter);</span>
<span class="nc" id="L3786">        getter.makePublic();</span>
<span class="nc" id="L3787">        Code code = getter.getCode(true);</span>

        // if we're not already tracking field access via reflection, then we
        // must make the getter hook in lazy loading before accessing the super
        // method.
<span class="nc bnc" id="L3792" title="All 2 branches missed.">        if (!getRedefine())</span>
<span class="nc" id="L3793">            addNotifyAccess(code, fmd);</span>

<span class="nc" id="L3795">        code.aload().setThis();</span>
<span class="nc" id="L3796">        code.invokespecial().setMethod(_managedType.getType(), methName,</span>
<span class="nc" id="L3797">            fmd.getDeclaredType(), null);</span>
<span class="nc" id="L3798">        code.xreturn().setType(fmd.getDeclaredType());</span>
<span class="nc" id="L3799">        code.calculateMaxLocals();</span>
<span class="nc" id="L3800">        code.calculateMaxStack();</span>
<span class="nc" id="L3801">    }</span>

    /**
     * Adds a static getter method for the given field.
     * The generated method interacts with the instance state and the
     * StateManager to get the value of the field.
     *
     * @param index the relative number of the field
     * @param fmd metadata about the field to get
     */
    private void addGetMethod(int index, FieldMetaData fmd)
        throws NoSuchMethodException {
<span class="nc" id="L3813">        BCMethod method = createGetMethod(fmd);</span>
<span class="nc" id="L3814">        Code code = method.getCode(true);</span>

        // if reads are not checked, just return the value
<span class="nc" id="L3817">        byte fieldFlag = getFieldFlag(fmd);</span>
<span class="nc bnc" id="L3818" title="All 4 branches missed.">        if ((fieldFlag &amp; PersistenceCapable.CHECK_READ) == 0</span>
            &amp;&amp; (fieldFlag &amp; PersistenceCapable.MEDIATE_READ) == 0) {
<span class="nc" id="L3820">            loadManagedInstance(code, true, fmd);</span>
<span class="nc" id="L3821">            addGetManagedValueCode(code, fmd);</span>
<span class="nc" id="L3822">            code.xreturn().setType(fmd.getDeclaredType());</span>

<span class="nc" id="L3824">            code.calculateMaxStack();</span>
<span class="nc" id="L3825">            code.calculateMaxLocals();</span>
<span class="nc" id="L3826">            return;</span>
        }

        // if (inst.pcStateManager == null) return inst.&lt;field&gt;;
<span class="nc" id="L3830">        loadManagedInstance(code, true, fmd);</span>
<span class="nc" id="L3831">        code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L3832">        JumpInstruction ifins = code.ifnonnull();</span>
<span class="nc" id="L3833">        loadManagedInstance(code, true, fmd);</span>
<span class="nc" id="L3834">        addGetManagedValueCode(code, fmd);</span>
<span class="nc" id="L3835">        code.xreturn().setType(fmd.getDeclaredType());</span>

        // int field = pcInheritedFieldCount + &lt;fieldindex&gt;;
<span class="nc" id="L3838">        int fieldLocal = code.getNextLocalsIndex();</span>
<span class="nc" id="L3839">        ifins.setTarget(code.getstatic().setField(INHERIT, int.class));</span>
<span class="nc" id="L3840">        code.constant().setValue(index);</span>
<span class="nc" id="L3841">        code.iadd();</span>
<span class="nc" id="L3842">        code.istore().setLocal(fieldLocal);</span>

        // inst.pcStateManager.accessingField (field);
        // return inst.&lt;field&gt;;
<span class="nc" id="L3846">        loadManagedInstance(code, true, fmd);</span>
<span class="nc" id="L3847">        code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L3848">        code.iload().setLocal(fieldLocal);</span>
<span class="nc" id="L3849">        code.invokeinterface().setMethod(SMTYPE, &quot;accessingField&quot;, void.class,</span>
            new Class[]{ int.class });
<span class="nc" id="L3851">        loadManagedInstance(code, true, fmd);</span>
<span class="nc" id="L3852">        addGetManagedValueCode(code, fmd);</span>
<span class="nc" id="L3853">        code.xreturn().setType(fmd.getDeclaredType());</span>

<span class="nc" id="L3855">        code.calculateMaxStack();</span>
<span class="nc" id="L3856">        code.calculateMaxLocals();</span>
<span class="nc" id="L3857">    }</span>

    /**
     * Adds a static setter method for the given field.
     * The generated method interacts with the instance state and the
     * StateManager to set the value of the field.
     *
     * @param index the relative number of the field
     * @param fmd metadata about the field to set
     */
    private void addSetMethod(int index, FieldMetaData fmd)
        throws NoSuchMethodException {
<span class="nc" id="L3869">        BCMethod method = createSetMethod(fmd);</span>
<span class="nc" id="L3870">        Code code = method.getCode(true);</span>

        // PCEnhancer uses static methods; PCSubclasser does not.
<span class="nc" id="L3873">        int firstParamOffset = getAccessorParameterOffset(fmd);</span>

        // if (inst.pcStateManager == null) inst.&lt;field&gt; = value;
<span class="nc" id="L3876">        loadManagedInstance(code, true, fmd);</span>
<span class="nc" id="L3877">        code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L3878">        JumpInstruction ifins = code.ifnonnull();</span>
<span class="nc" id="L3879">        loadManagedInstance(code, true, fmd);</span>
<span class="nc" id="L3880">        code.xload().setParam(firstParamOffset);</span>
<span class="nc" id="L3881">        addSetManagedValueCode(code, fmd);</span>
<span class="nc bnc" id="L3882" title="All 4 branches missed.">        if(fmd.isVersion()==true &amp;&amp; _addVersionInitFlag){</span>
            // if we are setting the version, flip the versionInit flag to true
<span class="nc" id="L3884">            loadManagedInstance(code, true);</span>
<span class="nc" id="L3885">            code.constant().setValue(1);</span>
            // pcVersionInit = true;
<span class="nc" id="L3887">            putfield(code, null, VERSION_INIT_STR, boolean.class);</span>
        }
<span class="nc" id="L3889">        code.vreturn();</span>

        // inst.pcStateManager.setting&lt;fieldType&gt;Field (inst,
        //     pcInheritedFieldCount + &lt;index&gt;, inst.&lt;field&gt;, value, 0);
<span class="nc" id="L3893">        ifins.setTarget(loadManagedInstance(code, true, fmd));</span>
<span class="nc" id="L3894">        code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L3895">        loadManagedInstance(code, true, fmd);</span>
<span class="nc" id="L3896">        code.getstatic().setField(INHERIT, int.class);</span>
<span class="nc" id="L3897">        code.constant().setValue(index);</span>
<span class="nc" id="L3898">        code.iadd();</span>
<span class="nc" id="L3899">        loadManagedInstance(code, true, fmd);</span>
<span class="nc" id="L3900">        addGetManagedValueCode(code, fmd);</span>
<span class="nc" id="L3901">        code.xload().setParam(firstParamOffset);</span>
<span class="nc" id="L3902">        code.constant().setValue(0);</span>
<span class="nc" id="L3903">        code.invokeinterface().setMethod(getStateManagerMethod</span>
<span class="nc" id="L3904">            (fmd.getDeclaredType(), &quot;setting&quot;, false, true));</span>
<span class="nc" id="L3905">        code.vreturn();</span>

<span class="nc" id="L3907">        code.calculateMaxStack();</span>
<span class="nc" id="L3908">        code.calculateMaxLocals();</span>
<span class="nc" id="L3909">    }</span>

    /**
     * Determines which attach / detach methods to use.
     */
    private void addAttachDetachCode()
        throws NoSuchMethodException {
        // see if any superclasses are detachable
<span class="nc" id="L3917">        boolean parentDetachable = false;</span>
<span class="nc" id="L3918">        for (ClassMetaData parent = _meta.getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L3919" title="All 2 branches missed.">            parent != null; parent = parent.getPCSuperclassMetaData()) {</span>
<span class="nc bnc" id="L3920" title="All 2 branches missed.">            if (parent.isDetachable()) {</span>
<span class="nc" id="L3921">                parentDetachable = true;</span>
<span class="nc" id="L3922">                break;</span>
            }
        }

        // if parent not detachable, we need to add the detach state fields and
        // accessor methods
<span class="nc bnc" id="L3928" title="All 4 branches missed.">        if (_meta.getPCSuperclass() == null || getCreateSubclass()</span>
<span class="nc bnc" id="L3929" title="All 2 branches missed.">            || parentDetachable != _meta.isDetachable()) {</span>
<span class="nc" id="L3930">            addIsDetachedMethod();</span>
<span class="nc bnc" id="L3931" title="All 2 branches missed.">            addDetachedStateMethods(_meta.usesDetachedState()</span>
                != Boolean.FALSE);
        }

        // if we detach on serialize, we also need to implement the
        // externalizable interface to write just the state for the fields
        // being detached
<span class="nc bnc" id="L3938" title="All 2 branches missed.">        if (externalizeDetached()) {</span>
            try {
<span class="nc" id="L3940">                addDetachExternalize(parentDetachable,</span>
<span class="nc bnc" id="L3941" title="All 2 branches missed.">                    _meta.usesDetachedState() != Boolean.FALSE);</span>
<span class="nc" id="L3942">            } catch (NoSuchMethodException nsme) {</span>
<span class="nc" id="L3943">                throw new GeneralException(nsme);</span>
<span class="nc" id="L3944">            }</span>
        }
<span class="nc" id="L3946">    }</span>

    /**
     * Add the fields to hold detached state and their accessor methods.
     *
     * @param impl whether to fully implement detach state functionality
     */
    private void addDetachedStateMethods(boolean impl) {
<span class="nc" id="L3954">        Field detachField = _meta.getDetachedStateField();</span>
<span class="nc" id="L3955">        String name = null;</span>
<span class="nc" id="L3956">        String declarer = null;</span>
<span class="nc bnc" id="L3957" title="All 4 branches missed.">        if (impl &amp;&amp; detachField == null) {</span>
<span class="nc" id="L3958">            name = PRE + &quot;DetachedState&quot;;</span>
<span class="nc" id="L3959">            declarer = _pc.getName();</span>
<span class="nc" id="L3960">            BCField field = _pc.declareField(name, Object.class);</span>
<span class="nc" id="L3961">            field.makePrivate();</span>
<span class="nc" id="L3962">            field.setTransient(true);</span>
<span class="nc bnc" id="L3963" title="All 2 branches missed.">        } else if (impl) {</span>
<span class="nc" id="L3964">            name = detachField.getName();</span>
<span class="nc" id="L3965">            declarer = detachField.getDeclaringClass().getName();</span>
        }

        // public Object pcGetDetachedState ()
<span class="nc" id="L3969">        BCMethod method = _pc.declareMethod(PRE + &quot;GetDetachedState&quot;,</span>
            Object.class, null);
<span class="nc" id="L3971">        method.setStatic(false);</span>
<span class="nc" id="L3972">        method.makePublic();</span>
<span class="nc" id="L3973">        int access = method.getAccessFlags();</span>

<span class="nc" id="L3975">        Code code = method.getCode(true);</span>
<span class="nc bnc" id="L3976" title="All 2 branches missed.">        if (impl) {</span>
            // return pcDetachedState;
<span class="nc" id="L3978">            loadManagedInstance(code, false);</span>
<span class="nc" id="L3979">            getfield(code, _managedType.getProject().loadClass(declarer),</span>
                name);
        } else
<span class="nc" id="L3982">            code.constant().setNull();</span>
<span class="nc" id="L3983">        code.areturn();</span>
<span class="nc" id="L3984">        code.calculateMaxLocals();</span>
<span class="nc" id="L3985">        code.calculateMaxStack();</span>

        // public void pcSetDetachedState (Object state)
<span class="nc" id="L3988">        method = _pc.declareMethod(PRE + &quot;SetDetachedState&quot;,</span>
            void.class, new Class []{ Object.class });
<span class="nc" id="L3990">        method.setAccessFlags(access);</span>
<span class="nc" id="L3991">        code = method.getCode(true);</span>
<span class="nc bnc" id="L3992" title="All 2 branches missed.">        if (impl) {</span>
            // pcDetachedState = state;
<span class="nc" id="L3994">            loadManagedInstance(code, false);</span>
<span class="nc" id="L3995">            code.aload().setParam(0);</span>
<span class="nc" id="L3996">            putfield(code, _managedType.getProject().loadClass(declarer),</span>
                name, Object.class);
        }
<span class="nc" id="L3999">        code.vreturn();</span>
<span class="nc" id="L4000">        code.calculateMaxStack();</span>
<span class="nc" id="L4001">        code.calculateMaxLocals();</span>
<span class="nc" id="L4002">    }</span>

    /**
     * Adds to &lt;code&gt;code&lt;/code&gt; the instructions to get field
     * &lt;code&gt;attrName&lt;/code&gt; declared in type &lt;code&gt;declarer&lt;/code&gt;
     * onto the top of the stack.
     *
     * The instance to access must already be on the top of the
     * stack when this is invoked.
     */
    private void getfield(Code code, BCClass declarer, String attrName) {
<span class="nc bnc" id="L4013" title="All 2 branches missed.">        if (declarer == null)</span>
<span class="nc" id="L4014">            declarer = _managedType;</span>

        // first, see if we can convert the attribute name to a field name
<span class="nc" id="L4017">        String fieldName = toBackingFieldName(attrName);</span>

        // next, find the field in the managed type hierarchy
<span class="nc" id="L4020">        BCField field = null;</span>
<span class="nc bnc" id="L4021" title="All 2 branches missed.">        outer: for (BCClass bc = _pc; bc != null; bc = bc.getSuperclassBC()) {</span>
<span class="nc" id="L4022">            BCField[] fields = AccessController</span>
<span class="nc" id="L4023">                .doPrivileged(J2DoPrivHelper.getBCClassFieldsAction(bc,</span>
                    fieldName));
<span class="nc bnc" id="L4025" title="All 2 branches missed.">            for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc" id="L4026">                field = fields[i];</span>
                // if we reach a field declared in this type, then this is the
                // most-masking field, and is the one that we want.
<span class="nc bnc" id="L4029" title="All 2 branches missed.">                if (fields[i].getDeclarer() == declarer) {</span>
<span class="nc" id="L4030">                    break outer;</span>
                }
            }
        }

<span class="nc bnc" id="L4035" title="All 6 branches missed.">        if (getCreateSubclass() &amp;&amp; code.getMethod().getDeclarer() == _pc</span>
<span class="nc bnc" id="L4036" title="All 2 branches missed.">            &amp;&amp; (field == null || !field.isPublic())) {</span>
            // we're creating the subclass, not redefining the user type.

            // Reflection.getXXX(this, Reflection.findField(...));
<span class="nc" id="L4040">            code.classconstant().setClass(declarer);</span>
<span class="nc" id="L4041">            code.constant().setValue(fieldName);</span>
<span class="nc" id="L4042">            code.constant().setValue(true);</span>
<span class="nc" id="L4043">            code.invokestatic().setMethod(Reflection.class,</span>
                &quot;findField&quot;, Field.class, new Class[] {
                Class.class, String.class, boolean.class });
<span class="nc" id="L4046">            Class type = _meta.getField(attrName).getDeclaredType();</span>
            try {
<span class="nc" id="L4048">                code.invokestatic().setMethod(</span>
<span class="nc" id="L4049">                    getReflectionGetterMethod(type, Field.class));</span>
<span class="nc" id="L4050">            } catch (NoSuchMethodException e) {</span>
                // should never happen
<span class="nc" id="L4052">                throw new InternalException(e);</span>
<span class="nc" id="L4053">            }</span>
<span class="nc bnc" id="L4054" title="All 4 branches missed.">            if (!type.isPrimitive() &amp;&amp; type != Object.class)</span>
<span class="nc" id="L4055">                code.checkcast().setType(type);</span>
<span class="nc" id="L4056">        } else {</span>
<span class="nc" id="L4057">            code.getfield().setField(declarer.getName(), fieldName,</span>
<span class="nc" id="L4058">                field.getType().getName());</span>
        }
<span class="nc" id="L4060">    }</span>

    /**
     * Adds to &lt;code&gt;code&lt;/code&gt; the instructions to set field
     * &lt;code&gt;attrName&lt;/code&gt; declared in type &lt;code&gt;declarer&lt;/code&gt;
     * to the value of type &lt;code&gt;fieldType&lt;/code&gt; on the top of the stack.
     *
     * When this method is invoked, the value to load must
     * already be on the top of the stack in &lt;code&gt;code&lt;/code&gt;,
     * and the instance to load into must be second.
     */
    private void putfield(Code code, BCClass declarer, String attrName,
        Class fieldType) {
<span class="nc bnc" id="L4073" title="All 2 branches missed.">        if (declarer == null)</span>
<span class="nc" id="L4074">            declarer = _managedType;</span>

<span class="nc" id="L4076">        String fieldName = toBackingFieldName(attrName);</span>

<span class="nc bnc" id="L4078" title="All 4 branches missed.">        if (getRedefine() || getCreateSubclass()) {</span>
            // Reflection.set(this, Reflection.findField(...), value);
<span class="nc" id="L4080">            code.classconstant().setClass(declarer);</span>
<span class="nc" id="L4081">            code.constant().setValue(fieldName);</span>
<span class="nc" id="L4082">            code.constant().setValue(true);</span>
<span class="nc" id="L4083">            code.invokestatic().setMethod(Reflection.class,</span>
                &quot;findField&quot;, Field.class, new Class[] {
                Class.class, String.class, boolean.class });
<span class="nc" id="L4086">            code.invokestatic().setMethod(Reflection.class, &quot;set&quot;,</span>
                void.class,
                new Class[] {
                    Object.class,
<span class="nc bnc" id="L4090" title="All 2 branches missed.">                    fieldType.isPrimitive() ? fieldType : Object.class,</span>
                    Field.class });
        } else {
<span class="nc" id="L4093">            code.putfield()</span>
<span class="nc" id="L4094">                .setField(declarer.getName(), fieldName, fieldType.getName());</span>
        }
<span class="nc" id="L4096">    }</span>

    /**
     * If using property access, see if there is a different backing field
     * name for the persistent attribute &lt;code&gt;name&lt;/code&gt;.
     */
    private String toBackingFieldName(String name) {
        // meta is null when enhancing persistence-aware
<span class="nc bnc" id="L4104" title="All 2 branches missed.">    	FieldMetaData fmd = _meta == null ? null : _meta.getField(name);</span>
<span class="nc bnc" id="L4105" title="All 6 branches missed.">        if (_meta != null &amp;&amp; isPropertyAccess(fmd)</span>
<span class="nc bnc" id="L4106" title="All 2 branches missed.">            &amp;&amp; _attrsToFields != null &amp;&amp; _attrsToFields.containsKey(name))</span>
<span class="nc" id="L4107">            name = (String)_attrsToFields.get(name);</span>
<span class="nc" id="L4108">        return name;</span>
    }

    /**
     * If using property access, see if there is a different persistent
     * attribute name for the backing field &lt;code&gt;name&lt;/code&gt;.
     */
    private String fromBackingFieldName(String name) {
        // meta is null when enhancing persistence-aware
<span class="nc bnc" id="L4117" title="All 2 branches missed.">    	FieldMetaData fmd = _meta == null ? null : _meta.getField(name);</span>
<span class="nc bnc" id="L4118" title="All 6 branches missed.">        if (_meta != null &amp;&amp; isPropertyAccess(fmd)</span>
<span class="nc bnc" id="L4119" title="All 2 branches missed.">            &amp;&amp; _fieldsToAttrs != null &amp;&amp; _fieldsToAttrs.containsKey(name))</span>
<span class="nc" id="L4120">            return (String)_fieldsToAttrs.get(name);</span>
        else
<span class="nc" id="L4122">            return name;</span>
    }

    /**
     * Implement the externalizable interface to detach on serialize.
     */
    private void addDetachExternalize(boolean parentDetachable,
        boolean detachedState)
        throws NoSuchMethodException {
        // ensure that the declared default constructor is public
        // for externalization
<span class="nc" id="L4133">        BCMethod meth = _pc.getDeclaredMethod(&quot;&lt;init&gt;&quot;, (String[]) null);</span>
<span class="nc bnc" id="L4134" title="All 2 branches missed.">        if (!meth.isPublic()) {</span>
<span class="nc bnc" id="L4135" title="All 2 branches missed.">            if (_log.isWarnEnabled())</span>
<span class="nc" id="L4136">                _log.warn(_loc.get(&quot;enhance-defcons-extern&quot;,</span>
<span class="nc" id="L4137">                  _meta.getDescribedType()));</span>
<span class="nc" id="L4138">            meth.makePublic();</span>
        }
        // declare externalizable interface
<span class="nc bnc" id="L4141" title="All 2 branches missed.">        if (!Externalizable.class.isAssignableFrom(_meta.getDescribedType()))</span>
<span class="nc" id="L4142">            _pc.declareInterface(Externalizable.class);</span>

        // make sure the user doesn't already have custom externalization or
        // serialization methods
<span class="nc" id="L4146">        Class[] input = new Class[]{ ObjectInputStream.class };</span>
<span class="nc" id="L4147">        Class[] output = new Class[]{ ObjectOutputStream.class };</span>
<span class="nc bnc" id="L4148" title="All 2 branches missed.">        if (_managedType.getDeclaredMethod(&quot;readObject&quot;, input) != null</span>
<span class="nc bnc" id="L4149" title="All 2 branches missed.">            || _managedType.getDeclaredMethod(&quot;writeObject&quot;, output) != null)</span>
<span class="nc" id="L4150">            throw new UserException(_loc.get(&quot;detach-custom-ser&quot;, _meta));</span>
<span class="nc" id="L4151">        input[0] = ObjectInput.class;</span>
<span class="nc" id="L4152">        output[0] = ObjectOutput.class;</span>
<span class="nc bnc" id="L4153" title="All 2 branches missed.">        if (_managedType.getDeclaredMethod(&quot;readExternal&quot;, input) != null</span>
<span class="nc bnc" id="L4154" title="All 2 branches missed.">            || _managedType.getDeclaredMethod(&quot;writeExternal&quot;, output) != null)</span>
<span class="nc" id="L4155">            throw new UserException(_loc.get(&quot;detach-custom-extern&quot;, _meta));</span>

        // create list of all unmanaged serializable fields
<span class="nc" id="L4158">        BCField[] fields = _managedType.getDeclaredFields();</span>
<span class="nc" id="L4159">        Collection unmgd = new ArrayList(fields.length);</span>
<span class="nc bnc" id="L4160" title="All 2 branches missed.">        for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc bnc" id="L4161" title="All 4 branches missed.">            if (!fields[i].isTransient() &amp;&amp; !fields[i].isStatic()</span>
<span class="nc bnc" id="L4162" title="All 2 branches missed.">                &amp;&amp; !fields[i].isFinal()</span>
<span class="nc bnc" id="L4163" title="All 2 branches missed.">                &amp;&amp; !fields[i].getName().startsWith(PRE)</span>
<span class="nc bnc" id="L4164" title="All 2 branches missed.">                &amp;&amp; _meta.getDeclaredField(fields[i].getName()) == null)</span>
<span class="nc" id="L4165">                unmgd.add(fields[i]);</span>
        }

<span class="nc" id="L4168">        addReadExternal(parentDetachable, detachedState);</span>
<span class="nc" id="L4169">        addReadUnmanaged(unmgd, parentDetachable);</span>
<span class="nc" id="L4170">        addWriteExternal(parentDetachable, detachedState);</span>
<span class="nc" id="L4171">        addWriteUnmanaged(unmgd, parentDetachable);</span>
<span class="nc" id="L4172">    }</span>

    /**
     * Add custom readExternal method.
     */
    private void addReadExternal(boolean parentDetachable,
        boolean detachedState)
        throws NoSuchMethodException {
<span class="nc" id="L4180">        Class[] inargs = new Class[]{ ObjectInput.class };</span>
<span class="nc" id="L4181">        BCMethod meth = _pc.declareMethod(&quot;readExternal&quot;, void.class, inargs);</span>
<span class="nc" id="L4182">        Exceptions exceps = meth.getExceptions(true);</span>
<span class="nc" id="L4183">        exceps.addException(IOException.class);</span>
<span class="nc" id="L4184">        exceps.addException(ClassNotFoundException.class);</span>
<span class="nc" id="L4185">        Code code = meth.getCode(true);</span>

        // super.readExternal (in);
        // not sure if this works: this is depending on the order of the enhancement!
        // if the subclass gets enhanced first, then the superclass misses
        // the Externalizable at this point!
<span class="nc" id="L4191">        Class&lt;?&gt; sup = _meta.getDescribedType().getSuperclass();</span>
<span class="nc bnc" id="L4192" title="All 4 branches missed.">        if (!parentDetachable &amp;&amp; Externalizable.class.isAssignableFrom(sup)) {</span>
<span class="nc" id="L4193">            loadManagedInstance(code, false);</span>
<span class="nc" id="L4194">            code.aload().setParam(0);</span>
<span class="nc" id="L4195">            code.invokespecial().setMethod(sup, &quot;readExternal&quot;,</span>
                void.class, inargs);
        }

        // readUnmanaged (in);
<span class="nc" id="L4200">        loadManagedInstance(code, false);</span>
<span class="nc" id="L4201">        code.aload().setParam(0);</span>
<span class="nc" id="L4202">        code.invokevirtual().setMethod(getType(_meta),</span>
            PRE + &quot;ReadUnmanaged&quot;, void.class, inargs);

<span class="nc bnc" id="L4205" title="All 2 branches missed.">        if (detachedState) {</span>
            // pcSetDetachedState (in.readObject ());
<span class="nc" id="L4207">            loadManagedInstance(code, false);</span>
<span class="nc" id="L4208">            code.aload().setParam(0);</span>
<span class="nc" id="L4209">            code.invokeinterface().setMethod(ObjectInput.class, &quot;readObject&quot;,</span>
                Object.class, null);
<span class="nc" id="L4211">            code.invokevirtual().setMethod(PRE + &quot;SetDetachedState&quot;,</span>
                void.class, new Class[]{ Object.class });

            // pcReplaceStateManager ((StateManager) in.readObject ());
<span class="nc" id="L4215">            loadManagedInstance(code, false);</span>
<span class="nc" id="L4216">            code.aload().setParam(0);</span>
<span class="nc" id="L4217">            code.invokeinterface().setMethod(ObjectInput.class, &quot;readObject&quot;,</span>
                Object.class, null);
<span class="nc" id="L4219">            code.checkcast().setType(StateManager.class);</span>
<span class="nc" id="L4220">            code.invokevirtual().setMethod(PRE + &quot;ReplaceStateManager&quot;,</span>
                void.class, new Class[]{ StateManager.class });
        }

<span class="nc" id="L4224">        addReadExternalFields();</span>

        // readExternalFields(in.readObject ());
<span class="nc" id="L4227">        loadManagedInstance(code, false);</span>
<span class="nc" id="L4228">        code.aload().setParam(0);</span>
<span class="nc" id="L4229">        code.invokevirtual().setMethod(&quot;readExternalFields&quot;,</span>
            void.class, inargs);

<span class="nc" id="L4232">        code.vreturn();</span>
<span class="nc" id="L4233">        code.calculateMaxStack();</span>
<span class="nc" id="L4234">        code.calculateMaxLocals();</span>
<span class="nc" id="L4235">    }</span>

    private void addReadExternalFields() throws NoSuchMethodException {
<span class="nc" id="L4238">        Class&lt;?&gt;[] inargs = new Class[]{ ObjectInput.class };</span>
<span class="nc" id="L4239">        BCMethod meth = _pc.declareMethod(&quot;readExternalFields&quot;, void.class, inargs);</span>
<span class="nc" id="L4240">        meth.setAccessFlags(Constants.ACCESS_PROTECTED);</span>
<span class="nc" id="L4241">        Exceptions exceps = meth.getExceptions(true);</span>
<span class="nc" id="L4242">        exceps.addException(IOException.class);</span>
<span class="nc" id="L4243">        exceps.addException(ClassNotFoundException.class);</span>
<span class="nc" id="L4244">        Code code = meth.getCode(true);</span>

<span class="nc" id="L4246">        Class&lt;?&gt; sup = _meta.getPCSuperclass();</span>
<span class="nc bnc" id="L4247" title="All 2 branches missed.">        if (sup != null) {</span>
            //add a call to super.readExternalFields()
<span class="nc" id="L4249">            loadManagedInstance(code, false);</span>
<span class="nc" id="L4250">            code.aload().setParam(0);</span>
<span class="nc" id="L4251">            code.invokespecial().setMethod(sup, &quot;readExternalFields&quot;, void.class, inargs);</span>
        }

        // read managed fields
<span class="nc" id="L4255">        FieldMetaData[] fmds = _meta.getDeclaredFields();</span>
<span class="nc bnc" id="L4256" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L4257" title="All 2 branches missed.">            if (!fmds[i].isTransient()) {</span>
<span class="nc" id="L4258">                readExternal(code, fmds[i].getName(),</span>
<span class="nc" id="L4259">                    fmds[i].getDeclaredType(), fmds[i]);</span>
            }
        }

<span class="nc" id="L4263">        code.vreturn();</span>
<span class="nc" id="L4264">        code.calculateMaxStack();</span>
<span class="nc" id="L4265">        code.calculateMaxLocals();</span>
<span class="nc" id="L4266">    }</span>

    /**
     * Read unmanaged fields from the stream (pcReadUnmanaged).
     */
    private void addReadUnmanaged(Collection unmgd, boolean parentDetachable)
        throws NoSuchMethodException {
<span class="nc" id="L4273">        Class[] inargs = new Class[]{ ObjectInput.class };</span>
<span class="nc" id="L4274">        BCMethod meth = _pc.declareMethod(PRE + &quot;ReadUnmanaged&quot;, void.class,</span>
            inargs);
<span class="nc" id="L4276">        meth.makeProtected();</span>
<span class="nc" id="L4277">        Exceptions exceps = meth.getExceptions(true);</span>
<span class="nc" id="L4278">        exceps.addException(IOException.class);</span>
<span class="nc" id="L4279">        exceps.addException(ClassNotFoundException.class);</span>
<span class="nc" id="L4280">        Code code = meth.getCode(true);</span>

        // super.readUnmanaged (in);
<span class="nc bnc" id="L4283" title="All 2 branches missed.">        if (parentDetachable) {</span>
<span class="nc" id="L4284">            loadManagedInstance(code, false);</span>
<span class="nc" id="L4285">            code.aload().setParam(0);</span>
<span class="nc" id="L4286">            code.invokespecial().setMethod(getType(_meta.</span>
<span class="nc" id="L4287">                getPCSuperclassMetaData()), PRE + &quot;ReadUnmanaged&quot;, void.class,</span>
                inargs);
        }

        // read declared unmanaged serializable fields
        BCField field;
<span class="nc bnc" id="L4293" title="All 2 branches missed.">        for (Iterator itr = unmgd.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L4294">            field = (BCField) itr.next();</span>
<span class="nc" id="L4295">            readExternal(code, field.getName(), field.getType(), null);</span>
        }
<span class="nc" id="L4297">        code.vreturn();</span>
<span class="nc" id="L4298">        code.calculateMaxStack();</span>
<span class="nc" id="L4299">        code.calculateMaxLocals();</span>
<span class="nc" id="L4300">    }</span>

    /**
     * Helper method to read a field from an externalization input stream.
     */
    private void readExternal(Code code, String fieldName, Class type,
        FieldMetaData fmd)
        throws NoSuchMethodException {
        String methName;
<span class="nc bnc" id="L4309" title="All 2 branches missed.">        if (type.isPrimitive()) {</span>
<span class="nc" id="L4310">            methName = type.getName();</span>
<span class="nc" id="L4311">            methName = methName.substring(0, 1).toUpperCase(Locale.ENGLISH)</span>
<span class="nc" id="L4312">                + methName.substring(1);</span>
<span class="nc" id="L4313">            methName = &quot;read&quot; + methName;</span>
        } else
<span class="nc" id="L4315">            methName = &quot;readObject&quot;;</span>

        // &lt;field&gt; = in.read&lt;type&gt; ();
<span class="nc" id="L4318">        loadManagedInstance(code, false);</span>
<span class="nc" id="L4319">        code.aload().setParam(0);</span>
<span class="nc bnc" id="L4320" title="All 2 branches missed.">        Class ret = (type.isPrimitive()) ? type : Object.class;</span>
<span class="nc" id="L4321">        code.invokeinterface().setMethod(ObjectInput.class, methName,</span>
            ret, null);
<span class="nc bnc" id="L4323" title="All 4 branches missed.">        if (!type.isPrimitive() &amp;&amp; type != Object.class)</span>
<span class="nc" id="L4324">            code.checkcast().setType(type);</span>
<span class="nc bnc" id="L4325" title="All 2 branches missed.">        if (fmd == null)</span>
<span class="nc" id="L4326">            putfield(code, null, fieldName, type);</span>
        else {
<span class="nc" id="L4328">            addSetManagedValueCode(code, fmd);</span>
<span class="nc bnc" id="L4329" title="All 2 branches missed.">            switch (fmd.getDeclaredTypeCode()) {</span>
                case JavaTypes.DATE:
                case JavaTypes.ARRAY:
                case JavaTypes.COLLECTION:
                case JavaTypes.MAP:
                case JavaTypes.OBJECT:
                case JavaTypes.CALENDAR:
                    // if (sm != null)
                    //   sm.proxyDetachedDeserialized (&lt;index&gt;);
<span class="nc" id="L4338">                    loadManagedInstance(code, false);</span>
<span class="nc" id="L4339">                    code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L4340">                    IfInstruction ifins = code.ifnull();</span>
<span class="nc" id="L4341">                    loadManagedInstance(code, false);</span>
<span class="nc" id="L4342">                    code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L4343">                    code.constant().setValue(fmd.getIndex());</span>
<span class="nc" id="L4344">                    code.invokeinterface().setMethod(SMTYPE,</span>
                        &quot;proxyDetachedDeserialized&quot;, void.class,
                        new Class[]{ int.class });
<span class="nc" id="L4347">                    ifins.setTarget(code.nop());</span>
            }
        }
<span class="nc" id="L4350">    }</span>

    /**
     * Add custom writeExternal method.
     */
    private void addWriteExternal(boolean parentDetachable,
        boolean detachedState)
        throws NoSuchMethodException {
<span class="nc" id="L4358">        Class[] outargs = new Class[]{ ObjectOutput.class };</span>
<span class="nc" id="L4359">        BCMethod meth = _pc.declareMethod(&quot;writeExternal&quot;, void.class, outargs);</span>
<span class="nc" id="L4360">        Exceptions exceps = meth.getExceptions(true);</span>
<span class="nc" id="L4361">        exceps.addException(IOException.class);</span>
<span class="nc" id="L4362">        Code code = meth.getCode(true);</span>

        // super.writeExternal (out);
<span class="nc" id="L4365">        Class sup = getType(_meta).getSuperclass();</span>
<span class="nc bnc" id="L4366" title="All 4 branches missed.">        if (!parentDetachable &amp;&amp; Externalizable.class.isAssignableFrom(sup)) {</span>
<span class="nc" id="L4367">            loadManagedInstance(code, false);</span>
<span class="nc" id="L4368">            code.aload().setParam(0);</span>
<span class="nc" id="L4369">            code.invokespecial().setMethod(sup, &quot;writeExternal&quot;,</span>
                void.class, outargs);
        }

        // writeUnmanaged (out);
<span class="nc" id="L4374">        loadManagedInstance(code, false);</span>
<span class="nc" id="L4375">        code.aload().setParam(0);</span>
<span class="nc" id="L4376">        code.invokevirtual().setMethod(getType(_meta),</span>
            PRE + &quot;WriteUnmanaged&quot;, void.class, outargs);

<span class="nc" id="L4379">        JumpInstruction go2 = null;</span>
<span class="nc bnc" id="L4380" title="All 2 branches missed.">        if (detachedState) {</span>
            // if (sm != null)
            //   if (sm.writeDetached (out))
            //      return;
<span class="nc" id="L4384">            loadManagedInstance(code, false);</span>
<span class="nc" id="L4385">            code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L4386">            IfInstruction ifnull = code.ifnull();</span>
<span class="nc" id="L4387">            loadManagedInstance(code, false);</span>
<span class="nc" id="L4388">            code.getfield().setField(SM, SMTYPE);</span>
<span class="nc" id="L4389">            code.aload().setParam(0);</span>
<span class="nc" id="L4390">            code.invokeinterface().setMethod(SMTYPE, &quot;writeDetached&quot;,</span>
                boolean.class, outargs);
<span class="nc" id="L4392">            go2 = code.ifeq();</span>
<span class="nc" id="L4393">            code.vreturn();</span>

            // else
            //   out.writeObject (pcGetDetachedState ());
<span class="nc" id="L4397">            Class[] objargs = new Class[]{ Object.class };</span>
<span class="nc" id="L4398">            ifnull.setTarget(code.aload().setParam(0));</span>
<span class="nc" id="L4399">            loadManagedInstance(code, false);</span>
<span class="nc" id="L4400">            code.invokevirtual().setMethod(PRE + &quot;GetDetachedState&quot;,</span>
                Object.class, null);
<span class="nc" id="L4402">            code.invokeinterface().setMethod(ObjectOutput.class,</span>
                &quot;writeObject&quot;, void.class, objargs);
            //    out.writeObject (null) // StateManager
<span class="nc" id="L4405">            code.aload().setParam(0);</span>
<span class="nc" id="L4406">            code.constant().setValue((Object) null);</span>
<span class="nc" id="L4407">            code.invokeinterface().setMethod(ObjectOutput.class,</span>
                &quot;writeObject&quot;, void.class, objargs);
        }
<span class="nc bnc" id="L4410" title="All 2 branches missed.">        if (go2 != null)</span>
<span class="nc" id="L4411">            go2.setTarget(code.nop());</span>

<span class="nc" id="L4413">        addWriteExternalFields();</span>

<span class="nc" id="L4415">        loadManagedInstance(code, false);</span>
<span class="nc" id="L4416">        code.aload().setParam(0);</span>
<span class="nc" id="L4417">        code.invokevirtual().setMethod(&quot;writeExternalFields&quot;,</span>
            void.class, outargs);

        // return
<span class="nc" id="L4421">        code.vreturn();</span>
<span class="nc" id="L4422">        code.calculateMaxStack();</span>
<span class="nc" id="L4423">        code.calculateMaxLocals();</span>
<span class="nc" id="L4424">    }</span>


    private void addWriteExternalFields()
        throws NoSuchMethodException {
<span class="nc" id="L4429">        Class&lt;?&gt;[] outargs = new Class[]{ ObjectOutput.class };</span>
<span class="nc" id="L4430">        BCMethod meth = _pc.declareMethod(&quot;writeExternalFields&quot;, void.class, outargs);</span>
<span class="nc" id="L4431">        meth.setAccessFlags(Constants.ACCESS_PROTECTED);</span>
<span class="nc" id="L4432">        Exceptions exceps = meth.getExceptions(true);</span>
<span class="nc" id="L4433">        exceps.addException(IOException.class);</span>
<span class="nc" id="L4434">        Code code = meth.getCode(true);</span>

<span class="nc" id="L4436">        Class&lt;?&gt; sup = _meta.getPCSuperclass();</span>
<span class="nc bnc" id="L4437" title="All 2 branches missed.">        if (sup != null) {</span>
            // add a call to super.readExternalFields()
<span class="nc" id="L4439">            loadManagedInstance(code, false);</span>
<span class="nc" id="L4440">            code.aload().setParam(0);</span>
<span class="nc" id="L4441">            code.invokespecial().setMethod(sup, &quot;writeExternalFields&quot;, void.class, outargs);</span>
        }

<span class="nc" id="L4444">        FieldMetaData[] fmds = _meta.getDeclaredFields();</span>
<span class="nc bnc" id="L4445" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L4446" title="All 2 branches missed.">            if (!fmds[i].isTransient()) {</span>
<span class="nc" id="L4447">                writeExternal(code, fmds[i].getName(),</span>
<span class="nc" id="L4448">                    fmds[i].getDeclaredType(), fmds[i]);</span>
            }
        }

        // return
<span class="nc" id="L4453">        code.vreturn();</span>
<span class="nc" id="L4454">        code.calculateMaxStack();</span>
<span class="nc" id="L4455">        code.calculateMaxLocals();</span>
<span class="nc" id="L4456">    }</span>

    /**
     * Write unmanaged fields to the stream (pcWriteUnmanaged).
     */
    private void addWriteUnmanaged(Collection unmgd, boolean parentDetachable)
        throws NoSuchMethodException {
<span class="nc" id="L4463">        Class[] outargs = new Class[]{ ObjectOutput.class };</span>
<span class="nc" id="L4464">        BCMethod meth = _pc.declareMethod(PRE + &quot;WriteUnmanaged&quot;, void.class,</span>
            outargs);
<span class="nc" id="L4466">        meth.makeProtected();</span>
<span class="nc" id="L4467">        Exceptions exceps = meth.getExceptions(true);</span>
<span class="nc" id="L4468">        exceps.addException(IOException.class);</span>
<span class="nc" id="L4469">        Code code = meth.getCode(true);</span>

        // super.writeUnmanaged (out);
<span class="nc bnc" id="L4472" title="All 2 branches missed.">        if (parentDetachable) {</span>
<span class="nc" id="L4473">            loadManagedInstance(code, false);</span>
<span class="nc" id="L4474">            code.aload().setParam(0);</span>
<span class="nc" id="L4475">            code.invokespecial().setMethod(getType(_meta.</span>
<span class="nc" id="L4476">                getPCSuperclassMetaData()), PRE + &quot;WriteUnmanaged&quot;, void.class,</span>
                outargs);
        }

        // write declared unmanaged serializable fields
        BCField field;
<span class="nc bnc" id="L4482" title="All 2 branches missed.">        for (Iterator itr = unmgd.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L4483">            field = (BCField) itr.next();</span>
<span class="nc" id="L4484">            writeExternal(code, field.getName(), field.getType(), null);</span>
        }
<span class="nc" id="L4486">        code.vreturn();</span>
<span class="nc" id="L4487">        code.calculateMaxStack();</span>
<span class="nc" id="L4488">        code.calculateMaxLocals();</span>
<span class="nc" id="L4489">    }</span>

    /**
     * Helper method to write a field to an externalization output stream.
     */
    private void writeExternal(Code code, String fieldName, Class type,
        FieldMetaData fmd)
        throws NoSuchMethodException {
        String methName;
<span class="nc bnc" id="L4498" title="All 2 branches missed.">        if (type.isPrimitive()) {</span>
<span class="nc" id="L4499">            methName = type.getName();</span>
<span class="nc" id="L4500">            methName = methName.substring(0, 1).toUpperCase(Locale.ENGLISH)</span>
<span class="nc" id="L4501">                + methName.substring(1);</span>
<span class="nc" id="L4502">            methName = &quot;write&quot; + methName;</span>
        } else
<span class="nc" id="L4504">            methName = &quot;writeObject&quot;;</span>

        // out.write&lt;type&gt; (&lt;field&gt;);
<span class="nc" id="L4507">        code.aload().setParam(0);</span>
<span class="nc" id="L4508">        loadManagedInstance(code, false);</span>
<span class="nc bnc" id="L4509" title="All 2 branches missed.">        if (fmd == null)</span>
<span class="nc" id="L4510">            getfield(code, null, fieldName);</span>
        else
<span class="nc" id="L4512">            addGetManagedValueCode(code, fmd);</span>
<span class="nc" id="L4513">        Class[] args = new Class[]{ type };</span>
<span class="nc bnc" id="L4514" title="All 6 branches missed.">        if (type == byte.class || type == char.class || type == short.class)</span>
<span class="nc" id="L4515">            args[0] = int.class;</span>
<span class="nc bnc" id="L4516" title="All 2 branches missed.">        else if (!type.isPrimitive())</span>
<span class="nc" id="L4517">            args[0] = Object.class;</span>
<span class="nc" id="L4518">        code.invokeinterface().setMethod(ObjectOutput.class, methName,</span>
            void.class, args);
<span class="nc" id="L4520">    }</span>

    private void addGetManagedValueCode(Code code, FieldMetaData fmd)
        throws NoSuchMethodException {
<span class="nc" id="L4524">        addGetManagedValueCode(code, fmd, true);</span>
<span class="nc" id="L4525">    }</span>

    /**
     * Load the field value specified by &lt;code&gt;fmd&lt;/code&gt; onto the stack.
     * Before this method is called, the object that the data should be loaded
     * from will be on the top of the stack.
     *
     * @param fromSameClass if &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;fmd&lt;/code&gt; is
     * being loaded from an instance of the same class as the current execution
     * context. If &lt;code&gt;false&lt;/code&gt;, then the instance on the top of the stack
     * might be a superclass of the current execution context's 'this' instance.
     */
    private void addGetManagedValueCode(Code code, FieldMetaData fmd,
        boolean fromSameClass)
        throws NoSuchMethodException {
        // if redefining, then we must always reflect (or access the field
        // directly if accessible), since the redefined methods will always
        // trigger method calls to StateManager, even from internal direct-
        // access usage. We could work around this by not redefining, and
        // just do a subclass approach instead. But this is not a good option,
        // since it would sacrifice lazy loading and efficient dirty tracking.

<span class="nc bnc" id="L4547" title="All 4 branches missed.">        if (getRedefine() || isFieldAccess(fmd)) {</span>
<span class="nc" id="L4548">            getfield(code, null, fmd.getName());</span>
<span class="nc bnc" id="L4549" title="All 2 branches missed.">        } else if (getCreateSubclass()) {</span>
            // property access, and we're not redefining. If we're operating
            // on an instance that is definitely the same type as 'this', then
            // call superclass method to bypass tracking. Otherwise, reflect
            // to both bypass tracking and avoid class verification errors.
<span class="nc bnc" id="L4554" title="All 2 branches missed.">            if (fromSameClass) {</span>
<span class="nc" id="L4555">                Method meth = (Method) fmd.getBackingMember();</span>
<span class="nc" id="L4556">                code.invokespecial().setMethod(meth);</span>
<span class="nc" id="L4557">            } else {</span>
<span class="nc" id="L4558">                getfield(code, null, fmd.getName());</span>
            }
        } else {
            // regular enhancement + property access
<span class="nc" id="L4562">            Method meth = (Method) fmd.getBackingMember();</span>
<span class="nc" id="L4563">            code.invokevirtual().setMethod(PRE + meth.getName(),</span>
<span class="nc" id="L4564">                meth.getReturnType(), meth.getParameterTypes());</span>
        }
<span class="nc" id="L4566">    }</span>

    /**
     * Store the value at the top of the stack into the field value specified
     * by &lt;code&gt;fmd&lt;/code&gt;. Before this method is called, the data to load will
     * be on the top of the stack and the object that the data should be loaded
     * into will be second in the stack.
     */
    private void addSetManagedValueCode(Code code, FieldMetaData fmd)
        throws NoSuchMethodException {
        // if redefining, then we must always reflect (or access the field
        // directly if accessible), since the redefined methods will always
        // trigger method calls to StateManager, even from internal direct-
        // access usage. We could work around this by not redefining, and
        // just do a subclass approach instead. But this is not a good option,
        // since it would sacrifice lazy loading and efficient dirty tracking.

<span class="nc bnc" id="L4583" title="All 4 branches missed.">        if (getRedefine() || isFieldAccess(fmd)) {</span>
<span class="nc" id="L4584">            putfield(code, null, fmd.getName(), fmd.getDeclaredType());</span>
<span class="nc bnc" id="L4585" title="All 2 branches missed.">        } else if (getCreateSubclass()) {</span>
            // property access, and we're not redefining. invoke the
            // superclass method to bypass tracking.
<span class="nc" id="L4588">            code.invokespecial().setMethod(_managedType.getType(),</span>
<span class="nc" id="L4589">                getSetterName(fmd), void.class,</span>
<span class="nc" id="L4590">                new Class[] { fmd.getDeclaredType() });</span>
        } else {
            // regular enhancement + property access
<span class="nc" id="L4593">            code.invokevirtual().setMethod(PRE + getSetterName(fmd),</span>
<span class="nc" id="L4594">                void.class, new Class[] { fmd.getDeclaredType() });</span>
        }
<span class="nc" id="L4596">    }</span>

    /**
     * Add the {@link Instruction}s to load the instance to modify onto the
     * stack, and return it. If &lt;code&gt;forStatic&lt;/code&gt; is set, then
     * &lt;code&gt;code&lt;/code&gt; is in an accessor method or another static method;
     * otherwise, it is in one of the PC-specified methods.
     *
     * @return the first instruction added to &lt;code&gt;code&lt;/code&gt;.
     */
    private Instruction loadManagedInstance(Code code, boolean forStatic,
            FieldMetaData fmd) {
<span class="nc bnc" id="L4608" title="All 4 branches missed.">        if (forStatic &amp;&amp; isFieldAccess(fmd))</span>
<span class="nc" id="L4609">            return code.aload().setParam(0);</span>
<span class="nc" id="L4610">        return code.aload().setThis();</span>
    }

    /**
     * Add the {@link Instruction}s to load the instance to modify onto the
     * stack, and return it.  This method should not be used to load static
     * fields.
     *
     * @return the first instruction added to &lt;code&gt;code&lt;/code&gt;.
     */
    private Instruction loadManagedInstance(Code code, boolean forStatic) {
<span class="nc" id="L4621">    	return loadManagedInstance(code, forStatic, null);</span>
    }

    private int getAccessorParameterOffset(FieldMetaData fmd) {
<span class="nc bnc" id="L4625" title="All 2 branches missed.">       return isFieldAccess(fmd) ? 1 : 0;</span>
    }

    /**
     * Affirms if the given class is using field-based access.
     */
    boolean isPropertyAccess(ClassMetaData meta) {
<span class="nc bnc" id="L4632" title="All 4 branches missed.">    	return meta != null &amp;&amp; (meta.isMixedAccess() ||</span>
<span class="nc bnc" id="L4633" title="All 2 branches missed.">    		AccessCode.isProperty(meta.getAccessType()));</span>
    }

    /**
     * Affirms if the given field is using field-based access.
     */
    boolean isPropertyAccess(FieldMetaData fmd) {
<span class="nc bnc" id="L4640" title="All 4 branches missed.">    	return fmd != null &amp;&amp; AccessCode.isProperty(fmd.getAccessType());</span>
    }

    /**
     * Affirms if the given field is using method-based access.
     */
    boolean isFieldAccess(FieldMetaData fmd) {
<span class="nc bnc" id="L4647" title="All 4 branches missed.">    	return fmd != null &amp;&amp; AccessCode.isField(fmd.getAccessType());</span>
    }

    /**
     * Create the generated getter {@link BCMethod} for &lt;code&gt;fmd&lt;/code&gt;. The
     * calling environment will then populate this method's code block.
     */
    private BCMethod createGetMethod(FieldMetaData fmd) {
        BCMethod getter;
<span class="nc bnc" id="L4656" title="All 2 branches missed.">        if (isFieldAccess(fmd)) {</span>
            // static &lt;fieldtype&gt; pcGet&lt;field&gt; (XXX inst)
<span class="nc" id="L4658">            BCField field = _pc.getDeclaredField(fmd.getName());</span>
<span class="nc" id="L4659">            getter = _pc.declareMethod(PRE + &quot;Get&quot; + fmd.getName(), fmd.</span>
<span class="nc" id="L4660">                getDeclaredType().getName(), new String[]{ _pc.getName() });</span>
<span class="nc" id="L4661">            getter.setAccessFlags(field.getAccessFlags()</span>
                &amp; ~Constants.ACCESS_TRANSIENT &amp; ~Constants.ACCESS_VOLATILE);
<span class="nc" id="L4663">            getter.setStatic(true);</span>
<span class="nc" id="L4664">            getter.setFinal(true);</span>
<span class="nc" id="L4665">            return getter;</span>
        }

        // property access:
        // copy the user's getter method to a new name; we can't just reset
        // the name, because that will also reset all calls to the method
<span class="nc" id="L4671">        Method meth = (Method) fmd.getBackingMember();</span>
<span class="nc" id="L4672">        getter = _pc.getDeclaredMethod(meth.getName(),</span>
<span class="nc" id="L4673">            meth.getParameterTypes());</span>
<span class="nc" id="L4674">        BCMethod newgetter = _pc.declareMethod(PRE + meth.getName(),</span>
<span class="nc" id="L4675">            meth.getReturnType(), meth.getParameterTypes());</span>
<span class="nc" id="L4676">        newgetter.setAccessFlags(getter.getAccessFlags());</span>
<span class="nc" id="L4677">        newgetter.makeProtected();</span>
<span class="nc" id="L4678">        transferCodeAttributes(getter, newgetter);</span>
<span class="nc" id="L4679">        return getter;</span>
    }

    /**
     * Create the generated setter {@link BCMethod} for &lt;code&gt;fmd&lt;/code&gt;. The
     * calling environment will then populate this method's code block.
     */
    private BCMethod createSetMethod(FieldMetaData fmd) {
        BCMethod setter;
<span class="nc bnc" id="L4688" title="All 2 branches missed.">        if (isFieldAccess(fmd)) {</span>
            // static void pcSet&lt;field&gt; (XXX inst, &lt;fieldtype&gt; value)
<span class="nc" id="L4690">            BCField field = _pc.getDeclaredField(fmd.getName());</span>
<span class="nc" id="L4691">            setter = _pc.declareMethod(PRE + &quot;Set&quot; + fmd.getName(), void.class,</span>
<span class="nc" id="L4692">                new Class[]{ getType(_meta), fmd.getDeclaredType() });</span>
<span class="nc" id="L4693">            setter.setAccessFlags(field.getAccessFlags()</span>
                &amp; ~Constants.ACCESS_TRANSIENT &amp; ~Constants.ACCESS_VOLATILE);
<span class="nc" id="L4695">            setter.setStatic(true);</span>
<span class="nc" id="L4696">            setter.setFinal(true);</span>
<span class="nc" id="L4697">            return setter;</span>
        }

        // property access:
        // copy the user's getter method to a new name; we can't just reset
        // the name, because that will also reset all calls to the method
<span class="nc" id="L4703">        setter = _pc.getDeclaredMethod(getSetterName(fmd),</span>
<span class="nc" id="L4704">            new Class[]{ fmd.getDeclaredType() });</span>
<span class="nc" id="L4705">        BCMethod newsetter = _pc.declareMethod(PRE + setter.getName(),</span>
<span class="nc" id="L4706">            setter.getReturnName(), setter.getParamNames());</span>
<span class="nc" id="L4707">        newsetter.setAccessFlags(setter.getAccessFlags());</span>
<span class="nc" id="L4708">        newsetter.makeProtected();</span>
<span class="nc" id="L4709">        transferCodeAttributes(setter, newsetter);</span>
<span class="nc" id="L4710">        return setter;</span>
    }

    private void addGetEnhancementContractVersionMethod() {
        // public int getEnhancementContractVersion()
<span class="nc" id="L4715">        BCMethod method = _pc.declareMethod(PRE +</span>
                &quot;GetEnhancementContractVersion&quot;, int.class, null);
<span class="nc" id="L4717">        method.makePublic();</span>
<span class="nc" id="L4718">        Code code = method.getCode(true);</span>
<span class="nc" id="L4719">        code.constant().setValue(ENHANCER_VERSION);</span>
<span class="nc" id="L4720">        code.ireturn();</span>
<span class="nc" id="L4721">        code.calculateMaxStack();</span>
<span class="nc" id="L4722">        code.calculateMaxLocals();</span>
<span class="nc" id="L4723">    }</span>

    /**
     * Return the concrete type for the given class, i.e. impl for managed
     * interfaces
     */
    public Class getType(ClassMetaData meta) {
<span class="nc bnc" id="L4730" title="All 2 branches missed.">        if (meta.getInterfaceImpl() != null)</span>
<span class="nc" id="L4731">            return meta.getInterfaceImpl();</span>
<span class="nc" id="L4732">        return meta.getDescribedType();</span>
    }

    /**
     * Move code-related attributes from one method to another.
     */
    private static void transferCodeAttributes(BCMethod from, BCMethod to) {
<span class="nc" id="L4739">        Code code = from.getCode(false);</span>
<span class="nc bnc" id="L4740" title="All 2 branches missed.">        if (code != null) {</span>
<span class="nc" id="L4741">            to.addAttribute(code);</span>
<span class="nc" id="L4742">            from.removeCode();</span>
        }

<span class="nc" id="L4745">        Exceptions exceps = from.getExceptions(false);</span>
<span class="nc bnc" id="L4746" title="All 2 branches missed.">        if (exceps != null)</span>
<span class="nc" id="L4747">            to.addAttribute(exceps);</span>
<span class="nc" id="L4748">    }</span>

    /**
     * Usage: java org.apache.openjpa.enhance.PCEnhancer [option]*
     * &amp;lt;class name | .java file | .class file | .jdo file&amp;gt;+
     *  Where the following options are recognized.
     * &lt;ul&gt;
     * &lt;li&gt;&lt;i&gt;-properties/-p &amp;lt;properties file&amp;gt;&lt;/i&gt;: The path to a OpenJPA
     * properties file containing information as outlined in
     * {@link Configuration}; optional.&lt;/li&gt;
     * &lt;li&gt;&lt;i&gt;-&amp;lt;property name&amp;gt; &amp;lt;property value&amp;gt;&lt;/i&gt;: All bean
     * properties of the standard OpenJPA {@link OpenJPAConfiguration} can be
     * set by using their names and supplying a value; for example:
     * &lt;li&gt;&lt;i&gt;-directory/-d &amp;lt;build directory&amp;gt;&lt;/i&gt;: The path to the base
     * directory where enhanced classes are stored. By default, the
     * enhancer overwrites the original .class file with the enhanced
     * version. Use this option to store the generated .class file in
     * another directory. The package structure will be created beneath
     * the given directory.&lt;/li&gt;
     * &lt;li&gt;&lt;i&gt;-addDefaultConstructor/-adc [true/t | false/f]&lt;/i&gt;: Whether to
     * add a default constructor to persistent classes missing one, as
     * opposed to throwing an exception. Defaults to true.&lt;/li&gt;
     * &lt;li&gt;&lt;i&gt;-tmpClassLoader/-tcl [true/t | false/f]&lt;/i&gt;: Whether to
     * load the pre-enhanced classes using a temporary class loader.
     * Defaults to true. Set this to false when attempting to debug
     * class loading errors.&lt;/li&gt;
     * &lt;li&gt;&lt;i&gt;-enforcePropertyRestrictions/-epr [true/t | false/f]&lt;/i&gt;:
     * Whether to throw an exception if a PROPERTY access entity appears
     * to be violating standard property restrictions. Defaults to false.&lt;/li&gt;
     * &lt;/ul&gt;
     *  Each additional argument can be either the full class name of the
     * type to enhance, the path to the .java file for the type, the path to
     * the .class file for the type, or the path to a .jdo file listing one
     * or more types to enhance.
     * If the type being enhanced has metadata, it will be enhanced as a
     * persistence capable class. If not, it will be considered a persistence
     * aware class, and all access to fields of persistence capable classes
     * will be replaced by the appropriate	get/set method. If the type
     * explicitly declares the persistence-capable interface, it will
     * not be enhanced. Thus, it is safe to invoke the enhancer on classes
     * that are already enhanced.
     */
    public static void main(String[] args) {
<span class="nc" id="L4791">        Options opts = new Options();</span>
<span class="nc" id="L4792">        args = opts.setFromCmdLine(args);</span>
<span class="nc bnc" id="L4793" title="All 2 branches missed.">        if (!run(args, opts)) {</span>
            // START - ALLOW PRINT STATEMENTS
<span class="nc" id="L4795">            System.err.println(_loc.get(&quot;enhance-usage&quot;));</span>
            // STOP - ALLOW PRINT STATEMENTS
        }
<span class="nc" id="L4798">    }</span>

    /**
     * Run the tool. Returns false if invalid options given. Runs against all
     * the persistence units defined in the resource to parse.
     */
    public static boolean run(final String[] args, Options opts) {
<span class="nc" id="L4805">        return Configurations.runAgainstAllAnchors(opts,</span>
<span class="nc" id="L4806">            new Configurations.Runnable() {</span>
            @Override
            public boolean run(Options opts) throws IOException {
<span class="nc" id="L4809">                OpenJPAConfiguration conf = new OpenJPAConfigurationImpl();</span>
                try {
<span class="nc" id="L4811">                    return PCEnhancer.run(conf, args, opts);</span>
                } finally {
<span class="nc" id="L4813">                    conf.close();</span>
                }
            }
        });
    }

    /**
     * Run the tool. Returns false if invalid options given.
     */
    public static boolean run(OpenJPAConfiguration conf, String[] args,
        Options opts)
        throws IOException {
<span class="nc" id="L4825">        Flags flags = new Flags();</span>
<span class="nc" id="L4826">        flags.directory = Files.getFile(opts.removeProperty(&quot;directory&quot;, &quot;d&quot;,</span>
            null), null);
<span class="nc" id="L4828">        flags.addDefaultConstructor = opts.removeBooleanProperty</span>
<span class="nc" id="L4829">            (&quot;addDefaultConstructor&quot;, &quot;adc&quot;, flags.addDefaultConstructor);</span>
<span class="nc" id="L4830">        flags.tmpClassLoader = opts.removeBooleanProperty</span>
<span class="nc" id="L4831">            (&quot;tmpClassLoader&quot;, &quot;tcl&quot;, flags.tmpClassLoader);</span>
<span class="nc" id="L4832">        flags.enforcePropertyRestrictions = opts.removeBooleanProperty</span>
<span class="nc" id="L4833">            (&quot;enforcePropertyRestrictions&quot;, &quot;epr&quot;,</span>
                flags.enforcePropertyRestrictions);

        // for unit testing
<span class="nc" id="L4837">        BytecodeWriter writer = (BytecodeWriter) opts.get(</span>
<span class="nc" id="L4838">            PCEnhancer.class.getName() + &quot;#bytecodeWriter&quot;);</span>

<span class="nc" id="L4840">        Configurations.populateConfiguration(conf, opts);</span>
<span class="nc" id="L4841">        return run(conf, args, flags, null, writer, null);</span>
    }

    /**
     * Enhance the given classes.
     */
    public static boolean run(OpenJPAConfiguration conf, String[] args,
        Flags flags, MetaDataRepository repos, BytecodeWriter writer,
        ClassLoader loader)
        throws IOException {
<span class="nc bnc" id="L4851" title="All 2 branches missed.">        if (loader == null)</span>
<span class="nc" id="L4852">            loader = conf.getClassResolverInstance().</span>
<span class="nc" id="L4853">                getClassLoader(PCEnhancer.class, null);</span>
<span class="nc bnc" id="L4854" title="All 2 branches missed.">        if (flags.tmpClassLoader)</span>
<span class="nc" id="L4855">            loader = AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc" id="L4856">                .newTemporaryClassLoaderAction(loader));</span>

<span class="nc bnc" id="L4858" title="All 2 branches missed.">        if (repos == null) {</span>
<span class="nc" id="L4859">            repos = conf.newMetaDataRepositoryInstance();</span>
<span class="nc" id="L4860">            repos.setSourceMode(MetaDataModes.MODE_META);</span>
        }

<span class="nc" id="L4863">        Log log = conf.getLog(OpenJPAConfiguration.LOG_TOOL);</span>
        Collection classes;
<span class="nc bnc" id="L4865" title="All 4 branches missed.">        if (args == null || args.length == 0) {</span>
<span class="nc" id="L4866">            classes = repos.getPersistentTypeNames(true, loader);</span>
<span class="nc bnc" id="L4867" title="All 2 branches missed.">            if (classes == null) {</span>
<span class="nc" id="L4868">            	log.warn(_loc.get(&quot;no-class-to-enhance&quot;));</span>
<span class="nc" id="L4869">            	return false;</span>
            }
        } else {
<span class="nc" id="L4872">            ClassArgParser cap = conf.getMetaDataRepositoryInstance().</span>
<span class="nc" id="L4873">                getMetaDataFactory().newClassArgParser();</span>
<span class="nc" id="L4874">            cap.setClassLoader(loader);</span>
<span class="nc" id="L4875">            classes = new HashSet();</span>
<span class="nc bnc" id="L4876" title="All 2 branches missed.">            for (int i = 0; i &lt; args.length; i++)</span>
<span class="nc" id="L4877">                classes.addAll(Arrays.asList(cap.parseTypes(args[i])));</span>
        }

<span class="nc" id="L4880">        Project project = new Project();</span>
        BCClass bc;
        PCEnhancer enhancer;
<span class="nc" id="L4883">        Collection persAwareClasses = new HashSet();</span>

        int status;
<span class="nc bnc" id="L4886" title="All 2 branches missed.">        for (Iterator itr = classes.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L4887">            Object o = itr.next();</span>
<span class="nc bnc" id="L4888" title="All 2 branches missed.">            if (log.isInfoEnabled())</span>
<span class="nc" id="L4889">                log.info(_loc.get(&quot;enhance-running&quot;, o));</span>

<span class="nc bnc" id="L4891" title="All 2 branches missed.">            if (o instanceof String)</span>
<span class="nc" id="L4892">                bc = project.loadClass((String) o, loader);</span>
            else
<span class="nc" id="L4894">                bc = project.loadClass((Class) o);</span>
<span class="nc" id="L4895">            enhancer = new PCEnhancer(conf, bc, repos, loader);</span>
<span class="nc bnc" id="L4896" title="All 2 branches missed.">            if (writer != null)</span>
<span class="nc" id="L4897">                enhancer.setBytecodeWriter(writer);</span>
<span class="nc" id="L4898">            enhancer.setDirectory(flags.directory);</span>
<span class="nc" id="L4899">            enhancer.setAddDefaultConstructor(flags.addDefaultConstructor);</span>
<span class="nc" id="L4900">            status = enhancer.run();</span>
<span class="nc bnc" id="L4901" title="All 2 branches missed.">            if (status == ENHANCE_NONE) {</span>
<span class="nc bnc" id="L4902" title="All 2 branches missed.">                if (log.isTraceEnabled())</span>
<span class="nc" id="L4903">                    log.trace(_loc.get(&quot;enhance-norun&quot;));</span>
<span class="nc bnc" id="L4904" title="All 2 branches missed.">            } else if (status == ENHANCE_INTERFACE) {</span>
<span class="nc bnc" id="L4905" title="All 2 branches missed.">                if (log.isTraceEnabled())</span>
<span class="nc" id="L4906">                    log.trace(_loc.get(&quot;enhance-interface&quot;));</span>
<span class="nc bnc" id="L4907" title="All 2 branches missed.">            } else if (status == ENHANCE_AWARE) {</span>
<span class="nc" id="L4908">                persAwareClasses.add(o);</span>
<span class="nc" id="L4909">                enhancer.record();</span>
            } else {
<span class="nc" id="L4911">                enhancer.record();</span>
            }
<span class="nc" id="L4913">            project.clear();</span>
<span class="nc" id="L4914">        }</span>
<span class="nc bnc" id="L4915" title="All 4 branches missed.">        if(log.isInfoEnabled() &amp;&amp; !persAwareClasses.isEmpty()){</span>
<span class="nc" id="L4916">        	log.info(_loc.get(&quot;pers-aware-classes&quot;, persAwareClasses.size(), persAwareClasses));</span>
        }
<span class="nc" id="L4918">        return true;</span>
    }

    /**
     * Run flags.
     */
<span class="nc" id="L4924">    public static class Flags {</span>

<span class="nc" id="L4926">        public File directory = null;</span>
<span class="nc" id="L4927">        public boolean addDefaultConstructor = true;</span>
<span class="nc" id="L4928">        public boolean tmpClassLoader = true;</span>
<span class="nc" id="L4929">        public boolean enforcePropertyRestrictions = false;</span>
    }

    /**
     * Plugin interface for additional enhancement.
     */
    public interface AuxiliaryEnhancer
    {
        void run (BCClass bc, ClassMetaData meta);
        boolean skipEnhance(BCMethod m);
    }

    private void addGetIDOwningClass() throws NoSuchMethodException {
<span class="nc" id="L4942">        BCMethod method = _pc.declareMethod(PRE + &quot;GetIDOwningClass&quot;,</span>
            Class.class, null);
<span class="nc" id="L4944">        Code code = method.getCode(true);</span>

<span class="nc" id="L4946">        code.classconstant().setClass(getType(_meta));</span>
<span class="nc" id="L4947">        code.areturn();</span>

<span class="nc" id="L4949">        code.calculateMaxStack();</span>
<span class="nc" id="L4950">        code.calculateMaxLocals();</span>
<span class="nc" id="L4951">    }</span>

    /**
     * This static public worker method detects and logs any Entities that may have been enhanced at build time by
     * a version of the enhancer that is older than the current version.
     *
     * @param cls
     *            - A non-null Class implementing org.apache.openjpa.enhance.PersistenceCapable.
     * @param log
     *            - A non-null org.apache.openjpa.lib.log.Log.
     *
     * @throws - IllegalStateException if cls doesn't implement org.apache.openjpa.enhance.PersistenceCapable.
     *
     * @return true if the provided Class is down level from the current PCEnhancer.ENHANCER_VERSION. False
     *         otherwise.
     */
    public static boolean checkEnhancementLevel(Class&lt;?&gt; cls, Log log) {
<span class="nc bnc" id="L4968" title="All 4 branches missed.">        if (cls == null || log == null) {</span>
<span class="nc" id="L4969">            return false;</span>
        }
<span class="nc" id="L4971">        PersistenceCapable pc = PCRegistry.newInstance(cls, null, false);</span>
<span class="nc bnc" id="L4972" title="All 2 branches missed.">        if (pc == null) {</span>
<span class="nc" id="L4973">            return false;</span>
        }
<span class="nc bnc" id="L4975" title="All 2 branches missed.">        if (pc.pcGetEnhancementContractVersion() &lt; PCEnhancer.ENHANCER_VERSION) {</span>
<span class="nc" id="L4976">            log.info(_loc.get(&quot;down-level-enhanced-entity&quot;, new Object[] { cls.getName(),</span>
<span class="nc" id="L4977">                pc.pcGetEnhancementContractVersion(), PCEnhancer.ENHANCER_VERSION }));</span>
<span class="nc" id="L4978">            return true;</span>
        }
<span class="nc" id="L4980">        return false;</span>
    }

    /**
     * Read the optimizedIdCopy value from the config (if available)
     */
    private void configureOptimizeIdCopy() {
<span class="nc bnc" id="L4987" title="All 4 branches missed.">        if (_repos != null &amp;&amp; _repos.getConfiguration() != null) {</span>
<span class="nc" id="L4988">            _optimizeIdCopy = _repos.getConfiguration().getOptimizeIdCopy();</span>
        }
<span class="nc" id="L4990">    }</span>

    /*
     * Cycles through all primary keys verifying whether they can and should
     * be used for faster oid copy.  The field must be private and must
     * not have a public setter.  If this is the case, the list of pk fields is
     * returned.  If not, returns null.
     */
    private ArrayList&lt;Integer&gt; optimizeIdCopy(Class&lt;?&gt; oidType, FieldMetaData[] fmds) {
        // collect all object id fields and verify they
        // a) have a private field
        // b) do not have a public setter
<span class="nc" id="L5002">        ArrayList&lt;Integer&gt; pkFields = new ArrayList&lt;&gt;();</span>
        // build list of primary key fields
<span class="nc bnc" id="L5004" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L5005" title="All 2 branches missed.">            if (!fmds[i].isPrimaryKey())</span>
<span class="nc" id="L5006">                continue;</span>
            // optimizing copy with PC type not (yet) supported
<span class="nc bnc" id="L5008" title="All 2 branches missed.">            if (fmds[i].getDeclaredTypeCode() == JavaTypes.PC) {</span>
<span class="nc" id="L5009">                return null;</span>
            }
<span class="nc" id="L5011">            String name = fmds[i].getName();</span>
<span class="nc" id="L5012">            Field fld = Reflection.findField(oidType, name, false);</span>
<span class="nc bnc" id="L5013" title="All 4 branches missed.">            if (fld == null || Modifier.isPublic(fld.getModifiers())) {</span>
<span class="nc" id="L5014">                return null;</span>
            }
<span class="nc" id="L5016">            Method setter = Reflection.findSetter(oidType, name, false);</span>
<span class="nc bnc" id="L5017" title="All 4 branches missed.">            if (setter == null || !Modifier.isPublic(setter.getModifiers())) {</span>
<span class="nc" id="L5018">                pkFields.add(i);</span>
            } else {
<span class="nc" id="L5020">                return null;</span>
            }
        }
<span class="nc bnc" id="L5023" title="All 2 branches missed.">        return pkFields.size() &gt; 0 ? pkFields : null;</span>
    }

    /*
     * Cycles through all constructors of an IdClass and examines the instructions to find
     * a matching constructor for the provided pk fields.  If a match is found, it returns
     * the order (relative to the field metadata) of the constructor parameters.  If a match
     * is not found, returns null.
    */
    private int[] getIdClassConstructorParmOrder(Class&lt;?&gt; oidType, ArrayList&lt;Integer&gt; pkfields,
            FieldMetaData[] fmds) {
<span class="nc" id="L5034">        Project project = new Project();</span>
<span class="nc" id="L5035">        BCClass bc = project.loadClass(oidType);</span>
<span class="nc" id="L5036">        BCMethod[] methods = bc.getDeclaredMethods(&quot;&lt;init&gt;&quot;);</span>
<span class="nc bnc" id="L5037" title="All 4 branches missed.">        if (methods == null || methods.length == 0) {</span>
<span class="nc" id="L5038">            return null;</span>
        }

<span class="nc" id="L5041">        int parmOrder[] = new int[pkfields.size()];</span>
<span class="nc bnc" id="L5042" title="All 2 branches missed.">        for (BCMethod method : methods) {</span>
            // constructor must be public
<span class="nc bnc" id="L5044" title="All 2 branches missed.">            if (!method.isPublic()) {</span>
<span class="nc" id="L5045">                continue;</span>
            }
<span class="nc" id="L5047">            Class&lt;?&gt;[] parmTypes = method.getParamTypes();</span>
            // make sure the constructors have the same # of parms as
            // the number of pk fields
<span class="nc bnc" id="L5050" title="All 2 branches missed.">            if (parmTypes.length != pkfields.size()) {</span>
<span class="nc" id="L5051">                continue;</span>
            }

<span class="nc" id="L5054">            int parmOrderIndex = 0;</span>
<span class="nc" id="L5055">            Code code = method.getCode(false);</span>
<span class="nc" id="L5056">            Instruction[] ins = code.getInstructions();</span>
<span class="nc bnc" id="L5057" title="All 2 branches missed.">            for (int i = 0; i &lt; ins.length; i++) {</span>
<span class="nc bnc" id="L5058" title="All 2 branches missed.">                if (ins[i] instanceof PutFieldInstruction) {</span>
<span class="nc" id="L5059">                    PutFieldInstruction pfi = (PutFieldInstruction)ins[i];</span>
<span class="nc bnc" id="L5060" title="All 2 branches missed.">                    for (int j = 0; j &lt; pkfields.size(); j++) {</span>
<span class="nc" id="L5061">                        int fieldNum = pkfields.get(j);</span>
                        // Compare the field being set with the current pk field
<span class="nc" id="L5063">                        String parmName = fmds[fieldNum].getName();</span>
<span class="nc" id="L5064">                        Class&lt;?&gt; parmType = fmds[fieldNum].getType();</span>
<span class="nc bnc" id="L5065" title="All 2 branches missed.">                        if (parmName.equals(pfi.getFieldName())) {</span>
                            // backup and examine the load instruction parm
<span class="nc bnc" id="L5067" title="All 4 branches missed.">                            if (i &gt; 0 &amp;&amp; ins[i-1] instanceof LoadInstruction) {</span>
<span class="nc" id="L5068">                                LoadInstruction li = (LoadInstruction)ins[i-1];</span>
                                // Get the local index from the instruction.  This will be the index
                                // of the constructor parameter.  must be less than or equal to the
                                // max parm index to prevent from picking up locals that could have
                                // been produced within the constructor.  Also make sure the parm type
                                // matches the fmd type
<span class="nc" id="L5074">                                int parm = li.getLocal();</span>
<span class="nc bnc" id="L5075" title="All 4 branches missed.">                                if (parm &lt;= pkfields.size() &amp;&amp; parmTypes[parm-1].equals(parmType)) {</span>
<span class="nc" id="L5076">                                    parmOrder[parmOrderIndex] = fieldNum;</span>
<span class="nc" id="L5077">                                    parmOrderIndex++;</span>
                                }
                            } else {
                                // Some other instruction found. can't make a determination of which local/parm
                                // is being used on the putfield.
                                break;
                            }
                        }
                    }
                }
            }
<span class="nc bnc" id="L5088" title="All 2 branches missed.">            if (parmOrderIndex == pkfields.size()) {</span>
<span class="nc" id="L5089">                return parmOrder;</span>
            }
        }
<span class="nc" id="L5092">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>