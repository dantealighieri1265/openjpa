<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ClassMetaData.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-kernel</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.meta</a> &gt; <span class="el_source">ClassMetaData.java</span></div><h1>ClassMetaData.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.meta;

import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.TreeMap;

import org.apache.openjpa.conf.OpenJPAConfiguration;
import org.apache.openjpa.datacache.CacheDistributionPolicy;
import org.apache.openjpa.datacache.DataCache;
import org.apache.openjpa.enhance.PCRegistry;
import org.apache.openjpa.enhance.PersistenceCapable;
import org.apache.openjpa.enhance.Reflection;
import org.apache.openjpa.lib.conf.Value;
import org.apache.openjpa.lib.conf.ValueListener;
import org.apache.openjpa.lib.log.Log;
import org.apache.openjpa.lib.meta.SourceTracker;
import org.apache.openjpa.lib.util.ClassUtil;
import org.apache.openjpa.lib.util.J2DoPrivHelper;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.lib.util.StringUtil;
import org.apache.openjpa.lib.xml.Commentable;
import org.apache.openjpa.util.BigDecimalId;
import org.apache.openjpa.util.BigIntegerId;
import org.apache.openjpa.util.BooleanId;
import org.apache.openjpa.util.ByteId;
import org.apache.openjpa.util.CharId;
import org.apache.openjpa.util.DateId;
import org.apache.openjpa.util.DoubleId;
import org.apache.openjpa.util.FloatId;
import org.apache.openjpa.util.GeneralException;
import org.apache.openjpa.util.ImplHelper;
import org.apache.openjpa.util.IntId;
import org.apache.openjpa.util.InternalException;
import org.apache.openjpa.util.LongId;
import org.apache.openjpa.util.MetaDataException;
import org.apache.openjpa.util.ObjectId;
import org.apache.openjpa.util.OpenJPAId;
import org.apache.openjpa.util.ShortId;
import org.apache.openjpa.util.StringId;
import org.apache.openjpa.util.UnsupportedException;


/**
 * Contains metadata about a persistent type.
 * This metadata is available both at enhancement time and runtime.
 *  Note that this class employs aggressive caching, and therefore it is
 * important to finalize the configuration of field metadatas before invoking
 * methods that depend on that configuration, such as
 * {@link #getPrimaryKeyFields}.
 *
 * @author Abe White
 */
public class ClassMetaData
    extends Extensions
    implements Comparable&lt;ClassMetaData&gt;, SourceTracker, MetaDataContext,
    MetaDataModes, Commentable, ValueListener {

    private static final long serialVersionUID = 1L;

    /**
     * Unknown identity type.
     */
    public static final int ID_UNKNOWN = 0;

    /**
     * Datastore identity type.
     */
    public static final int ID_DATASTORE = 1;

    /**
     * Application identity type.
     */
    public static final int ID_APPLICATION = 2;

    /**
     * Unknown access type.
     */
<span class="nc" id="L111">    public static final int ACCESS_UNKNOWN = AccessCode.UNKNOWN;</span>

    /**
     * Persistent attributes are accessed via direct field access. Bit flag.
     */
<span class="nc" id="L116">    public static final int ACCESS_FIELD = AccessCode.FIELD;</span>

    /**
     * Persistent attributes are accessed via setters and getters. Bit flag.
     */
<span class="nc" id="L121">    public static final int ACCESS_PROPERTY = AccessCode.PROPERTY;</span>

    /**
     * Persistent class has explicitly defined an access type.
     * This will allow the attributes to use mixed access i.e. some field
     * may use ACCESS_FIELD while others ACCESS_PROPERTY.
     */
<span class="nc" id="L128">    public static final int ACCESS_EXPLICIT = AccessCode.EXPLICIT;</span>

    /**
     * Value for using a synthetic detached state field, which is the default.
     */
    public static final String SYNTHETIC = &quot;`syn&quot;;

    protected static final String DEFAULT_STRING = &quot;`&quot;;

<span class="nc" id="L137">    private static final Localizer _loc = Localizer.forPackage</span>
<span class="nc" id="L138">        (ClassMetaData.class);</span>

<span class="nc" id="L140">    private static final FetchGroup[] EMPTY_FETCH_GROUP_ARRAY</span>
        = new FetchGroup[0];
<span class="nc" id="L142">    private static final String[] EMPTY_STRING_ARRAY = new String[0];</span>

    private MetaDataRepository _repos;
<span class="nc" id="L145">    private transient ClassLoader _loader = null;</span>

    private final ValueMetaData _owner;
<span class="nc" id="L148">    private final LifecycleMetaData _lifeMeta = new LifecycleMetaData(this);</span>
<span class="nc" id="L149">    private File _srcFile = null;</span>
<span class="nc" id="L150">    private String _srcName = null;</span>
<span class="nc" id="L151">    private int _srcType = SRC_OTHER;</span>
<span class="nc" id="L152">    private int _lineNum = 0;</span>
<span class="nc" id="L153">    private int _colNum = 0;</span>
<span class="nc" id="L154">    private String[] _comments = null;</span>
<span class="nc" id="L155">    private int _listIndex = -1;</span>
<span class="nc" id="L156">    private int _srcMode = MODE_META | MODE_MAPPING;</span>
<span class="nc" id="L157">    private int _resMode = MODE_NONE;</span>

<span class="nc" id="L159">    private Class&lt;?&gt; _type = Object.class;</span>
<span class="nc" id="L160">    private int _hashCode = Object.class.getName().hashCode();</span>
<span class="nc" id="L161">    private String _typeString = Object.class.getName();</span>
<span class="nc" id="L162">    private final Map&lt;String,FieldMetaData&gt; _fieldMap = new TreeMap&lt;&gt;();</span>
<span class="nc" id="L163">    private Map&lt;String,FieldMetaData&gt; _supFieldMap = null;</span>
<span class="nc" id="L164">    private boolean _defSupFields = false;</span>
<span class="nc" id="L165">    private Collection&lt;String&gt; _staticFields = null;</span>
<span class="nc" id="L166">    private int[] _fieldDataTable = null;</span>
<span class="nc" id="L167">    private Map&lt;String,FetchGroup&gt; _fgMap = null;</span>

    ////////////////////////////////////////////////////////////////////
    // Note: if you add additional state, make sure to add it to copy()
    ////////////////////////////////////////////////////////////////////

<span class="nc" id="L173">    private Class&lt;?&gt; _objectId = null;</span>
<span class="nc" id="L174">    private Class&lt;?&gt; _idClass = null;</span>
<span class="nc" id="L175">    private Boolean _objectIdShared = null;</span>
<span class="nc" id="L176">    private Boolean _openjpaId = null;</span>
<span class="nc" id="L177">    private Boolean _extent = null;</span>
<span class="nc" id="L178">    private Boolean _embedded = null;</span>
<span class="nc" id="L179">    private boolean _embeddable = false;</span>
<span class="nc" id="L180">    private Boolean _interface = null;</span>
<span class="nc" id="L181">    private Class&lt;?&gt; _impl = null;</span>
<span class="nc" id="L182">    private List&lt;Class&lt;?&gt;&gt; _interfaces = null;</span>
<span class="nc" id="L183">    private final Map&lt;Class&lt;?&gt;,Map&lt;String,String&gt;&gt; _ifaceMap =</span>
    	new HashMap&lt;&gt;();
<span class="nc" id="L185">    private Integer _identity = null;</span>
<span class="nc" id="L186">    private int _idStrategy = ValueStrategies.NONE;</span>
<span class="nc" id="L187">    private int _accessType = AccessCode.UNKNOWN;</span>

<span class="nc" id="L189">    private String _seqName = DEFAULT_STRING;</span>
<span class="nc" id="L190">    private SequenceMetaData _seqMeta = null;</span>
<span class="nc" id="L191">    private String _cacheName = DEFAULT_STRING; // null implies @DataCache(enabled=false)</span>
<span class="nc" id="L192">    private boolean _dataCacheEnabled = false;     // true implies the class has been annotated by the user or name of</span>
                                                // the cache is explicitly set by the user to a null string

<span class="nc" id="L195">    private Boolean _cacheEnabled = null;       // denotes status of JPA 2 @Cacheable annotation</span>
<span class="nc" id="L196">    private int _cacheTimeout = Integer.MIN_VALUE;</span>
<span class="nc" id="L197">    private Boolean _detachable = null;</span>
<span class="nc" id="L198">    private String _detachState = DEFAULT_STRING;</span>
<span class="nc" id="L199">    private String _alias = null;</span>
<span class="nc" id="L200">    private int _versionIdx = Integer.MIN_VALUE;</span>

<span class="nc" id="L202">    private Class&lt;?&gt; _super = null;</span>
<span class="nc" id="L203">    private ClassMetaData _superMeta = null;</span>
<span class="nc" id="L204">    private Class&lt;?&gt;[] _subs = null;</span>
<span class="nc" id="L205">    private ClassMetaData[] _subMetas = null;</span>
<span class="nc" id="L206">    private ClassMetaData[] _mapSubMetas = null;</span>

<span class="nc" id="L208">    private FieldMetaData[] _fields = null;</span>
<span class="nc" id="L209">    private FieldMetaData[] _unmgdFields = null;</span>
<span class="nc" id="L210">    private FieldMetaData[] _allFields = null;</span>
<span class="nc" id="L211">    private FieldMetaData[] _allPKFields = null;</span>
<span class="nc" id="L212">    private FieldMetaData[] _allDFGFields = null;</span>
<span class="nc" id="L213">    private FieldMetaData[] _definedFields = null;</span>
<span class="nc" id="L214">    private FieldMetaData[] _listingFields = null;</span>
<span class="nc" id="L215">    private FieldMetaData[] _allListingFields = null;</span>
<span class="nc" id="L216">    private FieldMetaData[] _allProxyFields = null;</span>
<span class="nc" id="L217">    private FieldMetaData[] _allLrsFields = null;</span>
<span class="nc" id="L218">    private FetchGroup[] _fgs = null;</span>
<span class="nc" id="L219">    private FetchGroup[] _customFGs = null;</span>
<span class="nc" id="L220">    private boolean _intercepting = false;</span>
<span class="nc" id="L221">    private Boolean _useIdClassFromParent = null;</span>
<span class="nc" id="L222">    private boolean _abstract = false;</span>
<span class="nc" id="L223">    private Boolean _hasAbstractPKField = null;</span>
<span class="nc" id="L224">    private Boolean _hasPKFieldsFromAbstractClass = null;</span>
<span class="nc" id="L225">    private int[] _pkAndNonPersistentManagedFmdIndexes = null;</span>
<span class="nc" id="L226">    private Boolean inverseManagedFields = null;</span>
    private List&lt;FieldMetaData&gt; _mappedByIdFields;
<span class="nc" id="L228">    private boolean _mappedByIdFieldsSet = false;</span>
<span class="nc" id="L229">    private boolean _useSchemaElement = true;</span>

    /**
     * Constructor. Supply described type and repository.
     */
<span class="nc" id="L234">    protected ClassMetaData(Class&lt;?&gt; type, MetaDataRepository repos) {</span>
<span class="nc" id="L235">        _repos = repos;</span>
<span class="nc" id="L236">        _owner = null;</span>
<span class="nc" id="L237">        setDescribedType(type);</span>
<span class="nc" id="L238">        registerForValueUpdate(&quot;DataCacheTimeout&quot;);</span>
<span class="nc" id="L239">    }</span>

    /**
     * Embedded constructor. Supply embedding value.
     */
<span class="nc" id="L244">    protected ClassMetaData(ValueMetaData owner) {</span>
<span class="nc" id="L245">        _owner = owner;</span>
<span class="nc" id="L246">        _repos = owner.getRepository();</span>
<span class="nc" id="L247">        setEnvClassLoader(owner.getFieldMetaData().getDefiningMetaData().</span>
<span class="nc" id="L248">            getEnvClassLoader());</span>
<span class="nc" id="L249">        registerForValueUpdate(&quot;DataCacheTimeout&quot;);</span>
<span class="nc" id="L250">    }</span>

    /**
     * Return the owning repository.
     */
    @Override
    public MetaDataRepository getRepository() {
<span class="nc" id="L257">        return _repos;</span>
    }

    /**
     * If this metadata is for an embedded object, returning the owning value.
     */
    public ValueMetaData getEmbeddingMetaData() {
<span class="nc" id="L264">        return _owner;</span>
    }

    /**
     * The persistence capable class described by this metadata.
     */
    public Class&lt;?&gt; getDescribedType() {
<span class="nc" id="L271">        return _type;</span>
    }

    /**
     * The persistence capable stringified class described by this metadata.
     */
    public String getDescribedTypeString(){
<span class="nc" id="L278">        return _typeString;</span>
    }

    /**
     * Set the class described by this metadata. The type may be reset when
     * an embedded value changes its declared type.
     */
    protected void setDescribedType(Class&lt;?&gt; type) {
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (type.getSuperclass() != null &amp;&amp; &quot;java.lang.Enum&quot;.equals</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">            (type.getSuperclass().getName()))</span>
<span class="nc" id="L288">            throw new MetaDataException(_loc.get(&quot;enum&quot;, type));</span>
<span class="nc" id="L289">        _type = type;</span>
<span class="nc" id="L290">        _typeString = _type.getName();</span>
<span class="nc" id="L291">        _hashCode = _typeString.hashCode();</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (PersistenceCapable.class.isAssignableFrom(type))</span>
<span class="nc" id="L293">            setIntercepting(true);</span>
<span class="nc" id="L294">    }</span>

    /**
     * The environmental loader used when loading this metadata.
     * The class metadata should use this loader when loading metadata for
     * its superclass and field types.
     */
    public ClassLoader getEnvClassLoader() {
<span class="nc" id="L302">        return _loader;</span>
    }

    /**
     * The class environmental loader used when loading this metadata.
     * The class metadata should use this loader when loading metadata for
     * its superclass and field types.
     */
    public void setEnvClassLoader(ClassLoader loader) {
<span class="nc" id="L311">        _loader = loader;</span>
<span class="nc" id="L312">    }</span>

    /**
     * The persistence capable superclass of the described type.
     */
    public Class&lt;?&gt; getPCSuperclass() {
<span class="nc" id="L318">        return _super;</span>
    }

    /**
     * The persistence capable superclass of the described type.
     */
    public void setPCSuperclass(Class&lt;?&gt; pc) {
<span class="nc" id="L325">        clearAllFieldCache();</span>
<span class="nc" id="L326">        _super = pc;</span>
<span class="nc" id="L327">    }</span>

    /**
     * The metadata for this class' superclass.
     */
    public ClassMetaData getPCSuperclassMetaData() {
<span class="nc bnc" id="L333" title="All 4 branches missed.">        if (_superMeta == null &amp;&amp; _super != null) {</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            if (_owner != null) {</span>
<span class="nc" id="L335">                _superMeta = _repos.newEmbeddedClassMetaData(_owner);</span>
<span class="nc" id="L336">                _superMeta.setDescribedType(_super);</span>
            } else
<span class="nc" id="L338">                _superMeta = _repos.getMetaData(_super, _loader, true);</span>
        }
<span class="nc" id="L340">        return _superMeta;</span>
    }

    /**
     * The metadata for this class' superclass.
     */
    public void setPCSuperclassMetaData(ClassMetaData meta) {
<span class="nc" id="L347">        clearAllFieldCache();</span>
<span class="nc" id="L348">        _superMeta = meta;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (meta != null)</span>
<span class="nc" id="L350">            setPCSuperclass(meta.getDescribedType());</span>
<span class="nc" id="L351">    }</span>

    /**
     * Whether this class is mapped to the datastore. By default, only
     * returns false if class is embedded-only, but subclasses might override
     * to allow unmapped other types.
     */
    public boolean isMapped() {
<span class="nc bnc" id="L359" title="All 2 branches missed.">        return _embedded != Boolean.TRUE;</span>
    }

    /**
     * Return the closest mapped superclass.
     */
    public ClassMetaData getMappedPCSuperclassMetaData() {
<span class="nc" id="L366">        ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L367" title="All 4 branches missed.">        if (sup == null || sup.isMapped())</span>
<span class="nc" id="L368">            return sup;</span>
<span class="nc" id="L369">        return sup.getMappedPCSuperclassMetaData();</span>
    }

    /**
     * Return the known persistence capable subclasses of the described type,
     * or empty array if none or if this is embedded metadata.
     */
    public Class&lt;?&gt;[] getPCSubclasses() {
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (_owner != null)</span>
<span class="nc" id="L378">            return MetaDataRepository.EMPTY_CLASSES;</span>

<span class="nc" id="L380">        _repos.processRegisteredClasses(_loader);</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (_subs == null) {</span>
<span class="nc" id="L382">            Collection&lt;Class&lt;?&gt;&gt; subs = _repos.getPCSubclasses(_type);</span>
<span class="nc" id="L383">            _subs = subs.toArray(new Class[subs.size()]);</span>
        }
<span class="nc" id="L385">        return _subs;</span>
    }

    /**
     * Return the metadata for the known persistence capable subclasses of
     * the described type, or empty array if none or if this is embedded
     * metadata.
     */
    public ClassMetaData[] getPCSubclassMetaDatas() {
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (_owner != null)</span>
<span class="nc" id="L395">            return _repos.EMPTY_METAS;</span>

<span class="nc" id="L397">        Class&lt;?&gt;[] subs = getPCSubclasses(); // checks for new</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (_subMetas == null) {</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">            if (subs.length == 0)</span>
<span class="nc" id="L400">                _subMetas = _repos.EMPTY_METAS;</span>
            else {
<span class="nc" id="L402">                ClassMetaData[] metas = _repos.newClassMetaDataArray</span>
<span class="nc" id="L403">                    (subs.length);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                for (int i = 0; i &lt; subs.length; i++)</span>
<span class="nc" id="L405">                    metas[i] = _repos.getMetaData(subs[i], _loader, true);</span>
<span class="nc" id="L406">                _subMetas = metas;</span>
            }
        }
<span class="nc" id="L409">        return _subMetas;</span>
    }

    /**
     * Return all mapped subclasses.
     */
    public ClassMetaData[] getMappedPCSubclassMetaDatas() {
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (_owner != null)</span>
<span class="nc" id="L417">            return _repos.EMPTY_METAS;</span>

<span class="nc" id="L419">        ClassMetaData[] subs = getPCSubclassMetaDatas(); // checks for new</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (_mapSubMetas == null) {</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (subs.length == 0)</span>
<span class="nc" id="L422">                _mapSubMetas = subs;</span>
            else {
<span class="nc" id="L424">                List&lt;ClassMetaData&gt; mapped =</span>
                	new ArrayList&lt;&gt;(subs.length);
<span class="nc bnc" id="L426" title="All 2 branches missed.">                for (int i = 0; i &lt; subs.length; i++)</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">                    if (subs[i].isMapped())</span>
<span class="nc" id="L428">                        mapped.add(subs[i]);</span>
<span class="nc" id="L429">                _mapSubMetas = mapped.toArray</span>
<span class="nc" id="L430">                    (_repos.newClassMetaDataArray(mapped.size()));</span>
            }
        }
<span class="nc" id="L433">        return _mapSubMetas;</span>
    }

    /**
     * The type of identity being used. This will be one of:
     * &lt;ul&gt;
     * &lt;li&gt;{@link #ID_UNKNOWN}: unknown identity type&lt;/li&gt;
     * &lt;li&gt;{@link #ID_DATASTORE}: identity managed by the data store and
     * independent	of the fields of the instance&lt;/li&gt;
     * &lt;li&gt;{@link #ID_APPLICATION}: identity managed by the application and
     * defined by one or more fields of the instance&lt;/li&gt;
     * &lt;/ul&gt; If unspecified, defaults to {@link #ID_DATASTORE} if there are no
     * primary key fields, and {@link #ID_APPLICATION} otherwise.
     */
    public int getIdentityType() {
<span class="nc bnc" id="L448" title="All 2 branches missed.">    	if (_identity != null) {</span>
<span class="nc" id="L449">    		return _identity;</span>
    	} else {
<span class="nc" id="L451">    		ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L452" title="All 4 branches missed.">	        if (sup != null &amp;&amp; sup.getIdentityType() != ID_UNKNOWN)</span>
<span class="nc" id="L453">	            _identity = sup.getIdentityType();</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">	        else if (getPrimaryKeyFields().length &gt; 0)</span>
<span class="nc" id="L455">	            _identity = ID_APPLICATION;</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">	        else if (isMapped())</span>
<span class="nc" id="L457">	            _identity = ID_DATASTORE;</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">	        else if (isAbstract())</span>
<span class="nc" id="L459">	        	_identity = ID_UNKNOWN;</span>
	        else
<span class="nc" id="L461">	            _identity = _repos.getMetaDataFactory().getDefaults().</span>
<span class="nc" id="L462">	            	 getDefaultIdentityType();</span>
    	}
<span class="nc" id="L464">        return _identity;</span>
    }

    /**
     * The type of identity being used. This will be one of:
     * &lt;ul&gt;
     * &lt;li&gt;{@link #ID_UNKNOWN}: unknown identity type&lt;/li&gt;
     * &lt;li&gt;{@link #ID_DATASTORE}: identity managed by the data store and
     * independent	of the fields of the instance&lt;/li&gt;
     * &lt;li&gt;{@link #ID_APPLICATION}: identity managed by the application and
     * defined by one or more fields of the instance&lt;/li&gt;
     * &lt;/ul&gt; If unspecified, defaults to {@link #ID_DATASTORE} if there are no
     * primary key fields, and {@link #ID_APPLICATION} otherwise.
     */
    public void setIdentityType(int type) {
<span class="nc" id="L479">        _identity = type;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (type != ID_APPLICATION) {</span>
<span class="nc" id="L481">            _objectId = null;</span>
<span class="nc" id="L482">            _openjpaId = null;</span>
        }
<span class="nc" id="L484">    }</span>

    /**
     * The metadata-specified class to use for the object ID.
     */
    public Class&lt;?&gt; getObjectIdType() {
        // if this entity does not use IdClass from the parent entity,
        // just return the _objectId set during annotation parsing time.
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (!useIdClassFromParent()) {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            if (_objectId != null)</span>
<span class="nc" id="L494">                return _objectId;</span>
        }

        // if this entity uses IdClass from the parent entity,
        // the _objectId set during the parsing time should be
        // ignored, and let the system determine the objectId type
        // of this entity.
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (getIdentityType() != ID_APPLICATION)</span>
<span class="nc" id="L502">            return null;</span>
<span class="nc" id="L503">        ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L504" title="All 4 branches missed.">        if (sup != null &amp;&amp; sup.getIdentityType() != ID_UNKNOWN) {</span>
<span class="nc" id="L505">            _objectId = sup.getObjectIdType();</span>
<span class="nc" id="L506">            return _objectId;</span>
        }

        // figure out OpenJPA identity type based on primary key field
<span class="nc" id="L510">        FieldMetaData[] pks = getPrimaryKeyFields();</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">        if (pks.length != 1)</span>
<span class="nc" id="L512">            return null;</span>
<span class="nc bnc" id="L513" title="All 14 branches missed.">        switch (pks[0].getObjectIdFieldTypeCode()) {</span>
            case JavaTypes.BYTE:
            case JavaTypes.BYTE_OBJ:
<span class="nc" id="L516">                _objectId = ByteId.class;</span>
<span class="nc" id="L517">                break;</span>
            case JavaTypes.CHAR:
            case JavaTypes.CHAR_OBJ:
<span class="nc" id="L520">                _objectId = CharId.class;</span>
<span class="nc" id="L521">                break;</span>
            case JavaTypes.DOUBLE:
            case JavaTypes.DOUBLE_OBJ:
<span class="nc" id="L524">                _objectId = DoubleId.class;</span>
<span class="nc" id="L525">                break;</span>
            case JavaTypes.FLOAT:
            case JavaTypes.FLOAT_OBJ:
<span class="nc" id="L528">                _objectId = FloatId.class;</span>
<span class="nc" id="L529">                break;</span>
            case JavaTypes.INT:
            case JavaTypes.INT_OBJ:
<span class="nc" id="L532">                _objectId = IntId.class;</span>
<span class="nc" id="L533">                break;</span>
            case JavaTypes.LONG:
            case JavaTypes.LONG_OBJ:
<span class="nc" id="L536">                _objectId = LongId.class;</span>
<span class="nc" id="L537">                break;</span>
            case JavaTypes.SHORT:
            case JavaTypes.SHORT_OBJ:
<span class="nc" id="L540">                _objectId = ShortId.class;</span>
<span class="nc" id="L541">                break;</span>
            case JavaTypes.STRING:
<span class="nc" id="L543">                _objectId = StringId.class;</span>
<span class="nc" id="L544">                break;</span>
            case JavaTypes.DATE:
<span class="nc" id="L546">                _objectId = DateId.class;</span>
<span class="nc" id="L547">                break;</span>
            case JavaTypes.OID:
            case JavaTypes.OBJECT:
<span class="nc" id="L550">                _objectId = ObjectId.class;</span>
<span class="nc" id="L551">                break;</span>
            case JavaTypes.BIGDECIMAL:
<span class="nc" id="L553">                _objectId = BigDecimalId.class;</span>
<span class="nc" id="L554">                break;</span>
            case JavaTypes.BIGINTEGER:
<span class="nc" id="L556">                _objectId = BigIntegerId.class;</span>
<span class="nc" id="L557">                break;</span>
            case JavaTypes.BOOLEAN:
            case JavaTypes.BOOLEAN_OBJ:
<span class="nc" id="L560">                _objectId = BooleanId.class;</span>
                break;
        }
<span class="nc" id="L563">        return _objectId;</span>
    }

    /**
     * The metadata-specified class to use for the object ID.
     * When there is IdClass annotation, AnnotationMetaDataParser
     * will call this method to set ObjectId type. However, if
     * this is a derived identity in the child entity where a
     * relation field (parent entity) is used as an id, and this
     * relation field has an IdClass, the IdClass annotation in
     * the child entity can be ignored as Openjpa will automatically
     * wrap parent's IdClass as child's IdClass.
     */
    public void setObjectIdType(Class&lt;?&gt; cls, boolean shared) {
<span class="nc" id="L577">        _objectId = null;</span>
<span class="nc" id="L578">        _openjpaId = null;</span>
<span class="nc" id="L579">        _objectIdShared = null;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (cls != null) {</span>
            // don't let people assign OpenJPAId types; safer to calculate it
            // ourselves
<span class="nc" id="L583">            setIdentityType(ID_APPLICATION);</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">            if (!OpenJPAId.class.isAssignableFrom(cls)) {</span>
<span class="nc" id="L585">                _objectId = cls;</span>
<span class="nc" id="L586">                _idClass = cls;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">                _objectIdShared = (shared) ? Boolean.TRUE : Boolean.FALSE;</span>
            }
        }
<span class="nc" id="L590">    }</span>

    /**
     * Whether this type uses an application identity class that is shared
     * with other classes, and is therefore wrapped in an {@link ObjectId}.
     */
    public boolean isObjectIdTypeShared() {
<span class="nc bnc" id="L597" title="All 2 branches missed.">        if (_objectIdShared != null)</span>
<span class="nc" id="L598">            return _objectIdShared.booleanValue();</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (_super != null)</span>
<span class="nc" id="L600">            return getPCSuperclassMetaData().isObjectIdTypeShared();</span>
<span class="nc" id="L601">        return isOpenJPAIdentity();</span>
    }

    /**
     * Whether this type uses OpenJPA identity.
     */
    public boolean isOpenJPAIdentity() {
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (_openjpaId == null) {</span>
<span class="nc" id="L609">            Class&lt;?&gt; cls = getObjectIdType();</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">            if (cls == null)</span>
<span class="nc" id="L611">                return false;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">            _openjpaId = (OpenJPAId.class.isAssignableFrom(cls)) ? Boolean.TRUE</span>
<span class="nc" id="L613">                : Boolean.FALSE;</span>
        }
<span class="nc" id="L615">        return _openjpaId.booleanValue();</span>
    }

    /**
     * The strategy to use for datastore identity generation.
     * One of the constants from {@link ValueStrategies}.
     */
    public int getIdentityStrategy() {
<span class="nc bnc" id="L623" title="All 4 branches missed.">        if (getIdentityType() == ID_DATASTORE</span>
            &amp;&amp; _idStrategy == ValueStrategies.NONE) {
<span class="nc" id="L625">            ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L626" title="All 4 branches missed.">            if (sup != null &amp;&amp; sup.getIdentityType() != ID_UNKNOWN)</span>
<span class="nc" id="L627">                _idStrategy = sup.getIdentityStrategy();</span>
            else
<span class="nc" id="L629">                _idStrategy = ValueStrategies.NATIVE;</span>
        }
<span class="nc" id="L631">        return _idStrategy;</span>
    }

    /**
     * The strategy to use for datastore identity generation.
     * One of the constants from {@link ValueStrategies}.
     */
    public void setIdentityStrategy(int strategy) {
<span class="nc" id="L639">        _idStrategy = strategy;</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (strategy != ValueStrategies.SEQUENCE)</span>
<span class="nc" id="L641">            setIdentitySequenceName(null);</span>
<span class="nc" id="L642">    }</span>

    /**
     * The datastore identity sequence name, or null for none.
     */
    public String getIdentitySequenceName() {
<span class="nc bnc" id="L648" title="All 2 branches missed.">        if (DEFAULT_STRING.equals(_seqName)) {</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (_super != null)</span>
<span class="nc" id="L650">                _seqName = getPCSuperclassMetaData().getIdentitySequenceName();</span>
            else
<span class="nc" id="L652">                _seqName = null;</span>
        }
<span class="nc" id="L654">        return _seqName;</span>
    }

    /**
     * The datastore identity sequence name, or null for none.
     */
    public void setIdentitySequenceName(String seqName) {
<span class="nc" id="L661">        _seqName = seqName;</span>
<span class="nc" id="L662">        _seqMeta = null;</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">        if (seqName != null)</span>
<span class="nc" id="L664">            setIdentityStrategy(ValueStrategies.SEQUENCE);</span>
<span class="nc" id="L665">    }</span>

    /**
     * Metadata for the datastore identity sequence.
     */
    public SequenceMetaData getIdentitySequenceMetaData() {
<span class="nc bnc" id="L671" title="All 4 branches missed.">        if (_seqMeta == null &amp;&amp; getIdentitySequenceName() != null)</span>
<span class="nc" id="L672">            _seqMeta = _repos.getSequenceMetaData(this,</span>
<span class="nc" id="L673">                getIdentitySequenceName(), true);</span>
<span class="nc" id="L674">        return _seqMeta;</span>
    }

    /**
     * Information about lifecycle callbacks for this class.
     */
    public LifecycleMetaData getLifecycleMetaData() {
<span class="nc" id="L681">        return _lifeMeta;</span>
    }

    /**
     * Returns the alias for the described type, or &lt;code&gt;null&lt;/code&gt; if none
     * has been set.
     *
     * @see #setTypeAlias
     */
    public String getTypeAlias() {
<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (_alias == null)</span>
<span class="nc" id="L692">            _alias = ClassUtil.getClassName(_type);</span>
<span class="nc" id="L693">        return _alias;</span>
    }

    /**
     * Sets the alias for the described type. The alias can be
     * any arbitrary string that the implementation can later use to
     * refer to the class. Note that at runtime, only the alias
     * computed when the persistent type was enhanced is used.
     *
     * @param alias the alias name to apply to the described type
     */
    public void setTypeAlias(String alias) {
<span class="nc" id="L705">        _alias = alias;</span>
<span class="nc" id="L706">    }</span>

    /**
     * The access type used by this class.
     *
     */
    public int getAccessType() {
<span class="nc" id="L713">        return _accessType;</span>
    }

    /**
     * Sets the access type.
     */
    public void setAccessType(int type) {
<span class="nc bnc" id="L720" title="All 4 branches missed.">    	if (type == _accessType || type == AccessCode.UNKNOWN)</span>
<span class="nc" id="L721">    		return;</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">    	if (!AccessCode.isValidClassCode(type)) {</span>
<span class="nc" id="L723">            throw new IllegalArgumentException(_loc.get(&quot;access-type-invalid&quot;,</span>
<span class="nc" id="L724">    		    this, AccessCode.toClassString(type)).getMessage());</span>
    	}
<span class="nc bnc" id="L726" title="All 2 branches missed.">    	if (_accessType != AccessCode.UNKNOWN) { // changing access type</span>
<span class="nc" id="L727">    	    _repos.getLog().trace(_loc.get(&quot;access-type-change&quot;,</span>
<span class="nc" id="L728">    		    this, AccessCode.toClassString(type),</span>
<span class="nc" id="L729">    		    AccessCode.toClassString(_accessType)).getMessage());</span>
    	}
<span class="nc" id="L731">        _accessType = type;</span>
<span class="nc" id="L732">    }</span>

    /**
     * Asserts the the given field (which must belong to this receiver)
     * can be set to the given access code. If the field code is allowed,
     * it may have the side-effect of changing the access code of this receiver.
     */
    void mergeFieldAccess(FieldMetaData fmd, int fCode) {
<span class="nc" id="L740">    	setAccessType(AccessCode.mergeFieldCode(this, fmd, fCode));</span>
<span class="nc" id="L741">    }</span>

    /**
     * Affirms if access style is explicitly defined.
     */
    public boolean isExplicitAccess() {
<span class="nc" id="L747">        return AccessCode.isExplicit(_accessType);</span>
    }

    /**
     * Affirms if attributes of this class use mixed access types.
     */
    public boolean isMixedAccess() {
<span class="nc" id="L754">    	return AccessCode.isMixed(_accessType);</span>
    }

    /**
     * Whether the type requires extent management.
     */
    public boolean getRequiresExtent() {
<span class="nc bnc" id="L761" title="All 4 branches missed.">        if (_owner != null || isEmbeddedOnly())</span>
<span class="nc" id="L762">            return false;</span>

<span class="nc bnc" id="L764" title="All 2 branches missed.">        if (_extent == null) {</span>
<span class="nc" id="L765">            ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">            if (sup != null)</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">                _extent = (sup.getRequiresExtent()) ? Boolean.TRUE</span>
<span class="nc" id="L768">                    : Boolean.FALSE;</span>
            else
<span class="nc" id="L770">                _extent = Boolean.TRUE;</span>
        }
<span class="nc" id="L772">        return _extent.booleanValue();</span>
    }

    /**
     * Whether the type requires extent management.
     */
    public void setRequiresExtent(boolean req) {
<span class="nc bnc" id="L779" title="All 2 branches missed.">        _extent = (req) ? Boolean.TRUE : Boolean.FALSE;</span>
<span class="nc" id="L780">    }</span>

    /**
     * Whether the type can only be used as an embedded object.
     */
    public boolean isEmbeddedOnly() {
<span class="nc bnc" id="L786" title="All 2 branches missed.">        if (_embedded == null) {</span>
<span class="nc" id="L787">            ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">            if (sup != null)</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">                _embedded = (sup.isEmbeddedOnly()) ? Boolean.TRUE</span>
<span class="nc" id="L790">                    : Boolean.FALSE;</span>
            else
<span class="nc" id="L792">                _embedded = Boolean.FALSE;</span>
        }
<span class="nc" id="L794">        return _embedded.booleanValue();</span>
    }

    /**
     * Whether the type can only be used as an embedded object.
     */
    public void setEmbeddedOnly(boolean embed) {
<span class="nc bnc" id="L801" title="All 2 branches missed.">        _embedded = (embed) ? Boolean.TRUE : Boolean.FALSE;</span>
<span class="nc" id="L802">    }</span>

    public boolean isEmbeddable() {
<span class="nc" id="L805">        return _embeddable;</span>
    }

    public void setEmbeddable() {
<span class="nc" id="L809">        _embeddable = true;</span>
<span class="nc" id="L810">    }</span>

    /**
     * Whether the type's fields are actively intercepted, either by
     * redefinition or enhancement.
     */
    public boolean isIntercepting() {
<span class="nc" id="L817">        return _intercepting;</span>
    }

    /**
     * Whether the type's fields are actively intercepted, either by
     * redefinition or enhancement.
     */
    public void setIntercepting(boolean intercepting) {
<span class="nc" id="L825">        _intercepting = intercepting;</span>
<span class="nc" id="L826">    }</span>

    /**
     * Whether the type is a managed interface.
     */
    public boolean isManagedInterface() {
<span class="nc bnc" id="L832" title="All 2 branches missed.">        if (!_type.isInterface())</span>
<span class="nc" id="L833">            return false;</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">        return _interface == null ? false : _interface.booleanValue();</span>
    }

    /**
     * Whether the type is a managed interface
     */
    public void setManagedInterface(boolean managedInterface) {
<span class="nc bnc" id="L841" title="All 2 branches missed.">        if (!_type.isInterface())</span>
<span class="nc" id="L842">            throw new MetaDataException(_loc.get(&quot;not-interface&quot;, _type));</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">        _interface = managedInterface ? Boolean.TRUE : Boolean.FALSE;</span>

        // managed interfaces always do proper interception; OpenJPA generates
        // the implementations.
<span class="nc bnc" id="L847" title="All 2 branches missed.">        if (isManagedInterface())</span>
<span class="nc" id="L848">            setIntercepting(true);</span>

        // managed interfaces always use property access.
<span class="nc" id="L851">        setAccessType(AccessCode.PROPERTY);</span>
<span class="nc" id="L852">    }</span>

    /**
     * Return the managed interface implementor if any.
     */
    public Class&lt;?&gt; getInterfaceImpl() {
<span class="nc" id="L858">        return _impl;</span>
    }

    /**
     * Set the managed interface implementor class.
     */
    public void setInterfaceImpl(Class&lt;?&gt; impl) {
<span class="nc" id="L865">        _impl = impl;</span>
<span class="nc" id="L866">    }</span>

    /**
     * Return all explicitly declared interfaces this class implements.
     */
    public Class&lt;?&gt;[] getDeclaredInterfaces() {
<span class="nc bnc" id="L872" title="All 2 branches missed.">        if (_interfaces == null)</span>
<span class="nc" id="L873">            return MetaDataRepository.EMPTY_CLASSES;</span>
<span class="nc" id="L874">        return _interfaces.toArray(new Class[_interfaces.size()]);</span>
    }

    /**
     * Explicitly declare the given interface among the ones this
     * class implements.
     */
    public void addDeclaredInterface(Class&lt;?&gt; iface) {
<span class="nc bnc" id="L882" title="All 4 branches missed.">        if (iface == null || !iface.isInterface())</span>
<span class="nc" id="L883">            throw new MetaDataException(_loc.get(&quot;declare-non-interface&quot;,</span>
                this, iface));
<span class="nc bnc" id="L885" title="All 2 branches missed.">        if (_interfaces == null)</span>
<span class="nc" id="L886">            _interfaces = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L887">        _interfaces.add(iface);</span>
<span class="nc" id="L888">    }</span>

    /**
     * Remove the given interface from the declared list.
     */
    public boolean removeDeclaredInterface(Class&lt;?&gt; iface) {
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (_interfaces == null)</span>
<span class="nc" id="L895">            return false;</span>
<span class="nc" id="L896">        return _interfaces.remove(iface);</span>
    }

    /**
     * Alias properties from the given interface during  queries to
     * the local field.
     */
    public void setInterfacePropertyAlias(Class&lt;?&gt; iface, String orig,
        String local) {
<span class="nc" id="L905">        synchronized (_ifaceMap) {</span>
<span class="nc" id="L906">            Map&lt;String,String&gt; fields = _ifaceMap.get(iface);</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">            if (fields == null) {</span>
<span class="nc" id="L908">                fields = new HashMap&lt;&gt;();</span>
<span class="nc" id="L909">                _ifaceMap.put(iface, fields);</span>
            }
<span class="nc bnc" id="L911" title="All 2 branches missed.">            if (fields.containsKey(orig))</span>
<span class="nc" id="L912">                throw new MetaDataException(_loc.get(&quot;duplicate-iface-alias&quot;,</span>
                    this, orig, local));
<span class="nc" id="L914">            fields.put(orig, local);</span>
<span class="nc" id="L915">        }</span>
<span class="nc" id="L916">    }</span>

    /**
     * Get local field alias for the given interface property.
     */
    public String getInterfacePropertyAlias(Class&lt;?&gt; iface, String orig) {
<span class="nc" id="L922">        synchronized (_ifaceMap) {</span>
<span class="nc" id="L923">            Map&lt;String,String&gt; fields = _ifaceMap.get(iface);</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">            if (fields == null)</span>
<span class="nc" id="L925">                return null;</span>
<span class="nc" id="L926">            return fields.get(orig);</span>
        }
    }

    /**
     * Return all aliases property named for the given interface.
     */
    public String[] getInterfaceAliasedProperties(Class&lt;?&gt; iface) {
<span class="nc" id="L934">        synchronized (_ifaceMap) {</span>
<span class="nc" id="L935">            Map&lt;String,String&gt; fields = _ifaceMap.get(iface);</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">            if (fields == null)</span>
<span class="nc" id="L937">                return EMPTY_STRING_ARRAY;</span>
<span class="nc" id="L938">            return fields.keySet().toArray(new String[fields.size()]);</span>
        }
    }

    /**
     * Return the number of fields that use impl or intermediate data, in
     * order to create a compacted array for storage of said data.
     */
    public int getExtraFieldDataLength() {
<span class="nc" id="L947">        int[] table = getExtraFieldDataTable();</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">        for (int i = table.length - 1; i &gt;= 0; i--)</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">            if (table[i] != -1)</span>
<span class="nc" id="L950">                return table[i] + 1;</span>
<span class="nc" id="L951">        return 0;</span>
    }

    /**
     * Return the intermediate field data index of the given field
     * in the compacted array, or -1 if the field does not use extra data.
     *
     * @see #getExtraFieldDataLength
     */
    public int getExtraFieldDataIndex(int field) {
<span class="nc" id="L961">        int[] array = getExtraFieldDataTable();</span>
<span class="nc bnc" id="L962" title="All 4 branches missed.">        if (field &lt; 0 || field &gt;= array.length)</span>
<span class="nc" id="L963">            return -1;</span>
<span class="nc" id="L964">        return array[field];</span>
    }

    /**
     * Creates a table mapping each field index to its extra data index.
     */
    private int[] getExtraFieldDataTable() {
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (_fieldDataTable == null) {</span>
<span class="nc" id="L972">            FieldMetaData[] fmds = getFields();</span>
<span class="nc" id="L973">            int[] table = new int[fmds.length];</span>
<span class="nc" id="L974">            int idx = 0;</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">            for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">                if (fmds[i].usesIntermediate()</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">                    || fmds[i].usesImplData() != Boolean.FALSE)</span>
<span class="nc" id="L978">                    table[i] = idx++;</span>
                else
<span class="nc" id="L980">                    table[i] = -1;</span>
            }
<span class="nc" id="L982">            _fieldDataTable = table;</span>
        }
<span class="nc" id="L984">        return _fieldDataTable;</span>
    }

    /**
     * Return whether the given name represents a managed or static field of
     * this class, including superclass fields.
     */
    public boolean isAccessibleField(String field) {
<span class="nc bnc" id="L992" title="All 2 branches missed.">        if (getDeclaredField(field) != null)</span>
<span class="nc" id="L993">            return true;</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">        if (_staticFields == null) {</span>
<span class="nc" id="L995">            Field[] fields = AccessController.doPrivileged(</span>
<span class="nc" id="L996">                J2DoPrivHelper.getDeclaredFieldsAction(_type));</span>
<span class="nc" id="L997">            Set&lt;String&gt; names = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">            for (int i = 0; i &lt; fields.length; i++)</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">                if (Modifier.isStatic(fields[i].getModifiers()))</span>
<span class="nc" id="L1000">                    names.add(fields[i].getName());</span>
<span class="nc" id="L1001">            _staticFields = names;</span>
        }
<span class="nc bnc" id="L1003" title="All 2 branches missed.">        if (_staticFields.contains(field))</span>
<span class="nc" id="L1004">            return true;</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">        if (_super != null)</span>
<span class="nc" id="L1006">            return getPCSuperclassMetaData().isAccessibleField(field);</span>
<span class="nc" id="L1007">        return false;</span>
    }

    /**
     * Return all fields that are types that need to be wrappered by a proxy.
     * The types that need to be proxied are:
     * &lt;p&gt;
     *  &lt;li&gt;org.apache.openjpa.meta.JavaTypes.CALENDAR
     *  &lt;li&gt;org.apache.openjpa.meta.JavaTypes.COLLECTION
     *  &lt;li&gt;org.apache.openjpa.meta.JavaTypes.DATE
     *  &lt;li&gt;org.apache.openjpa.meta.JavaTypes.MAP
     *  &lt;li&gt;org.apache.openjpa.meta.JavaTypes.OBJECT
     */
    public FieldMetaData[] getProxyFields() {
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if (_allProxyFields == null) {</span>
            // Make sure _allFields has been initialized
<span class="nc bnc" id="L1023" title="All 2 branches missed.">            if (_allFields == null) {</span>
<span class="nc" id="L1024">                getFields();</span>
            }
<span class="nc" id="L1026">            List&lt;FieldMetaData&gt; res = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">            for (FieldMetaData fmd : _allFields) {</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">                switch (fmd.getDeclaredTypeCode()) {</span>
                    case JavaTypes.CALENDAR:
                    case JavaTypes.COLLECTION:
                    case JavaTypes.DATE:
                    case JavaTypes.MAP:
                    case JavaTypes.OBJECT:
<span class="nc" id="L1034">                        res.add(fmd);</span>
                        break;
                }
            }
<span class="nc" id="L1038">            _allProxyFields = res.toArray(new FieldMetaData[res.size()]);</span>
        }
<span class="nc" id="L1040">        return _allProxyFields;</span>
    }

    /**
     * Return all large result set fields. Will never return null.
     */
    public FieldMetaData[] getLrsFields() {
<span class="nc bnc" id="L1047" title="All 2 branches missed.">        if (_allLrsFields == null) {</span>
            // Make sure _allFields has been initialized
<span class="nc bnc" id="L1049" title="All 2 branches missed.">            if (_allFields == null) {</span>
<span class="nc" id="L1050">                getFields();</span>
            }
<span class="nc" id="L1052">            List&lt;FieldMetaData&gt; res = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">            for (FieldMetaData fmd : _allFields) {</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">                if(fmd.isLRS()==true){</span>
<span class="nc" id="L1055">                    res.add(fmd);</span>
                }
            }
<span class="nc" id="L1058">            _allLrsFields = res.toArray(new FieldMetaData[res.size()]);</span>
        }
<span class="nc" id="L1060">        return _allLrsFields;</span>
    }

    /**
     * Return all field metadata, including superclass fields.
     */
    public FieldMetaData[] getFields() {
<span class="nc bnc" id="L1067" title="All 2 branches missed.">        if (_allFields == null) {</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">            if (_super == null)</span>
<span class="nc" id="L1069">                _allFields = getDeclaredFields();</span>
            else {
<span class="nc" id="L1071">                FieldMetaData[] fields = getDeclaredFields();</span>
<span class="nc" id="L1072">                FieldMetaData[] supFields = getPCSuperclassMetaData().</span>
<span class="nc" id="L1073">                    getFields();</span>

<span class="nc" id="L1075">                FieldMetaData[] allFields = _repos.newFieldMetaDataArray</span>
<span class="nc" id="L1076">                    (fields.length + supFields.length);</span>
<span class="nc" id="L1077">                System.arraycopy(supFields, 0, allFields, 0, supFields.length);</span>
<span class="nc" id="L1078">                replaceDefinedSuperclassFields(allFields, supFields.length);</span>

<span class="nc bnc" id="L1080" title="All 2 branches missed.">                for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc" id="L1081">                    fields[i].setIndex(supFields.length + i);</span>
<span class="nc" id="L1082">                    allFields[supFields.length + i] = fields[i];</span>
                }
<span class="nc" id="L1084">                _allFields = allFields;</span>
            }
        }
<span class="nc" id="L1087">        return _allFields;</span>
    }

    /**
     * Replace superclass fields that we define with our version.
     */
    private void replaceDefinedSuperclassFields(FieldMetaData[] fields,
        int len) {
<span class="nc bnc" id="L1095" title="All 4 branches missed.">        if (_supFieldMap == null || !_defSupFields)</span>
<span class="nc" id="L1096">            return;</span>

        // don't assume fields are in order; this method is used for
        // listing order as well
        FieldMetaData supField;
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L1102">            supField = _supFieldMap.get(fields[i].getName());</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">            if (supField != null) {</span>
<span class="nc" id="L1104">                fields[i] = supField;</span>
<span class="nc" id="L1105">                supField.setIndex(i);</span>
            }
        }
<span class="nc" id="L1108">    }</span>

    /**
     * Return the superclass copy of the given field.
     */
    protected FieldMetaData getSuperclassField(FieldMetaData supField) {
<span class="nc" id="L1114">        ClassMetaData sm = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">        FieldMetaData fmd = sm == null ? null : sm.getField(supField.getName());</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">        if (fmd == null</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">        || fmd.getManagement() != FieldMetaData.MANAGE_PERSISTENT)</span>
<span class="nc" id="L1118">            throw new MetaDataException(_loc.get(&quot;unmanaged-sup-field&quot;,</span>
                supField, this));
<span class="nc" id="L1120">        return fmd;</span>
    }

    /**
     * Return only the fields for this class, without superclass fields.
     */
    public FieldMetaData[] getDeclaredFields() {
<span class="nc bnc" id="L1127" title="All 2 branches missed.">        if (_fields == null) {</span>
<span class="nc" id="L1128">            List&lt;FieldMetaData&gt; fields =</span>
<span class="nc" id="L1129">            	new ArrayList&lt;&gt;(_fieldMap.size());</span>
            ;
<span class="nc bnc" id="L1131" title="All 2 branches missed.">            for (FieldMetaData fmd : _fieldMap.values()) {</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">                if (fmd.getManagement() != FieldMetaData.MANAGE_NONE) {</span>
<span class="nc" id="L1133">                    fmd.setDeclaredIndex(fields.size());</span>
<span class="nc" id="L1134">                    fmd.setIndex(fmd.getDeclaredIndex());</span>
<span class="nc" id="L1135">                    fields.add(fmd);</span>
                }
<span class="nc" id="L1137">            }</span>
<span class="nc" id="L1138">            _fields = fields.toArray</span>
<span class="nc" id="L1139">            	(_repos.newFieldMetaDataArray(fields.size()));</span>
        }
<span class="nc" id="L1141">        return _fields;</span>
    }

    /**
     * Return primary key fields, or empty array if none. The order
     * in which the keys are returned will be the order in which
     * the fields are declared, starting at the least-derived superclass
     * and ending with the primary key fields of the most-derived subclass.
     */
    public FieldMetaData[] getPrimaryKeyFields() {
        // check for primary key fields even if not set to ID_APPLICATION so
        // that Application Id tool sees them even when user doesn't declare
    	// Application identity
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        if (_allPKFields == null) {</span>
<span class="nc" id="L1155">            FieldMetaData[] fields = getFields();</span>
<span class="nc" id="L1156">            int num = 0;</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">            for (int i = 0; i &lt; fields.length; i++)</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">                if (fields[i].isPrimaryKey())</span>
<span class="nc" id="L1159">                    num++;</span>

<span class="nc bnc" id="L1161" title="All 2 branches missed.">            if (num == 0)</span>
<span class="nc" id="L1162">                _allPKFields = _repos.EMPTY_FIELDS;</span>
            else {
<span class="nc" id="L1164">                FieldMetaData[] pks = _repos.newFieldMetaDataArray(num);</span>
<span class="nc" id="L1165">                num = 0;</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">                    if (fields[i].isPrimaryKey()) {</span>
<span class="nc" id="L1168">                        fields[i].setPrimaryKeyIndex(num);</span>
<span class="nc" id="L1169">                        pks[num] = fields[i];</span>
<span class="nc" id="L1170">                        num++;</span>
                    }
                }
<span class="nc" id="L1173">                _allPKFields = pks;</span>
            }
        }
<span class="nc" id="L1176">        return _allPKFields;</span>
    }

    /**
     * Return the list of fields in the default fetch group,
     * including superclass fields, or an empty array if none.
     */
    public FieldMetaData[] getDefaultFetchGroupFields() {
<span class="nc bnc" id="L1184" title="All 2 branches missed.">        if (_allDFGFields == null) {</span>
<span class="nc" id="L1185">            FieldMetaData[] fields = getFields();</span>
<span class="nc" id="L1186">            int num = 0;</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            for (int i = 0; i &lt; fields.length; i++)</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">                if (fields[i].isInDefaultFetchGroup())</span>
<span class="nc" id="L1189">                    num++;</span>

<span class="nc" id="L1191">            FieldMetaData[] dfgs = _repos.newFieldMetaDataArray(num);</span>
<span class="nc" id="L1192">            num = 0;</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">            for (int i = 0; i &lt; fields.length; i++)</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">                if (fields[i].isInDefaultFetchGroup())</span>
<span class="nc" id="L1195">                    dfgs[num++] = fields[i];</span>
<span class="nc" id="L1196">            _allDFGFields = dfgs;</span>
        }
<span class="nc" id="L1198">        return _allDFGFields;</span>
    }

    /**
     * Return the version field for this class, if any.
     */
    public FieldMetaData getVersionField() {
<span class="nc bnc" id="L1205" title="All 2 branches missed.">        if (_allFields == null) {</span>
<span class="nc" id="L1206">            getFields();</span>
        }
<span class="nc bnc" id="L1208" title="All 2 branches missed.">        if (_versionIdx == Integer.MIN_VALUE) {</span>
<span class="nc" id="L1209">            int idx = -1;</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">            for (int i = 0; i &lt; _allFields.length; i++) {</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">                if (_allFields[i].isVersion()) {</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">                    if (idx != -1)</span>
<span class="nc" id="L1213">                        throw new MetaDataException(_loc.get(&quot;mult-vers-fields&quot;, this, _allFields[idx], _allFields[i]));</span>
<span class="nc" id="L1214">                    idx = i;</span>
                }
            }
<span class="nc" id="L1217">            _versionIdx = idx;</span>
        }
<span class="nc bnc" id="L1219" title="All 2 branches missed.">        if (_versionIdx == -1)</span>
<span class="nc" id="L1220">            return null;</span>

<span class="nc" id="L1222">        return _allFields[_versionIdx];</span>
    }

    /**
     * Return the metadata for the persistent or transactional field with
     * the given absolute index.
     *
     * @return the field's metadata, or null if not found
     */
    public FieldMetaData getField(int index) {
<span class="nc bnc" id="L1232" title="All 2 branches missed.">        if(_allFields == null){</span>
<span class="nc" id="L1233">            getFields();</span>
        }
<span class="nc bnc" id="L1235" title="All 4 branches missed.">        if (index &lt; 0 || index &gt;= _allFields.length)</span>
<span class="nc" id="L1236">            return null;</span>
<span class="nc" id="L1237">        return _allFields[index];</span>
    }

    /**
     * Return the metadata for the persistent or transactional field with
     * the given relative index.
     *
     * @return the field's metadata, or null if not found
     */
    public FieldMetaData getDeclaredField(int index) {
<span class="nc" id="L1247">        FieldMetaData[] fields = getDeclaredFields();</span>
<span class="nc bnc" id="L1248" title="All 4 branches missed.">        if (index &lt; 0 || index &gt;= fields.length)</span>
<span class="nc" id="L1249">            return null;</span>
<span class="nc" id="L1250">        return fields[index];</span>
    }

    /**
     * Return the metadata for the persistent or transactional field with
     * the given name.
     *
     * @return the field's metadata, or null if not found
     */
    public FieldMetaData getField(String name) {
<span class="nc" id="L1260">        FieldMetaData fmd = getDeclaredField(name);</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">        if (fmd != null)</span>
<span class="nc" id="L1262">            return fmd;</span>
<span class="nc bnc" id="L1263" title="All 4 branches missed.">        if (_supFieldMap != null &amp;&amp; _defSupFields) {</span>
<span class="nc" id="L1264">            fmd = _supFieldMap.get(name);</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">            if (fmd != null)</span>
<span class="nc" id="L1266">                return fmd;</span>
        }
<span class="nc bnc" id="L1268" title="All 2 branches missed.">        if (_super != null)</span>
<span class="nc" id="L1269">            return getPCSuperclassMetaData().getField(name);</span>
<span class="nc" id="L1270">        return null;</span>
    }

    /**
     * Return the metadata for the persistent or transactional field with
     * the given name, without including superclass fields.
     *
     * @return the field's metadata, or null if not found
     */
    public FieldMetaData getDeclaredField(String name) {
<span class="nc" id="L1280">        FieldMetaData field = _fieldMap.get(name);</span>
<span class="nc bnc" id="L1281" title="All 4 branches missed.">        if (field == null || field.getManagement() == FieldMetaData.MANAGE_NONE)</span>
<span class="nc" id="L1282">            return null;</span>
<span class="nc" id="L1283">        return field;</span>
    }

    /**
     * Return any fields that were added as non-managed.
     * All other methods to get fields return only those that are managed.
     */
    public FieldMetaData[] getDeclaredUnmanagedFields() {
<span class="nc bnc" id="L1291" title="All 2 branches missed.">        if (_unmgdFields == null) {</span>
<span class="nc" id="L1292">            List&lt;FieldMetaData&gt; unmanaged = new ArrayList&lt;&gt;(3);</span>
            ;
<span class="nc bnc" id="L1294" title="All 2 branches missed.">            for (FieldMetaData field : _fieldMap.values()) {</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">                if (field.getManagement() == FieldMetaData.MANAGE_NONE)</span>
<span class="nc" id="L1296">                    unmanaged.add(field);</span>
<span class="nc" id="L1297">            }</span>
<span class="nc" id="L1298">            _unmgdFields = unmanaged.toArray</span>
<span class="nc" id="L1299">                (_repos.newFieldMetaDataArray(unmanaged.size()));</span>
        }
<span class="nc" id="L1301">        return _unmgdFields;</span>
    }

    /**
     * Add a new field metadata to this class.
     */
    public FieldMetaData addDeclaredField(String name, Class&lt;?&gt; type) {
<span class="nc" id="L1308">        FieldMetaData fmd = _repos.newFieldMetaData(name, type, this);</span>
<span class="nc" id="L1309">        clearFieldCache();</span>
<span class="nc" id="L1310">        _fieldMap.put(name, fmd);</span>

<span class="nc" id="L1312">        return fmd;</span>
    }

    /**
     * Remove the given field from management.
     *
     * @return true if the field was removed, false otherwise
     */
    public boolean removeDeclaredField(FieldMetaData field) {
<span class="nc bnc" id="L1321" title="All 4 branches missed.">        if (field != null &amp;&amp; _fieldMap.remove(field.getName()) != null) {</span>
<span class="nc" id="L1322">            clearFieldCache();</span>
<span class="nc" id="L1323">            return true;</span>
        }
<span class="nc" id="L1325">        return false;</span>
    }

    /**
     * Return the defined superclass field with the given name, or null if none.
     */
    public FieldMetaData getDefinedSuperclassField(String name) {
<span class="nc bnc" id="L1332" title="All 2 branches missed.">        if (_supFieldMap == null)</span>
<span class="nc" id="L1333">            return null;</span>
<span class="nc" id="L1334">        return _supFieldMap.get(name);</span>
    }

    /**
     * Add a new defined superclass field metadata to this class.
     */
    public FieldMetaData addDefinedSuperclassField(String name, Class&lt;?&gt; type,
        Class&lt;?&gt; sup) {
<span class="nc" id="L1342">        FieldMetaData fmd = _repos.newFieldMetaData(name, type, this);</span>
<span class="nc" id="L1343">        fmd.setDeclaringType(sup);</span>
<span class="nc" id="L1344">        clearAllFieldCache();</span>
<span class="nc" id="L1345">        _defSupFields = false;</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">        if (_supFieldMap == null)</span>
<span class="nc" id="L1347">            _supFieldMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1348">        _supFieldMap.put(name, fmd);</span>
<span class="nc" id="L1349">        return fmd;</span>
    }

    /**
     * Remove the given field from management.
     *
     * @return true if the field was removed, false otherwise
     */
    public boolean removeDefinedSuperclassField(FieldMetaData field) {
<span class="nc bnc" id="L1358" title="All 4 branches missed.">        if (field != null &amp;&amp; _supFieldMap != null</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">            &amp;&amp; _supFieldMap.remove(field.getName()) != null) {</span>
<span class="nc" id="L1360">            clearAllFieldCache();</span>
<span class="nc" id="L1361">            _defSupFields = false;</span>
<span class="nc" id="L1362">            return true;</span>
        }
<span class="nc" id="L1364">        return false;</span>
    }

    /**
     * Incorporate superclass fields redefined in this subclass into this
     * metadata. This method is generally called after metadata is resolved
     * and mapping information is loaded, but before mapping resolve.
     *
     * @param force whether to force re-mapping of even mapped superclass fields
     */
    public void defineSuperclassFields(boolean force) {
<span class="nc bnc" id="L1375" title="All 2 branches missed.">        if (_defSupFields)</span>
<span class="nc" id="L1376">            return;</span>

<span class="nc" id="L1378">        ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L1379" title="All 4 branches missed.">        if (isMapped() &amp;&amp; sup != null) {</span>
            // redefine all unmapped superclass fields
<span class="nc" id="L1381">            FieldMetaData[] sups = sup.getFields();</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">            for (int i = 0; i &lt; sups.length; i++) {</span>
<span class="nc bnc" id="L1383" title="All 4 branches missed.">                if ((force || !sups[i].getDefiningMetaData().isMapped())</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">                    &amp;&amp; getDefinedSuperclassField(sups[i].getName()) == null) {</span>
<span class="nc" id="L1385">                    addDefinedSuperclassField(sups[i].getName(),</span>
<span class="nc" id="L1386">                        sups[i].getDeclaredType(), sups[i].getDeclaringType());</span>
                }
            }
        }
<span class="nc" id="L1390">        resolveDefinedSuperclassFields();</span>

        // this ensures that all field indexes get set when fields are cached.
        // I don't like doing this twice (it's also done in resolveMeta), but
        // we have to re-cache in case this class or any superclass replaced
        // some fields with redefined versions, and I don't want outside code
        // to have to call this method after resolve just to get field indexes,
        // etc set correctly
<span class="nc" id="L1398">        clearAllFieldCache();</span>
<span class="nc" id="L1399">        cacheFields();</span>
<span class="nc" id="L1400">    }</span>

    /**
     * Resolve superclass fields we've redefined.
     */
    private void resolveDefinedSuperclassFields() {
<span class="nc" id="L1406">        _defSupFields = true;</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">        if (_supFieldMap == null)</span>
<span class="nc" id="L1408">            return;</span>

        FieldMetaData sup;
<span class="nc bnc" id="L1411" title="All 2 branches missed.">        for (FieldMetaData fmd : _supFieldMap.values()) {</span>
<span class="nc" id="L1412">            sup = getSuperclassField(fmd);</span>

            // JPA metadata doesn't qualify superclass field names, so we
            // might not know the declaring type until now
<span class="nc bnc" id="L1416" title="All 2 branches missed.">            if (fmd.getDeclaringType() == Object.class) {</span>
<span class="nc" id="L1417">                fmd.setDeclaringType(sup.getDeclaringType());</span>
<span class="nc" id="L1418">                fmd.backingMember(getRepository().getMetaDataFactory().</span>
<span class="nc" id="L1419">                    getDefaults().getBackingMember(fmd));</span>
            }
<span class="nc" id="L1421">            fmd.copy(sup);</span>
<span class="nc" id="L1422">            fmd.resolve(MODE_META);</span>
<span class="nc" id="L1423">        }</span>
<span class="nc" id="L1424">    }</span>

    /**
     * Returns an array of all the fields defined by this class.
     * This includes mapped declared fields and any concrete mapping of
     * unmapped superclass fields performed by this class.
     */
    public FieldMetaData[] getDefinedFields() {
<span class="nc bnc" id="L1432" title="All 2 branches missed.">        if (_definedFields == null) {</span>
<span class="nc" id="L1433">            FieldMetaData[] fields = getFields();</span>
<span class="nc" id="L1434">            List&lt;FieldMetaData&gt; defined =</span>
            	new ArrayList&lt;&gt;(fields.length);
<span class="nc bnc" id="L1436" title="All 2 branches missed.">            for (FieldMetaData fmd : fields) {</span>
<span class="nc bnc" id="L1437" title="All 2 branches missed.">                if (fmd.isMapped()</span>
<span class="nc bnc" id="L1438" title="All 2 branches missed.">                    &amp;&amp; fmd.getDefiningMetaData() == this)</span>
<span class="nc" id="L1439">                    defined.add(fmd);</span>
            }
<span class="nc" id="L1441">            _definedFields = defined.toArray</span>
<span class="nc" id="L1442">                (_repos.newFieldMetaDataArray(defined.size()));</span>
        }
<span class="nc" id="L1444">        return _definedFields;</span>
    }

    /**
     * Returns all fields in the order they are listed in the metadata
     * file. Unlisted fields are placed after listed ones.
     */
    public FieldMetaData[] getFieldsInListingOrder() {
<span class="nc bnc" id="L1452" title="All 2 branches missed.">        if (_allListingFields == null) {</span>
            // combine declared and unmanaged fields into listing order array
<span class="nc" id="L1454">            FieldMetaData[] dec = getDeclaredFields();</span>
<span class="nc" id="L1455">            FieldMetaData[] unmgd = getDeclaredUnmanagedFields();</span>
<span class="nc" id="L1456">            FieldMetaData[] decListing = _repos.newFieldMetaDataArray</span>
<span class="nc" id="L1457">                (dec.length + unmgd.length);</span>
<span class="nc" id="L1458">            System.arraycopy(dec, 0, decListing, 0, dec.length);</span>
<span class="nc" id="L1459">            System.arraycopy(unmgd, 0, decListing, dec.length, unmgd.length);</span>
<span class="nc" id="L1460">            Arrays.sort(decListing, ListingOrderComparator.getInstance());</span>

<span class="nc bnc" id="L1462" title="All 2 branches missed.">            if (_super == null)</span>
<span class="nc" id="L1463">                _allListingFields = decListing;</span>
            else {
                // place superclass fields in listing order before our
                // listing-order declared fields
<span class="nc" id="L1467">                FieldMetaData[] sup = getPCSuperclassMetaData().</span>
<span class="nc" id="L1468">                    getFieldsInListingOrder();</span>
<span class="nc" id="L1469">                FieldMetaData[] listing = _repos.newFieldMetaDataArray</span>
<span class="nc" id="L1470">                    (sup.length + decListing.length);</span>
<span class="nc" id="L1471">                System.arraycopy(sup, 0, listing, 0, sup.length);</span>
<span class="nc" id="L1472">                replaceDefinedSuperclassFields(listing, sup.length);</span>
<span class="nc" id="L1473">                System.arraycopy(decListing, 0, listing, sup.length,</span>
                    decListing.length);
<span class="nc" id="L1475">                _allListingFields = listing;</span>
            }
        }
<span class="nc" id="L1478">        return _allListingFields;</span>
    }

    /**
     * Returns all fields defined by this class in the order they are listed
     * in the metadata file. Unlisted fields are placed after listed ones.
     * This array includes declared transactional and unmanaged fields.
     */
    public FieldMetaData[] getDefinedFieldsInListingOrder() {
<span class="nc bnc" id="L1487" title="All 2 branches missed.">        if (_listingFields == null) {</span>
<span class="nc" id="L1488">            FieldMetaData[] fields = getFields();</span>
<span class="nc" id="L1489">            List&lt;FieldMetaData&gt; defined =</span>
            	new ArrayList&lt;&gt;(fields.length);
<span class="nc bnc" id="L1491" title="All 2 branches missed.">            for (FieldMetaData fmd : fields)</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">                if (fmd.getDefiningMetaData() == this)</span>
<span class="nc" id="L1493">                    defined.add(fmd);</span>
<span class="nc" id="L1494">            FieldMetaData[] unmgd = getDeclaredUnmanagedFields();</span>
<span class="nc" id="L1495">            FieldMetaData[] listing = _repos.newFieldMetaDataArray</span>
<span class="nc" id="L1496">                (defined.size() + unmgd.length);</span>
<span class="nc bnc" id="L1497" title="All 2 branches missed.">            for (int i = 0; i &lt; defined.size(); i++)</span>
<span class="nc" id="L1498">                listing[i] = defined.get(i);</span>
<span class="nc" id="L1499">            System.arraycopy(unmgd, 0, listing, defined.size(), unmgd.length);</span>
<span class="nc" id="L1500">            Arrays.sort(listing, ListingOrderComparator.getInstance());</span>
<span class="nc" id="L1501">            _listingFields = listing;</span>
        }
<span class="nc" id="L1503">        return _listingFields;</span>
    }

    /**
     * The name of the data cache that stores the managed instance of this class, by default.
     * This can be overwritten by per-instance basis {@linkplain CacheDistributionPolicy cache distribution policy}.
     *
     * @return null if this class is disabled from cache by @DataCache(enabled=false).
     *         {@linkplain DataCache#NAME_DEFAULT default} if @DataCache(enabled=true) without a name.
     *         Otherwise, data cache name set by the user via @DataCache name attribute.
     *
     */
    public String getDataCacheName() {
<span class="nc bnc" id="L1516" title="All 2 branches missed.">        if (DEFAULT_STRING.equals(_cacheName)) {</span>
<span class="nc bnc" id="L1517" title="All 4 branches missed.">            if (_super != null &amp;&amp; StringUtil.isNotEmpty(getPCSuperclassMetaData().getDataCacheName())) {</span>
<span class="nc" id="L1518">                _cacheName = getPCSuperclassMetaData().getDataCacheName();</span>
            } else {
<span class="nc" id="L1520">                _cacheName = DataCache.NAME_DEFAULT;</span>
            }
        }
<span class="nc" id="L1523">        return _cacheName;</span>
    }

    /**
     * Set the cache name for this class.
     *
     * @param name can be {@code null} to disable cache.
     */
    public void setDataCacheName(String name) {
<span class="nc" id="L1532">        _cacheName = name;</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">        if (name != null)</span>
<span class="nc" id="L1534">            _dataCacheEnabled = true;</span>
<span class="nc" id="L1535">    }</span>

    /**
     * Affirms true if this receiver is annotated with @DataCache and is not disabled.
     * A separate state variable is necessary besides the name of the cache defaulted to a special string.
     */
    public boolean getDataCacheEnabled() {
<span class="nc" id="L1542">        return _dataCacheEnabled;</span>
    }

    /**
     * The cache timeout for this class. -1 indicates no timeout.
     */
    public int getDataCacheTimeout() {
<span class="nc bnc" id="L1549" title="All 2 branches missed.">        if (_cacheTimeout == Integer.MIN_VALUE) {</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">            if (_super != null)</span>
<span class="nc" id="L1551">                _cacheTimeout = getPCSuperclassMetaData().</span>
<span class="nc" id="L1552">                    getDataCacheTimeout();</span>
            else
<span class="nc" id="L1554">                _cacheTimeout = _repos.getConfiguration().</span>
<span class="nc" id="L1555">                    getDataCacheTimeout();</span>
        }
<span class="nc" id="L1557">        return _cacheTimeout;</span>
    }

    /**
     * The cache timeout for this class. -1 indicates no timeout.
     */
    public void setDataCacheTimeout(int timeout) {
<span class="nc" id="L1564">        _cacheTimeout = timeout;</span>
<span class="nc" id="L1565">    }</span>

    /**
     * Return the data cache for this class, or null if it is not cachable.
     */
    public DataCache getDataCache() {
<span class="nc" id="L1571">        String name = getDataCacheName();</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L1573">            return null;</span>
        }
<span class="nc" id="L1575">        return _repos.getConfiguration().getDataCacheManagerInstance().getDataCache(name, true);</span>
    }

    /**
     * Whether instances are detachable.
     */
    public boolean isDetachable() {
<span class="nc bnc" id="L1582" title="All 2 branches missed.">        if (_detachable == null) {</span>
<span class="nc bnc" id="L1583" title="All 2 branches missed.">            if (_super != null)</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">                _detachable = (getPCSuperclassMetaData().isDetachable())</span>
<span class="nc" id="L1585">                    ? Boolean.TRUE : Boolean.FALSE;</span>
            else
<span class="nc" id="L1587">                _detachable = Boolean.FALSE;</span>
        }
<span class="nc" id="L1589">        return _detachable.booleanValue();</span>
    }

    /**
     * Whether instances are detachable.
     */
    public void setDetachable(boolean detachable) {
<span class="nc bnc" id="L1596" title="All 2 branches missed.">        _detachable = (detachable) ? Boolean.TRUE : Boolean.FALSE;</span>
<span class="nc" id="L1597">    }</span>

    /**
     * The name of the detach state field, or null if none.
     */
    public String getDetachedState() {
<span class="nc bnc" id="L1603" title="All 2 branches missed.">        if (DEFAULT_STRING.equals(_detachState)) {</span>
<span class="nc" id="L1604">            ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L1605" title="All 4 branches missed.">            if (sup != null &amp;&amp; sup.isDetachable() == isDetachable())</span>
<span class="nc" id="L1606">                _detachState = sup.getDetachedState();</span>
            else {
<span class="nc" id="L1608">                Boolean use = usesDetachedState(SYNTHETIC, true);</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">                _detachState = (Boolean.FALSE.equals(use)) ? null : SYNTHETIC;</span>
            }
        }
<span class="nc" id="L1612">        return _detachState;</span>
    }

    /**
     * The name of the detach state field, or null if none.
     */
    public void setDetachedState(String field) {
<span class="nc" id="L1619">        _detachState = field;</span>
<span class="nc" id="L1620">    }</span>

    /**
     * Return the detach state field, or null if none.
     */
    public Field getDetachedStateField() {
        // no caching; only used at enhancement
<span class="nc" id="L1627">        String fieldName = getDetachedState();</span>
<span class="nc bnc" id="L1628" title="All 4 branches missed.">        if (fieldName == null || SYNTHETIC.equals(fieldName))</span>
<span class="nc" id="L1629">            return null;</span>

<span class="nc" id="L1631">        Field f = Reflection.findField(_type, fieldName, false);</span>
<span class="nc bnc" id="L1632" title="All 2 branches missed.">        if (f != null)</span>
<span class="nc" id="L1633">            return f;</span>
        else
<span class="nc" id="L1635">            throw new MetaDataException(</span>
<span class="nc" id="L1636">                _loc.get(&quot;no-detach-state&quot;, fieldName, _type));</span>
    }

    /**
     * Whether an instance of this type has detached state.
     *
     * @return true if a detached instance must have detached state, false
     * if it does not, and null if it may use a
     * manually-constructed instance without detached state
     */
    public Boolean usesDetachedState() {
        // no need to let conf disallow because it's taken into account in
        // getDetachedState() call
<span class="nc" id="L1649">        return usesDetachedState(getDetachedState(), false);</span>
    }

    /**
     * Whether an instance of this type has detached state, assuming the given
     * detached state field.
     *
     * @return true if a detached instance must have detached state, false
     * if it does not, and null if it may use a
     * manually-constructed instance without detached state
     */
    private Boolean usesDetachedState(String detachedField,
        boolean confDisallows) {
<span class="nc bnc" id="L1662" title="All 2 branches missed.">        if (!isDetachable())</span>
<span class="nc" id="L1663">            return Boolean.FALSE;</span>

        // if we declare a detached state field, have to use it
<span class="nc bnc" id="L1666" title="All 2 branches missed.">        if (detachedField == null)</span>
<span class="nc" id="L1667">            return Boolean.FALSE;</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">        if (!SYNTHETIC.equals(detachedField))</span>
<span class="nc" id="L1669">            return Boolean.TRUE;</span>

        // allow conf to disallow
<span class="nc bnc" id="L1672" title="All 2 branches missed.">        if (confDisallows &amp;&amp; !_repos.getConfiguration().</span>
<span class="nc bnc" id="L1673" title="All 2 branches missed.">            getDetachStateInstance().getDetachedStateField())</span>
<span class="nc" id="L1674">            return Boolean.FALSE;</span>

        // have to use detached state to store datastore id
<span class="nc bnc" id="L1677" title="All 2 branches missed.">        if (getIdentityType() == ID_DATASTORE)</span>
<span class="nc" id="L1678">            return Boolean.TRUE;</span>

        // allow detached state use, but don't require
<span class="nc" id="L1681">        return null;</span>
    }

    /**
     * Clear cached field data.
     */
    protected void clearAllFieldCache() {
<span class="nc" id="L1688">        _allFields = null;</span>
<span class="nc" id="L1689">        _allDFGFields = null;</span>
<span class="nc" id="L1690">        _allPKFields = null;</span>
<span class="nc" id="L1691">        _allProxyFields = null;</span>
<span class="nc" id="L1692">        _allLrsFields = null;</span>
<span class="nc" id="L1693">        _definedFields = null;</span>
<span class="nc" id="L1694">        _listingFields = null;</span>
<span class="nc" id="L1695">        _allListingFields = null;</span>
<span class="nc" id="L1696">        _fieldDataTable = null;</span>
<span class="nc" id="L1697">    }</span>

    /**
     * Clear defined field data.
     */
    protected void clearDefinedFieldCache() {
<span class="nc" id="L1703">        _definedFields = null;</span>
<span class="nc" id="L1704">        _listingFields = null;</span>
<span class="nc" id="L1705">    }</span>

    /**
     * Clear cached field data.
     */
    protected void clearFieldCache() {
<span class="nc" id="L1711">        clearAllFieldCache();</span>
<span class="nc" id="L1712">        _fields = null;</span>
<span class="nc" id="L1713">        _unmgdFields = null;</span>
<span class="nc" id="L1714">        _versionIdx = Integer.MIN_VALUE;</span>
<span class="nc" id="L1715">    }</span>

    /**
     * Clear cached subclass data.
     */
    protected void clearSubclassCache() {
<span class="nc" id="L1721">        _subs = null;</span>
<span class="nc" id="L1722">        _subMetas = null;</span>
<span class="nc" id="L1723">        _mapSubMetas = null;</span>
<span class="nc" id="L1724">    }</span>

    /**
     * Clear impl data and intermediate data table.
     */
    void clearExtraFieldDataTable() {
<span class="nc" id="L1730">        _fieldDataTable = null;</span>
<span class="nc" id="L1731">    }</span>

    /**
     * Cache field arrays.
     */
    private void cacheFields() {
<span class="nc" id="L1737">        getFields();</span>
<span class="nc" id="L1738">        getPrimaryKeyFields();</span>
<span class="nc" id="L1739">    }</span>

    @Override
    public int hashCode() {
<span class="nc" id="L1743">        return _hashCode;</span>
    }

    @Override
    public boolean equals(Object other) {
<span class="nc bnc" id="L1748" title="All 2 branches missed.">        if (other == this)</span>
<span class="nc" id="L1749">            return true;</span>
<span class="nc bnc" id="L1750" title="All 2 branches missed.">        if (!(other instanceof ClassMetaData))</span>
<span class="nc" id="L1751">            return false;</span>
<span class="nc bnc" id="L1752" title="All 2 branches missed.">        return _type == ((ClassMetaData) other).getDescribedType();</span>
    }

    @Override
    public int compareTo(ClassMetaData other) {
<span class="nc bnc" id="L1757" title="All 2 branches missed.">        if (other == this)</span>
<span class="nc" id="L1758">            return 0;</span>
<span class="nc" id="L1759">        return _type.getName().compareTo(other.</span>
<span class="nc" id="L1760">            getDescribedType().getName());</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L1765">        return getDescribedType().getName();</span>
    }

    ////////////////////////
    // Resolve and validate
    ////////////////////////

    /**
     * The resolve mode for this metadata.
     */
    public int getResolve() {
<span class="nc" id="L1776">        return _resMode;</span>
    }

    /**
     * The resolve mode for this metadata.
     */
    public void setResolve(int mode) {
<span class="nc" id="L1783">        _resMode = mode;</span>
<span class="nc" id="L1784">    }</span>

    /**
     * The resolve mode for this metadata.
     */
    public void setResolve(int mode, boolean on) {
<span class="nc bnc" id="L1790" title="All 2 branches missed.">        if (mode == MODE_NONE)</span>
<span class="nc" id="L1791">            _resMode = mode;</span>
<span class="nc bnc" id="L1792" title="All 2 branches missed.">        else if (on)</span>
<span class="nc" id="L1793">            _resMode |= mode;</span>
        else
<span class="nc" id="L1795">            _resMode &amp;= ~mode;</span>
<span class="nc" id="L1796">    }</span>

    /**
     * Resolve and validate metadata. Return true if already resolved.
     */
    public boolean resolve(int mode) {
<span class="nc bnc" id="L1802" title="All 2 branches missed.">        if ((_resMode &amp; mode) == mode)</span>
<span class="nc" id="L1803">            return true;</span>
<span class="nc" id="L1804">        int cur = _resMode;</span>
<span class="nc" id="L1805">        _resMode |= mode;</span>

<span class="nc" id="L1807">        int val = _repos.getValidate();</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">        boolean runtime = (val &amp; MetaDataRepository.VALIDATE_RUNTIME) != 0;</span>
<span class="nc" id="L1809">        boolean validate =</span>
<span class="nc bnc" id="L1810" title="All 4 branches missed.">            !ImplHelper.isManagedType(getRepository().getConfiguration(), _type)</span>
            || (val &amp; MetaDataRepository.VALIDATE_UNENHANCED) == 0;

        // we only do any actions for metadata mode
<span class="nc bnc" id="L1814" title="All 4 branches missed.">        if ((mode &amp; MODE_META) != 0 &amp;&amp; (cur &amp; MODE_META) == 0) {</span>
<span class="nc" id="L1815">            resolveMeta(runtime);</span>
<span class="nc bnc" id="L1816" title="All 4 branches missed.">            if (validate &amp;&amp; (val &amp; MetaDataRepository.VALIDATE_META) != 0)</span>
<span class="nc" id="L1817">                validateMeta(runtime);</span>
        }
<span class="nc bnc" id="L1819" title="All 4 branches missed.">        if ((mode &amp; MODE_MAPPING) != 0 &amp;&amp; (cur &amp; MODE_MAPPING) == 0) {</span>
<span class="nc" id="L1820">            resolveMapping(runtime);</span>
<span class="nc bnc" id="L1821" title="All 4 branches missed.">            if (validate &amp;&amp; (val &amp; MetaDataRepository.VALIDATE_MAPPING) != 0)</span>
<span class="nc" id="L1822">                validateMapping(runtime);</span>
        }
<span class="nc bnc" id="L1824" title="All 4 branches missed.">        if ((mode &amp; MODE_MAPPING_INIT) != 0 &amp;&amp; (cur &amp; MODE_MAPPING_INIT) == 0)</span>
<span class="nc" id="L1825">            initializeMapping();</span>
<span class="nc" id="L1826">        return false;</span>
    }

    /**
     * Resolve metadata.
     */
    protected void resolveMeta(boolean runtime) {
<span class="nc bnc" id="L1833" title="All 4 branches missed.">        boolean embed = _owner != null &amp;&amp; _owner.getDeclaredType() == _type;</span>
<span class="nc" id="L1834">        Log log = _repos.getLog();</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">        if (log.isTraceEnabled())</span>
<span class="nc bnc" id="L1836" title="All 2 branches missed.">            log.trace(_loc.get((embed) ? &quot;resolve-embed-meta&quot; : &quot;resolve-meta&quot;,</span>
<span class="nc" id="L1837">                this + &quot;@&quot; + System.identityHashCode(this)));</span>

<span class="nc bnc" id="L1839" title="All 4 branches missed.">        if (runtime &amp;&amp; !_type.isInterface() &amp;&amp;</span>
<span class="nc bnc" id="L1840" title="All 2 branches missed.">            !ImplHelper.isManagedType(getRepository().getConfiguration(),_type))</span>
<span class="nc" id="L1841">            throw new MetaDataException(_loc.get(&quot;not-enhanced&quot;, _type));</span>

        // are we the target of an embedded value?
<span class="nc bnc" id="L1844" title="All 2 branches missed.">        if (embed) {</span>
<span class="nc bnc" id="L1845" title="All 2 branches missed.">            if (recursiveEmbed(_owner)) {</span>
<span class="nc" id="L1846">                throw new MetaDataException(_loc.get(&quot;recurse-embed&quot;, _owner));</span>
            }

            // copy info from the &quot;real&quot; metadata for this type
<span class="nc" id="L1850">            ClassMetaData meta = _repos.getMetaData(_type, _loader, true);</span>
<span class="nc" id="L1851">            meta.resolve(MODE_META);</span>
<span class="nc" id="L1852">            copy(this, meta);</span>
<span class="nc" id="L1853">            _embedded = Boolean.FALSE; // embedded instance isn't embedded-only</span>
        }

        // make sure superclass is resolved
<span class="nc" id="L1857">        ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L1858" title="All 2 branches missed.">        if (sup != null) {</span>
<span class="nc" id="L1859">            sup.resolve(MODE_META);</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">            if (embed) {</span>
                // embedded instance always redefine all superclass fields
<span class="nc" id="L1862">                FieldMetaData[] sups = sup.getFields();</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">                for (int i = 0; i &lt; sups.length; i++) {</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">                    if (_supFieldMap == null</span>
<span class="nc bnc" id="L1865" title="All 2 branches missed.">                        || !_supFieldMap.containsKey(sups[i].getName())) {</span>
<span class="nc" id="L1866">                        addDefinedSuperclassField(sups[i].getName(),</span>
<span class="nc" id="L1867">                            sups[i].getDeclaredType(),</span>
<span class="nc" id="L1868">                            sups[i].getDeclaringType());</span>
                    }
                }
            }
        }

        // resolve fields and remove invalids
        FieldMetaData fmd;
<span class="nc" id="L1876">        for (Iterator&lt;FieldMetaData&gt; itr = _fieldMap.values().iterator();</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">        	itr.hasNext();) {</span>
            // only pass on metadata resolve mode so that metadata is always
            // resolved before any other resolve modes our subclasses pass along
<span class="nc" id="L1880">            fmd = itr.next();</span>
<span class="nc" id="L1881">            fmd.resolve(MODE_META);</span>

<span class="nc bnc" id="L1883" title="All 2 branches missed.">            if (!fmd.isExplicit()</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">                &amp;&amp; (fmd.getDeclaredTypeCode() == JavaTypes.OBJECT</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">                || fmd.getDeclaredTypeCode() == JavaTypes.PC_UNTYPED</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">                || (fmd.getDeclaredTypeCode() == JavaTypes.ARRAY</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">                &amp;&amp; fmd.getElement().getDeclaredTypeCode()</span>
                == JavaTypes.OBJECT))) {
<span class="nc" id="L1889">                _repos.getLog().warn(_loc.get(&quot;rm-field&quot;, fmd));</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">                if (fmd.getListingIndex() != -1)</span>
<span class="nc" id="L1891">                    fmd.setManagement(FieldMetaData.MANAGE_NONE);</span>
                else
<span class="nc" id="L1893">                    itr.remove();</span>
<span class="nc" id="L1894">                clearFieldCache();</span>
            }
        }

        // embedded instances must embed all superclass fields too
<span class="nc bnc" id="L1899" title="All 2 branches missed.">        if (embed) {</span>
<span class="nc" id="L1900">            clearAllFieldCache();</span>
<span class="nc" id="L1901">            resolveDefinedSuperclassFields();</span>
        }

        // this ensures that all field indexes get set when fields are cached
<span class="nc" id="L1905">        cacheFields();</span>

        // resolve lifecycle metadata now to prevent lazy threading problems
<span class="nc" id="L1908">        _lifeMeta.resolve();</span>

        // record implements in the repository
<span class="nc bnc" id="L1911" title="All 2 branches missed.">        if (_interfaces != null) {</span>
<span class="nc bnc" id="L1912" title="All 2 branches missed.">            for (Class&lt;?&gt; iface : _interfaces)</span>
<span class="nc" id="L1913">                _repos.addDeclaredInterfaceImpl(this, iface);</span>
        }

        // resolve fetch groups
<span class="nc bnc" id="L1917" title="All 2 branches missed.">        if (_fgMap != null)</span>
<span class="nc bnc" id="L1918" title="All 2 branches missed.">            for (FetchGroup fg : _fgMap.values())</span>
<span class="nc" id="L1919">                fg.resolve();</span>

<span class="nc bnc" id="L1921" title="All 4 branches missed.">        if (!embed &amp;&amp; _type.isInterface()) {</span>
<span class="nc bnc" id="L1922" title="All 2 branches missed.">            if (_interface != Boolean.TRUE)</span>
<span class="nc" id="L1923">                throw new MetaDataException(_loc.get(&quot;interface&quot;, _type));</span>

<span class="nc bnc" id="L1925" title="All 2 branches missed.">            if (runtime) {</span>
<span class="nc" id="L1926">                _impl = _repos.getImplGenerator().createImpl(this);</span>
<span class="nc" id="L1927">                _repos.setInterfaceImpl(this, _impl);</span>
            }
        }

        // if this is runtime, create a pc instance and scan it for comparators
<span class="nc bnc" id="L1932" title="All 4 branches missed.">        if (runtime &amp;&amp; !Modifier.isAbstract(_type.getModifiers())) {</span>
<span class="nc" id="L1933">            ProxySetupStateManager sm = new ProxySetupStateManager();</span>
<span class="nc" id="L1934">            sm.setProxyData(PCRegistry.newInstance(_type, sm, false), this);</span>
        }
<span class="nc" id="L1936">    }</span>

    private boolean recursiveEmbed(ValueMetaData owner) {
<span class="nc" id="L1939">        ClassMetaData cm = owner.getFieldMetaData().getDefiningMetaData();</span>
<span class="nc bnc" id="L1940" title="All 2 branches missed.">        if (cm.getDescribedType().isAssignableFrom(_type))</span>
<span class="nc" id="L1941">            return true;</span>
<span class="nc" id="L1942">        ValueMetaData owner1 = cm.getEmbeddingMetaData();</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">        if (owner1 == null)</span>
<span class="nc" id="L1944">            return false;</span>
        else
<span class="nc" id="L1946">            return recursiveEmbed(owner1);</span>
    }

    /**
     * Validate resolved metadata.
     */
    protected void validateMeta(boolean runtime) {
<span class="nc" id="L1953">        validateDataCache();</span>
<span class="nc" id="L1954">        validateDetachable();</span>
<span class="nc" id="L1955">        validateExtensionKeys();</span>
<span class="nc" id="L1956">        validateIdentity();</span>
<span class="nc" id="L1957">        validateAccessType();</span>
<span class="nc" id="L1958">    }</span>

    /**
     * Resolve mapping data. Logs resolve message and resolves super by default.
     */
    protected void resolveMapping(boolean runtime) {
<span class="nc" id="L1964">        Log log = _repos.getLog();</span>
<span class="nc bnc" id="L1965" title="All 2 branches missed.">        if (log.isTraceEnabled())</span>
<span class="nc" id="L1966">            log.trace(_loc.get(&quot;resolve-mapping&quot;, this + &quot;@&quot;</span>
<span class="nc" id="L1967">                + System.identityHashCode(this)));</span>

        // make sure superclass is resolved first
<span class="nc" id="L1970">        ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L1971" title="All 2 branches missed.">        if (sup != null)</span>
<span class="nc" id="L1972">            sup.resolve(MODE_MAPPING);</span>
<span class="nc" id="L1973">    }</span>

    /**
     * Validate mapping data.
     */
    protected void validateMapping(boolean runtime) {
<span class="nc" id="L1979">    }</span>

    /**
     * Initialize mapping. Logs init message by default.
     */
    protected void initializeMapping() {
<span class="nc" id="L1985">        Log log = _repos.getLog();</span>
<span class="nc bnc" id="L1986" title="All 2 branches missed.">        if (log.isTraceEnabled())</span>
<span class="nc" id="L1987">            log.trace(_loc.get(&quot;init-mapping&quot;, this + &quot;@&quot;</span>
<span class="nc" id="L1988">                + System.identityHashCode(this)));</span>
<span class="nc" id="L1989">    }</span>

    /**
     * Validate data cache settings.
     */
    private void validateDataCache() {
<span class="nc" id="L1995">        int timeout = getDataCacheTimeout();</span>
<span class="nc bnc" id="L1996" title="All 4 branches missed.">        if (timeout &lt; -1 || timeout == 0)</span>
<span class="nc" id="L1997">            throw new MetaDataException(_loc.get(&quot;cache-timeout-invalid&quot;,</span>
<span class="nc" id="L1998">                _type, String.valueOf(timeout)));</span>

<span class="nc bnc" id="L2000" title="All 2 branches missed.">        if (_super == null) {</span>
<span class="nc" id="L2001">            return;</span>
        }
<span class="nc" id="L2003">        String cache = getDataCacheName();</span>
<span class="nc bnc" id="L2004" title="All 2 branches missed.">        if (cache == null) {</span>
<span class="nc" id="L2005">            return;</span>
        }

<span class="nc" id="L2008">        String superCache = getPCSuperclassMetaData().getDataCacheName();</span>

<span class="nc bnc" id="L2010" title="All 2 branches missed.">        if (!StringUtil.isEmpty(superCache)) {</span>
<span class="nc bnc" id="L2011" title="All 2 branches missed.">            if (!Objects.equals(cache, superCache)) {</span>
<span class="nc" id="L2012">                throw new MetaDataException(_loc.get(&quot;cache-names&quot;, new Object[] { _type, cache, _super, superCache }));</span>
            }
        }
<span class="nc" id="L2015">    }</span>

    /**
     * Assert that the identity handling for this class is valid.
     */
    private void validateIdentity() {
        // make sure identity types are consistent
<span class="nc" id="L2022">        ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc" id="L2023">        int id = getIdentityType();</span>
<span class="nc bnc" id="L2024" title="All 4 branches missed.">        if (sup != null &amp;&amp; sup.getIdentityType() != ID_UNKNOWN</span>
<span class="nc bnc" id="L2025" title="All 2 branches missed.">            &amp;&amp; sup.getIdentityType() != id)</span>
<span class="nc" id="L2026">            throw new MetaDataException(_loc.get(&quot;id-types&quot;, _type));</span>

        // check for things the data store doesn't support
<span class="nc" id="L2029">        Collection&lt;String&gt; opts = _repos.getConfiguration().supportedOptions();</span>
<span class="nc bnc" id="L2030" title="All 2 branches missed.">        if (id == ID_APPLICATION</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">            &amp;&amp; !opts.contains(OpenJPAConfiguration.OPTION_ID_APPLICATION)) {</span>
<span class="nc" id="L2032">            throw new UnsupportedException(_loc.get(&quot;appid-not-supported&quot;,</span>
                _type));
        }
<span class="nc bnc" id="L2035" title="All 2 branches missed.">        if (id == ID_DATASTORE</span>
<span class="nc bnc" id="L2036" title="All 2 branches missed.">            &amp;&amp; !opts.contains(OpenJPAConfiguration.OPTION_ID_DATASTORE)) {</span>
<span class="nc" id="L2037">            throw new UnsupportedException(_loc.get</span>
<span class="nc" id="L2038">                (&quot;datastoreid-not-supported&quot;, _type));</span>
        }

<span class="nc bnc" id="L2041" title="All 2 branches missed.">        if (id == ID_APPLICATION) {</span>
<span class="nc bnc" id="L2042" title="All 2 branches missed.">            if (_idStrategy != ValueStrategies.NONE)</span>
<span class="nc" id="L2043">                throw new MetaDataException(_loc.get(&quot;appid-strategy&quot;, _type));</span>
<span class="nc" id="L2044">            validateAppIdClass();</span>
<span class="nc bnc" id="L2045" title="All 2 branches missed.">        } else if (id != ID_UNKNOWN)</span>
<span class="nc" id="L2046">            validateNoPKFields();</span>

<span class="nc" id="L2048">        int strategy = getIdentityStrategy();</span>
<span class="nc bnc" id="L2049" title="All 2 branches missed.">        if (strategy == ValueStrategies.SEQUENCE</span>
<span class="nc bnc" id="L2050" title="All 2 branches missed.">            &amp;&amp; getIdentitySequenceName() == null)</span>
<span class="nc" id="L2051">            throw new MetaDataException(_loc.get(&quot;no-seq-name&quot;, _type));</span>

<span class="nc" id="L2053">        ValueStrategies.assertSupported(strategy, this,</span>
            &quot;datastore identity strategy&quot;);
<span class="nc" id="L2055">    }</span>

    /**
     * Make sure the application identity class is valid.
     */
    private void validateAppIdClass() {
        // base types must declare an oid class if not single-field identity
<span class="nc" id="L2062">        FieldMetaData[] pks = getPrimaryKeyFields();</span>
<span class="nc bnc" id="L2063" title="All 2 branches missed.">        if (getObjectIdType() == null) {</span>
<span class="nc bnc" id="L2064" title="All 2 branches missed.">            if (pks.length == 1)</span>
<span class="nc" id="L2065">                throw new MetaDataException(_loc.get(&quot;unsupported-id-type&quot;,</span>
<span class="nc" id="L2066">                    _type, pks[0].getName(),</span>
<span class="nc" id="L2067">                    pks[0].getDeclaredType().getName()));</span>
<span class="nc" id="L2068">            throw new MetaDataException(_loc.get(&quot;no-id-class&quot;, _type,</span>
<span class="nc" id="L2069">            		Arrays.asList(toNames(pks))));</span>
        }
<span class="nc bnc" id="L2071" title="All 2 branches missed.">        if (_objectId == null)</span>
<span class="nc" id="L2072">            return;</span>

<span class="nc bnc" id="L2074" title="All 2 branches missed.">        if (isOpenJPAIdentity()) {</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">            if (pks[0].getDeclaredTypeCode() == JavaTypes.OID) {</span>
<span class="nc" id="L2076">                ClassMetaData embed = pks[0].getEmbeddedMetaData();</span>
<span class="nc" id="L2077">                validateAppIdClassMethods(embed.getDescribedType());</span>
<span class="nc" id="L2078">                validateAppIdClassPKs(embed, embed.getFields(),</span>
<span class="nc" id="L2079">                    embed.getDescribedType());</span>
            }
<span class="nc" id="L2081">            return;</span>
        }

<span class="nc bnc" id="L2084" title="All 2 branches missed.">        if (_super != null) {</span>
            // concrete superclass oid must match or be parent of ours
<span class="nc" id="L2086">            ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc" id="L2087">            Class&lt;?&gt; objectIdType = sup.getObjectIdType();</span>
<span class="nc bnc" id="L2088" title="All 2 branches missed.">            if (objectIdType != null &amp;&amp;</span>
<span class="nc bnc" id="L2089" title="All 2 branches missed.">                !objectIdType.isAssignableFrom(_objectId))</span>
<span class="nc" id="L2090">                throw new MetaDataException(_loc.get(&quot;id-classes&quot;,</span>
                    new Object[]{ _type, _objectId, _super,
<span class="nc" id="L2092">                        sup.getObjectIdType() }));</span>

            // validate that no other pks are declared if we have a
            // concrete PC superclass
<span class="nc bnc" id="L2096" title="All 2 branches missed.">            if (hasConcretePCSuperclass())</span>
<span class="nc" id="L2097">                validateNoPKFields();</span>
        }

        // if this class has its own oid class, do some more validation
<span class="nc bnc" id="L2101" title="All 2 branches missed.">        if (_super == null</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">            || _objectId != getPCSuperclassMetaData().getObjectIdType()) {</span>
            // make sure non-abstract oid classes override the proper methods
<span class="nc bnc" id="L2104" title="All 2 branches missed.">            if (!Modifier.isAbstract(_objectId.getModifiers()))</span>
<span class="nc" id="L2105">                validateAppIdClassMethods(_objectId);</span>

            // make sure the application id class has all primary key fields
<span class="nc" id="L2108">            validateAppIdClassPKs(this, pks, _objectId);</span>
        }
<span class="nc" id="L2110">    }</span>
    /**
     * Return true if this class uses IdClass derived from idClass of the
     * parent entity which annotated as id in the child class.
     * In this case, there are no key fields in the child entity corresponding
     * to the fields in the IdClass.
     */
    public boolean useIdClassFromParent() {
<span class="nc bnc" id="L2118" title="All 2 branches missed.">        if (_useIdClassFromParent == null) {</span>
<span class="nc bnc" id="L2119" title="All 2 branches missed.">            if (_objectId == null)</span>
<span class="nc" id="L2120">                _useIdClassFromParent = false;</span>
            else {
<span class="nc" id="L2122">                FieldMetaData[] pks = getPrimaryKeyFields();</span>
<span class="nc bnc" id="L2123" title="All 2 branches missed.">                if (pks.length != 1)</span>
<span class="nc" id="L2124">                    _useIdClassFromParent = false;</span>
                else {
<span class="nc" id="L2126">                    ClassMetaData pkMeta = pks[0].getTypeMetaData();</span>
<span class="nc bnc" id="L2127" title="All 2 branches missed.">                    if (pkMeta == null)</span>
<span class="nc" id="L2128">                        _useIdClassFromParent = false;</span>
                    else {
<span class="nc" id="L2130">                        Class&lt;?&gt; pkType = pkMeta.getObjectIdType();</span>
<span class="nc bnc" id="L2131" title="All 2 branches missed.">                        if (pkType == ObjectId.class) //parent id is EmbeddedId</span>
<span class="nc" id="L2132">                            pkType = pkMeta.getPrimaryKeyFields()[0].getType();</span>
<span class="nc bnc" id="L2133" title="All 2 branches missed.">                        if (pkType == _objectId)</span>
<span class="nc" id="L2134">                            _useIdClassFromParent = true;</span>
                        else {
<span class="nc" id="L2136">                            Field f = Reflection.findField(_objectId,</span>
<span class="nc" id="L2137">                                pks[0].getName(), false);</span>
<span class="nc bnc" id="L2138" title="All 2 branches missed.">                            if (f != null)</span>
<span class="nc" id="L2139">                                _useIdClassFromParent = false;</span>
                            else
<span class="nc" id="L2141">                                throw new MetaDataException(_loc.get(</span>
<span class="nc" id="L2142">                                        &quot;invalid-id&quot;, _type, pks[0].getName()));</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L2148">        return _useIdClassFromParent.booleanValue();</span>
    }

    /**
     * Return true if this class has a concrete persistent superclass.
     */
    private boolean hasConcretePCSuperclass() {
<span class="nc bnc" id="L2155" title="All 2 branches missed.">        if (_super == null)</span>
<span class="nc" id="L2156">            return false;</span>
<span class="nc bnc" id="L2157" title="All 2 branches missed.">        if (!Modifier.isAbstract(_super.getModifiers()) &amp;&amp;</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">        		(!getPCSuperclassMetaData().isAbstract()))</span>
<span class="nc" id="L2159">            return true;</span>
<span class="nc" id="L2160">        return getPCSuperclassMetaData().hasConcretePCSuperclass();</span>
    }

    /**
     * Ensure that the user has overridden the equals and hashCode methods,
     * and has the proper constructors.
     */
    private void validateAppIdClassMethods(Class&lt;?&gt; oid) {
        try {
<span class="nc" id="L2169">            oid.getConstructor((Class[]) null);</span>
<span class="nc" id="L2170">        } catch (Exception e) {</span>
<span class="nc" id="L2171">            throw new MetaDataException(_loc.get(&quot;null-cons&quot;, oid, _type)).</span>
<span class="nc" id="L2172">                setCause(e);</span>
<span class="nc" id="L2173">        }</span>

        // check for equals and hashcode overrides; don't enforce it
        // for abstract application id classes, since they may not necessarily
        // declare primary key fields
        Method method;
        try {
<span class="nc" id="L2180">            method = oid.getMethod(&quot;equals&quot;, new Class[]{ Object.class });</span>
<span class="nc" id="L2181">        } catch (Exception e) {</span>
<span class="nc" id="L2182">            throw new GeneralException(e).setFatal(true);</span>
<span class="nc" id="L2183">        }</span>

<span class="nc" id="L2185">        boolean abs = Modifier.isAbstract(_type.getModifiers());</span>
<span class="nc bnc" id="L2186" title="All 4 branches missed.">        if (!abs &amp;&amp; method.getDeclaringClass() == Object.class)</span>
<span class="nc" id="L2187">            throw new MetaDataException(_loc.get(&quot;eq-method&quot;, _type));</span>

        try {
<span class="nc" id="L2190">            method = oid.getMethod(&quot;hashCode&quot;, (Class[]) null);</span>
<span class="nc" id="L2191">        } catch (Exception e) {</span>
<span class="nc" id="L2192">            throw new GeneralException(e).setFatal(true);</span>
<span class="nc" id="L2193">        }</span>
<span class="nc bnc" id="L2194" title="All 4 branches missed.">        if (!abs &amp;&amp; method.getDeclaringClass() == Object.class)</span>
<span class="nc" id="L2195">            throw new MetaDataException(_loc.get(&quot;hc-method&quot;, _type));</span>
<span class="nc" id="L2196">    }</span>

    /**
     * Validate that the primary key class has all pk fields.
     */
    private void validateAppIdClassPKs(ClassMetaData meta,
        FieldMetaData[] fmds, Class&lt;?&gt; oid) {
<span class="nc bnc" id="L2203" title="All 4 branches missed.">        if (fmds.length == 0 &amp;&amp; !Modifier.isAbstract(meta.getDescribedType().</span>
<span class="nc" id="L2204">            getModifiers()))</span>
<span class="nc" id="L2205">            throw new MetaDataException(_loc.get(&quot;no-pk&quot;, _type));</span>

        // check that the oid type contains all pk fields
        Field f;
        Method m;
        Class&lt;?&gt; c;
<span class="nc bnc" id="L2211" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L2212" title="All 3 branches missed.">            switch (fmds[i].getDeclaredTypeCode()) {</span>
                case JavaTypes.ARRAY:
<span class="nc" id="L2214">                    c = fmds[i].getDeclaredType().getComponentType();</span>
<span class="nc bnc" id="L2215" title="All 8 branches missed.">                    if (c == byte.class || c == Byte.class</span>
                        || c == char.class || c == Character.class) {
<span class="nc" id="L2217">                        c = fmds[i].getDeclaredType();</span>
<span class="nc" id="L2218">                        break;</span>
                    }
                    // else no break
                case JavaTypes.PC_UNTYPED:
                case JavaTypes.COLLECTION:
                case JavaTypes.MAP:
                case JavaTypes.OID: // we're validating embedded fields
<span class="nc" id="L2225">                    throw new MetaDataException(_loc.get(&quot;bad-pk-type&quot;,</span>
                        fmds[i]));
                default:
<span class="nc" id="L2228">                    c = fmds[i].getObjectIdFieldType();</span>
            }

<span class="nc bnc" id="L2231" title="All 2 branches missed.">            if (AccessCode.isField(fmds[i].getAccessType())) {</span>
<span class="nc" id="L2232">                f = Reflection.findField(oid, fmds[i].getName(), false);</span>
<span class="nc bnc" id="L2233" title="All 4 branches missed.">                if (f == null || !f.getType().isAssignableFrom(c))</span>
<span class="nc" id="L2234">                    throw new MetaDataException(_loc.get(&quot;invalid-id&quot;,</span>
<span class="nc" id="L2235">                        _type, fmds[i].getName()));</span>
<span class="nc bnc" id="L2236" title="All 2 branches missed.">            } else if (AccessCode.isProperty(fmds[i].getAccessType())) {</span>
<span class="nc" id="L2237">                m = Reflection.findGetter(oid, fmds[i].getName(), false);</span>
<span class="nc bnc" id="L2238" title="All 4 branches missed.">                if (m == null || !m.getReturnType().isAssignableFrom(c))</span>
<span class="nc" id="L2239">                    throw new MetaDataException(_loc.get(&quot;invalid-id&quot;,</span>
<span class="nc" id="L2240">                        _type, fmds[i].getName()));</span>
<span class="nc" id="L2241">                m = Reflection.findSetter(oid, fmds[i].getName(),</span>
<span class="nc" id="L2242">                    fmds[i].getObjectIdFieldType(), false);</span>
<span class="nc bnc" id="L2243" title="All 4 branches missed.">                if (m == null || m.getReturnType() != void.class)</span>
<span class="nc" id="L2244">                    throw new MetaDataException(_loc.get(&quot;invalid-id&quot;,</span>
<span class="nc" id="L2245">                        _type, fmds[i].getName()));</span>
            }
        }
<span class="nc" id="L2248">    }</span>

    /**
     * Validate that this class doesn't declare any primary key fields.
     */
    private void validateNoPKFields() {
<span class="nc" id="L2254">        FieldMetaData[] fields = getDeclaredFields();</span>
<span class="nc bnc" id="L2255" title="All 2 branches missed.">        for (int i = 0; i &lt; fields.length; i++)</span>
<span class="nc bnc" id="L2256" title="All 2 branches missed.">            if (fields[i].isPrimaryKey())</span>
<span class="nc" id="L2257">                throw new MetaDataException(_loc.get(&quot;bad-pk&quot;, fields[i]));</span>
<span class="nc" id="L2258">    }</span>

    /**
     * Assert that this class' access type is allowed.
     * If no access style is set or an explicit style is set return.
     * Otherwise, if the superclass has persistent attributes,  check that
     * the superclass access style, if defaulted, is the same as that of this
     * receiver.
     */
    private void validateAccessType() {
<span class="nc bnc" id="L2268" title="All 2 branches missed.">        if (AccessCode.isEmpty(_accessType)</span>
<span class="nc bnc" id="L2269" title="All 2 branches missed.">           || AccessCode.isExplicit(_accessType))</span>
<span class="nc" id="L2270">            return;</span>
<span class="nc" id="L2271">        ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L2272" title="All 4 branches missed.">        while (sup != null &amp;&amp; sup.isExplicitAccess())</span>
<span class="nc" id="L2273">        	sup = sup.getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L2274" title="All 4 branches missed.">        if (sup != null &amp;&amp; sup.getDeclaredFields().length &gt; 0) {</span>
<span class="nc" id="L2275">        	int supCode = sup.getAccessType();</span>
<span class="nc bnc" id="L2276" title="All 2 branches missed.">        	if (!AccessCode.isCompatibleSuper(_accessType, supCode))</span>
<span class="nc" id="L2277">             throw new MetaDataException(_loc.get(&quot;access-inconsistent-inherit&quot;,</span>
<span class="nc" id="L2278">             new Object[]{this, AccessCode.toClassString(_accessType),</span>
<span class="nc" id="L2279">                          sup, AccessCode.toClassString(supCode)}).toString());</span>
        }
<span class="nc" id="L2281">    }</span>

    /**
     * Assert that detachment configuration is valid.
     */
    private void validateDetachable() {
<span class="nc" id="L2287">        boolean first = true;</span>
<span class="nc" id="L2288">        for (ClassMetaData parent = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L2289" title="All 4 branches missed.">            first &amp;&amp; parent != null; parent = parent.getPCSuperclassMetaData())</span>
        {
<span class="nc bnc" id="L2291" title="All 2 branches missed.">            if (parent.isDetachable())</span>
<span class="nc" id="L2292">                first = false;</span>
        }

<span class="nc" id="L2295">        Field field = getDetachedStateField();</span>
<span class="nc bnc" id="L2296" title="All 2 branches missed.">        if (field != null) {</span>
<span class="nc bnc" id="L2297" title="All 2 branches missed.">            if (!first)</span>
<span class="nc" id="L2298">                throw new MetaDataException(_loc.get(&quot;parent-detach-state&quot;,</span>
                    _type));
<span class="nc bnc" id="L2300" title="All 2 branches missed.">            if (getField(field.getName()) != null)</span>
<span class="nc" id="L2301">                throw new MetaDataException(_loc.get(&quot;managed-detach-state&quot;,</span>
<span class="nc" id="L2302">                    field.getName(), _type));</span>
<span class="nc bnc" id="L2303" title="All 2 branches missed.">            if (field.getType() != Object.class)</span>
<span class="nc" id="L2304">                throw new MetaDataException(_loc.get(&quot;bad-detach-state&quot;,</span>
<span class="nc" id="L2305">                    field.getName(), _type));</span>
        }
<span class="nc" id="L2307">    }</span>

    ///////////////
    // Fetch Group
    ///////////////

    /**
     * Return the fetch groups declared explicitly in this type.
     */
    public FetchGroup[] getDeclaredFetchGroups() {
<span class="nc bnc" id="L2317" title="All 2 branches missed.">        if (_fgs == null) {</span>
<span class="nc bnc" id="L2318" title="All 2 branches missed.">            _fgs = (_fgMap == null) ? EMPTY_FETCH_GROUP_ARRAY : _fgMap.values().toArray(new FetchGroup[_fgMap.size()]);</span>
        }
<span class="nc" id="L2320">        return _fgs;</span>
    }

    /**
     * Return all fetch groups for this type, including superclass groups but excluding the standard groups
     * such as &quot;default&quot; or &quot;all&quot;.
     */
    public FetchGroup[] getCustomFetchGroups() {
<span class="nc bnc" id="L2328" title="All 2 branches missed.">        if (_customFGs == null) {</span>
            // map fetch groups to names, allowing our groups to override super
<span class="nc" id="L2330">            Map&lt;String,FetchGroup&gt; fgs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2331">            ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">            if (sup != null) {</span>
<span class="nc" id="L2333">                FetchGroup[] supFGs = sup.getCustomFetchGroups();</span>
<span class="nc bnc" id="L2334" title="All 2 branches missed.">                for (int i = 0; i &lt; supFGs.length; i++) {</span>
<span class="nc" id="L2335">                    fgs.put(supFGs[i].getName(), supFGs[i]);</span>
                }
            }
<span class="nc" id="L2338">            FetchGroup[] decs = getDeclaredFetchGroups();</span>
<span class="nc bnc" id="L2339" title="All 2 branches missed.">            for (int i = 0; i &lt; decs.length; i++) {</span>
<span class="nc" id="L2340">                fgs.put(decs[i].getName(), decs[i]);</span>
            }
            // remove standard groups
<span class="nc" id="L2343">            fgs.remove(FetchGroup.NAME_DEFAULT);</span>
<span class="nc" id="L2344">            fgs.remove(FetchGroup.NAME_ALL);</span>

<span class="nc" id="L2346">            _customFGs = fgs.values().toArray(new FetchGroup[fgs.size()]);</span>
        }
<span class="nc" id="L2348">        return _customFGs;</span>
    }

    /**
     * Gets a named fetch group. If not available in this receiver then looks
     * up the inheritance hierarchy.
     *
     * @param name name of a fetch group.
     * @return an existing fetch group of the given name if known to this
     * receiver or any of its superclasses. Otherwise null.
     */
    public FetchGroup getFetchGroup(String name) {
<span class="nc bnc" id="L2360" title="All 2 branches missed.">        FetchGroup fg = (_fgMap == null) ? null : _fgMap.get(name);</span>
<span class="nc bnc" id="L2361" title="All 2 branches missed.">        if (fg != null)</span>
<span class="nc" id="L2362">            return fg;</span>
<span class="nc" id="L2363">        ClassMetaData sup = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L2364" title="All 2 branches missed.">        if (sup != null)</span>
<span class="nc" id="L2365">            return sup.getFetchGroup(name);</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">        if (FetchGroup.NAME_DEFAULT.equals(name))</span>
<span class="nc" id="L2367">            return FetchGroup.DEFAULT;</span>
<span class="nc bnc" id="L2368" title="All 2 branches missed.">        if (FetchGroup.NAME_ALL.equals(name))</span>
<span class="nc" id="L2369">            return FetchGroup.ALL;</span>
<span class="nc" id="L2370">        return null;</span>
    }

    /**
     * Adds fetch group of the given name, or returns existing instance.
     *
     * @param name a non-null, non-empty name. Must be unique within this
     * receiver's scope. The super class &lt;em&gt;may&lt;/em&gt; have a group with
     * the same name.
     */
    public FetchGroup addDeclaredFetchGroup(String name) {
<span class="nc bnc" id="L2381" title="All 2 branches missed.">    	if (StringUtil.isEmpty(name))</span>
<span class="nc" id="L2382">    		throw new MetaDataException(_loc.get(&quot;empty-fg-name&quot;, this));</span>
<span class="nc bnc" id="L2383" title="All 2 branches missed.">        if (_fgMap == null)</span>
<span class="nc" id="L2384">            _fgMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2385">        FetchGroup fg = _fgMap.get(name);</span>
<span class="nc bnc" id="L2386" title="All 2 branches missed.">        if (fg == null) {</span>
<span class="nc" id="L2387">        	fg = new FetchGroup(this, name);</span>
<span class="nc" id="L2388">        	_fgMap.put(name, fg);</span>
<span class="nc" id="L2389">            _fgs = null;</span>
<span class="nc" id="L2390">            _customFGs = null;</span>
        }
<span class="nc" id="L2392">        return fg;</span>
    }

    /**
     * Remove a declared fetch group.
     */
    public boolean removeDeclaredFetchGroup(FetchGroup fg) {
<span class="nc bnc" id="L2399" title="All 2 branches missed.">        if (fg == null)</span>
<span class="nc" id="L2400">            return false;</span>
<span class="nc bnc" id="L2401" title="All 2 branches missed.">        if (_fgMap.remove(fg.getName()) != null) {</span>
<span class="nc" id="L2402">            _fgs = null;</span>
<span class="nc" id="L2403">            _customFGs = null;</span>
<span class="nc" id="L2404">            return true;</span>
        }
<span class="nc" id="L2406">        return false;</span>
    }

    /////////////////
    // SourceTracker
    /////////////////

    @Override
    public File getSourceFile() {
<span class="nc" id="L2415">        return _srcFile;</span>
    }

    @Override
    public Object getSourceScope() {
<span class="nc" id="L2420">        return null;</span>
    }

    @Override
    public int getSourceType() {
<span class="nc" id="L2425">        return _srcType;</span>
    }

    public void setSource(File file, int srcType, String srcName) {
<span class="nc" id="L2429">        _srcFile = file;</span>
<span class="nc" id="L2430">        _srcType = srcType;</span>
<span class="nc" id="L2431">        _srcName = srcName;</span>
<span class="nc" id="L2432">    }</span>

    @Override
    public String getResourceName() {
<span class="nc" id="L2436">        return _type.getName();</span>
    }

    @Override
    public int getLineNumber() {
<span class="nc" id="L2441">        return _lineNum;</span>
    }

    public void setLineNumber(int lineNum) {
<span class="nc" id="L2445">        _lineNum = lineNum;</span>
<span class="nc" id="L2446">    }</span>

    @Override
    public int getColNumber() {
<span class="nc" id="L2450">        return _colNum;</span>
    }

    public void setColNumber(int colNum) {
<span class="nc" id="L2454">        _colNum = colNum;</span>
<span class="nc" id="L2455">    }</span>


    /**
     * The source mode this metadata has been loaded under.
     */
    public int getSourceMode() {
<span class="nc" id="L2462">        return _srcMode;</span>
    }

    /**
     * The source mode this metadata has been loaded under.
     */
    public void setSourceMode(int mode) {
<span class="nc" id="L2469">        _srcMode = mode;</span>
<span class="nc" id="L2470">    }</span>

    /**
     * The source mode this metadata has been loaded under.
     */
    public void setSourceMode(int mode, boolean on) {
<span class="nc bnc" id="L2476" title="All 2 branches missed.">        if (mode == MODE_NONE)</span>
<span class="nc" id="L2477">            _srcMode = mode;</span>
<span class="nc bnc" id="L2478" title="All 2 branches missed.">        else if (on)</span>
<span class="nc" id="L2479">            _srcMode |= mode;</span>
        else
<span class="nc" id="L2481">            _srcMode &amp;= ~mode;</span>
<span class="nc" id="L2482">    }</span>

    /**
     * The index in which this class was listed in the metadata. Defaults to
     * &lt;code&gt;-1&lt;/code&gt; if this class was not listed in the metadata.
     */
    public int getListingIndex() {
<span class="nc" id="L2489">        return _listIndex;</span>
    }

    /**
     * The index in which this field was listed in the metadata. Defaults to
     * &lt;code&gt;-1&lt;/code&gt; if this class was not listed in the metadata.
     */
    public void setListingIndex(int index) {
<span class="nc" id="L2497">        _listIndex = index;</span>
<span class="nc" id="L2498">    }</span>

    ///////////////
    // Commentable
    ///////////////

    @Override
    public String[] getComments() {
<span class="nc bnc" id="L2506" title="All 2 branches missed.">        return (_comments == null) ? EMPTY_COMMENTS : _comments;</span>
    }

    @Override
    public void setComments(String[] comments) {
<span class="nc" id="L2511">        _comments = comments;</span>
<span class="nc" id="L2512">    }</span>

    //////////////
    // State copy
    //////////////

    /**
     * Copy the metadata from the given instance to this one. Do not
     * copy mapping information.
     */
    public void copy(ClassMetaData meta) {
<span class="nc bnc" id="L2523" title="All 2 branches missed.">        if (meta.getDescribedType() != _type)</span>
<span class="nc" id="L2524">            throw new InternalException();</span>
<span class="nc" id="L2525">        super.copy(meta);</span>

        // copy class-level info; use get methods to force resolution of
        // lazy data
<span class="nc" id="L2529">        _super = meta.getPCSuperclass();</span>
<span class="nc" id="L2530">        _objectId = meta.getObjectIdType();</span>
<span class="nc" id="L2531">        _idClass = meta.getIdClass();</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">        _extent = (meta.getRequiresExtent()) ? Boolean.TRUE : Boolean.FALSE;</span>
<span class="nc bnc" id="L2533" title="All 2 branches missed.">        _embedded = (meta.isEmbeddedOnly()) ? Boolean.TRUE : Boolean.FALSE;</span>
<span class="nc" id="L2534">        _embeddable = meta._embeddable;</span>
<span class="nc bnc" id="L2535" title="All 2 branches missed.">        _interface = (meta.isManagedInterface()) ? Boolean.TRUE : Boolean.FALSE;</span>
<span class="nc" id="L2536">        setIntercepting(meta.isIntercepting());</span>
<span class="nc" id="L2537">        _abstract = meta.isAbstract();</span>
<span class="nc" id="L2538">        _impl = meta.getInterfaceImpl();</span>
<span class="nc bnc" id="L2539" title="All 2 branches missed.">        _identity = meta._identity == null ? null : meta.getIdentityType();</span>
<span class="nc" id="L2540">        _idStrategy = meta.getIdentityStrategy();</span>
<span class="nc" id="L2541">        _seqName = meta.getIdentitySequenceName();</span>
<span class="nc" id="L2542">        _seqMeta = null;</span>
<span class="nc" id="L2543">        _alias = meta.getTypeAlias();</span>
<span class="nc" id="L2544">        _accessType = meta.getAccessType();</span>

        // only copy this information if it wasn't set explicitly for this
        // instance
<span class="nc bnc" id="L2548" title="All 2 branches missed.">        if (DEFAULT_STRING.equals(_cacheName))</span>
<span class="nc" id="L2549">            _cacheName = meta.getDataCacheName();</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">        if (_cacheTimeout == Integer.MIN_VALUE)</span>
<span class="nc" id="L2551">            _cacheTimeout = meta.getDataCacheTimeout();</span>
<span class="nc" id="L2552">        _cacheEnabled = meta.getCacheEnabled();</span>
<span class="nc" id="L2553">        _dataCacheEnabled = meta.getDataCacheEnabled();</span>
<span class="nc bnc" id="L2554" title="All 2 branches missed.">        if (_detachable == null)</span>
<span class="nc" id="L2555">            _detachable = meta._detachable;</span>
<span class="nc bnc" id="L2556" title="All 2 branches missed.">        if (DEFAULT_STRING.equals(_detachState))</span>
<span class="nc" id="L2557">            _detachState = meta.getDetachedState();</span>

        // synch field information; first remove extra fields
<span class="nc" id="L2560">        clearFieldCache();</span>
<span class="nc" id="L2561">        _fieldMap.keySet().retainAll(meta._fieldMap.keySet());</span>

        // add copies of declared fields; other defined fields already copied
<span class="nc" id="L2564">        FieldMetaData[] fields = meta.getDeclaredFields();</span>
        FieldMetaData field;
<span class="nc bnc" id="L2566" title="All 2 branches missed.">        for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc" id="L2567">            field = getDeclaredField(fields[i].getName());</span>
<span class="nc bnc" id="L2568" title="All 2 branches missed.">            if (field == null)</span>
<span class="nc" id="L2569">                field = addDeclaredField(fields[i].getName(),</span>
<span class="nc" id="L2570">                    fields[i].getDeclaredType());</span>
<span class="nc" id="L2571">            field.setDeclaredIndex(-1);</span>
<span class="nc" id="L2572">            field.setIndex(-1);</span>
<span class="nc" id="L2573">            field.copy(fields[i]);</span>
        }

        // copy fetch groups
<span class="nc" id="L2577">        FetchGroup[] fgs = meta.getDeclaredFetchGroups();</span>
        FetchGroup fg;
<span class="nc bnc" id="L2579" title="All 2 branches missed.">        for (int i = 0; i &lt; fgs.length; i++) {</span>
<span class="nc" id="L2580">            fg = addDeclaredFetchGroup(fgs[i].getName());</span>
<span class="nc" id="L2581">            fg.copy(fgs[i]);</span>
        }

        // copy interface re-mapping
<span class="nc" id="L2585">        _ifaceMap.clear();</span>
<span class="nc" id="L2586">        _ifaceMap.putAll(meta._ifaceMap);</span>
<span class="nc" id="L2587">    }</span>

    /**
     * Recursive helper to copy embedded metadata.
     */
    private static void copy(ClassMetaData embed, ClassMetaData dec) {
<span class="nc" id="L2593">        ClassMetaData sup = dec.getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L2594" title="All 2 branches missed.">        if (sup != null) {</span>
<span class="nc" id="L2595">            embed.setPCSuperclass(sup.getDescribedType());</span>
<span class="nc" id="L2596">            copy(embed.getPCSuperclassMetaData(), sup);</span>
        }
<span class="nc" id="L2598">        embed.copy(dec);</span>
<span class="nc" id="L2599">    }</span>

    @Override
    protected void addExtensionKeys(Collection exts) {
<span class="nc" id="L2603">        _repos.getMetaDataFactory().addClassExtensionKeys(exts);</span>
<span class="nc" id="L2604">    }</span>

    /**
     * Comparator used to put field metadata into listing order.
     */
    private static class ListingOrderComparator
        implements Comparator&lt;FieldMetaData&gt; {

<span class="nc" id="L2612">        private static final ListingOrderComparator _instance</span>
            = new ListingOrderComparator();

        /**
         * Access singleton instance.
         */
        public static ListingOrderComparator getInstance() {
<span class="nc" id="L2619">            return _instance;</span>
        }

        @Override
        public int compare(FieldMetaData f1, FieldMetaData f2) {
<span class="nc bnc" id="L2624" title="All 2 branches missed.">            if (f1 == f2)</span>
<span class="nc" id="L2625">                return 0;</span>
<span class="nc bnc" id="L2626" title="All 2 branches missed.">            if (f1 == null)</span>
<span class="nc" id="L2627">                return 1;</span>
<span class="nc bnc" id="L2628" title="All 2 branches missed.">            if (f2 == null)</span>
<span class="nc" id="L2629">                return -1;</span>

<span class="nc bnc" id="L2631" title="All 2 branches missed.">            if (f1.getListingIndex() == f2.getListingIndex()) {</span>
<span class="nc bnc" id="L2632" title="All 2 branches missed.">                if (f1.getIndex() == f2.getIndex())</span>
<span class="nc" id="L2633">                    return f1.getFullName(false).compareTo</span>
<span class="nc" id="L2634">                        (f2.getFullName(false));</span>
<span class="nc bnc" id="L2635" title="All 2 branches missed.">				if (f1.getIndex () == -1)</span>
<span class="nc" id="L2636">					return 1;</span>
<span class="nc bnc" id="L2637" title="All 2 branches missed.">				if (f2.getIndex () == -1)</span>
<span class="nc" id="L2638">					return -1;</span>
<span class="nc" id="L2639">				return f1.getIndex () - f2.getIndex ();</span>
			}
<span class="nc bnc" id="L2641" title="All 2 branches missed.">			if (f1.getListingIndex () == -1)</span>
<span class="nc" id="L2642">				return 1;</span>
<span class="nc bnc" id="L2643" title="All 2 branches missed.">			if (f2.getListingIndex () == -1)</span>
<span class="nc" id="L2644">				return -1;</span>
<span class="nc" id="L2645">			return f1.getListingIndex () - f2.getListingIndex ();</span>
		}
	}

    public void registerForValueUpdate(String...values) {
<span class="nc bnc" id="L2650" title="All 2 branches missed.">    	if (values == null)</span>
<span class="nc" id="L2651">    		return;</span>
<span class="nc bnc" id="L2652" title="All 2 branches missed.">    	for (String key : values) {</span>
<span class="nc" id="L2653">    		Value value = getRepository().getConfiguration()</span>
<span class="nc" id="L2654">    			.getValue(key);</span>
<span class="nc bnc" id="L2655" title="All 2 branches missed.">    		if (value != null)</span>
<span class="nc" id="L2656">    			value.addListener(this);</span>
    	}
<span class="nc" id="L2658">    }</span>

    @Override
    public void valueChanged(Value val) {
<span class="nc bnc" id="L2662" title="All 4 branches missed.">    	if (val != null &amp;&amp; val.matches(&quot;DataCacheTimeout&quot;)) {</span>
<span class="nc" id="L2663">    		_cacheTimeout = Integer.MIN_VALUE;</span>
    	}
<span class="nc" id="L2665">    }</span>

    /**
     * Utility method to get names of all fields including the superclasses'
     * sorted in lexical order.
     */
    public String[] getFieldNames() {
<span class="nc" id="L2672">    	return toNames(getFields());</span>
    }

    /**
     * Utility method to get names of all declared fields excluding the
     * superclasses' sorted in lexical order.
     */
    public String[] getDeclaredFieldNames() {
<span class="nc" id="L2680">    	return toNames(getDeclaredFields());</span>
    }

    String[] toNames(FieldMetaData[] fields) {
<span class="nc" id="L2684">    	List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2685" title="All 2 branches missed.">    	for (FieldMetaData fmd : fields) {</span>
<span class="nc" id="L2686">    		result.add(fmd.getName());</span>
    	}
<span class="nc" id="L2688">    	Collections.sort(result);</span>
<span class="nc" id="L2689">    	return result.toArray(new String[result.size()]);</span>
    }


    public boolean isAbstract() {
<span class="nc" id="L2694">        return _abstract;</span>
    }

    public void setAbstract(boolean flag) {
<span class="nc" id="L2698">        _abstract = flag;</span>
<span class="nc" id="L2699">    }</span>

    /**
     * Convenience method to determine if the pcType modeled by
     * this ClassMetaData object is both abstract and declares PKFields. This
     * method is used by the PCEnhancer to determine if special handling is
     * required.
     *
     */
    public boolean hasAbstractPKField() {
<span class="nc bnc" id="L2709" title="All 2 branches missed.">        if (_hasAbstractPKField != null) {</span>
<span class="nc" id="L2710">            return _hasAbstractPKField.booleanValue();</span>
        }

        // Default to false, set to true only if this type is abstract and
        // declares a PKField.
<span class="nc" id="L2715">        Boolean temp = Boolean.FALSE;</span>

<span class="nc bnc" id="L2717" title="All 2 branches missed.">        if (isAbstract() == true) {</span>
<span class="nc" id="L2718">            FieldMetaData[] declaredFields = getDeclaredFields();</span>
<span class="nc bnc" id="L2719" title="All 4 branches missed.">            if (declaredFields != null &amp;&amp; declaredFields.length != 0) {</span>
<span class="nc bnc" id="L2720" title="All 2 branches missed.">                for (FieldMetaData fmd : declaredFields) {</span>
<span class="nc bnc" id="L2721" title="All 2 branches missed.">                    if (fmd.isPrimaryKey()) {</span>
<span class="nc" id="L2722">                        temp = Boolean.TRUE;</span>
<span class="nc" id="L2723">                        break;</span>
                    }
                }
            }
        }
<span class="nc" id="L2728">        _hasAbstractPKField = temp;</span>

<span class="nc" id="L2730">        return _hasAbstractPKField.booleanValue();</span>
    }

    /**
     * Convenience method to determine if this type is a direct
     * decendent of an abstract type declaring PKFields. Returns true if there
     * are no pcTypes mapped to a table between this type and an abstract pcType
     * declaring PKFields. Returns false if there no such abstract pcTypes in
     * the inheritance hierarchy or if there are any pcTypes mapped to tables in
     * between the type represented by this ClassMetaData object and the
     * abstract pcType declaring PKFields.
     *
     */
    public boolean hasPKFieldsFromAbstractClass() {
<span class="nc bnc" id="L2744" title="All 2 branches missed.">        if (_hasPKFieldsFromAbstractClass != null) {</span>
<span class="nc" id="L2745">            return _hasPKFieldsFromAbstractClass.booleanValue();</span>
        }

        // Default to FALSE, until proven true.
<span class="nc" id="L2749">        Boolean temp = Boolean.FALSE;</span>

<span class="nc" id="L2751">        FieldMetaData[] pkFields = getPrimaryKeyFields();</span>
<span class="nc bnc" id="L2752" title="All 2 branches missed.">        for (FieldMetaData fmd : pkFields) {</span>
<span class="nc" id="L2753">            ClassMetaData fmdDMDA = fmd.getDeclaringMetaData();</span>
<span class="nc bnc" id="L2754" title="All 2 branches missed.">            if (fmdDMDA.isAbstract()) {</span>
<span class="nc" id="L2755">                ClassMetaData cmd = getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L2756" title="All 2 branches missed.">                while (cmd != fmdDMDA) {</span>
<span class="nc bnc" id="L2757" title="All 2 branches missed.">                    if (fmdDMDA.isAbstract()) {</span>
<span class="nc" id="L2758">                        cmd = cmd.getPCSuperclassMetaData();</span>
                    } else {
                        break;
                    }
                }
<span class="nc bnc" id="L2763" title="All 2 branches missed.">                if (cmd == fmdDMDA) {</span>
<span class="nc" id="L2764">                    temp = Boolean.TRUE;</span>
<span class="nc" id="L2765">                    break;</span>
                }
            }
        }
<span class="nc" id="L2769">        _hasPKFieldsFromAbstractClass = temp;</span>

<span class="nc" id="L2771">        return _hasPKFieldsFromAbstractClass.booleanValue();</span>
    }

    /**
     * Sets the eligibility status of this class for cache.
     *
     */
    public void setCacheEnabled(boolean enabled) {
<span class="nc" id="L2779">        _cacheEnabled = enabled;</span>
<span class="nc" id="L2780">    }</span>

    /**
     * Returns tri-state status on whether this class has been enabled for caching.
     *
     * @return TRUE or FALSE denote this class has been explicitly enabled or disabled for caching.
     * If no status has been explicitly set, then the status of the persistent super class, if any, is returned.
     */
    public Boolean getCacheEnabled() {
<span class="nc bnc" id="L2789" title="All 2 branches missed.">        if (_cacheEnabled != null)</span>
<span class="nc" id="L2790">            return _cacheEnabled;</span>
<span class="nc bnc" id="L2791" title="All 2 branches missed.">        return getPCSuperclassMetaData() != null ?  getPCSuperclassMetaData().getCacheEnabled() : null;</span>
    }

    public String getSourceName(){
<span class="nc" id="L2795">        return _srcName;</span>
    }

    public int[] getPkAndNonPersistentManagedFmdIndexes() {
<span class="nc bnc" id="L2799" title="All 2 branches missed.">        if (_pkAndNonPersistentManagedFmdIndexes == null) {</span>
<span class="nc" id="L2800">            List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2801" title="All 2 branches missed.">            for (FieldMetaData fmd : getFields()) {</span>
<span class="nc bnc" id="L2802" title="All 4 branches missed.">                if (fmd.isPrimaryKey() || fmd.getManagement() != FieldMetaData.MANAGE_PERSISTENT) {</span>
<span class="nc" id="L2803">                    ids.add(fmd.getIndex());</span>
                }
            }
<span class="nc" id="L2806">            int idsSize = ids.size();</span>
<span class="nc" id="L2807">            int[] temp = new int[idsSize];</span>
<span class="nc bnc" id="L2808" title="All 2 branches missed.">            for (int i = 0; i &lt; idsSize; i++) {</span>
<span class="nc" id="L2809">                temp[i] = ids.get(i).intValue();</span>
            }
<span class="nc" id="L2811">            _pkAndNonPersistentManagedFmdIndexes = temp;</span>
        }
<span class="nc" id="L2813">        return _pkAndNonPersistentManagedFmdIndexes;</span>
    }

    public boolean hasInverseManagedFields() {
<span class="nc bnc" id="L2817" title="All 2 branches missed.">        if (inverseManagedFields == null) {</span>
<span class="nc" id="L2818">            Boolean res = Boolean.FALSE;</span>
<span class="nc bnc" id="L2819" title="All 2 branches missed.">            for (FieldMetaData fmd : getFields()) {</span>
<span class="nc bnc" id="L2820" title="All 2 branches missed.">                if (fmd.getInverseMetaDatas().length &gt; 0) {</span>
<span class="nc" id="L2821">                    res = Boolean.TRUE;</span>
<span class="nc" id="L2822">                    break;</span>
                }
            }
<span class="nc" id="L2825">            inverseManagedFields = res;</span>
        }
<span class="nc" id="L2827">        return inverseManagedFields.booleanValue();</span>
    }

    public List&lt;FieldMetaData&gt; getMappyedByIdFields() {
<span class="nc bnc" id="L2831" title="All 2 branches missed.">        if (!_mappedByIdFieldsSet) {</span>
<span class="nc" id="L2832">            List&lt;FieldMetaData&gt; fmdArray = null;</span>
<span class="nc bnc" id="L2833" title="All 2 branches missed.">            for (FieldMetaData fmd : getFields()) {</span>
<span class="nc bnc" id="L2834" title="All 2 branches missed.">                if (getIdentityType() == ClassMetaData.ID_APPLICATION) {</span>
<span class="nc" id="L2835">                    String mappedByIdValue = fmd.getMappedByIdValue();</span>
<span class="nc bnc" id="L2836" title="All 2 branches missed.">                    if (mappedByIdValue != null) {</span>
<span class="nc bnc" id="L2837" title="All 2 branches missed.">                        if (fmdArray == null) {</span>
<span class="nc" id="L2838">                            fmdArray = new ArrayList&lt;&gt;();</span>
                        }
<span class="nc" id="L2840">                        fmdArray.add(fmd);</span>
                    }
                }
            }
<span class="nc" id="L2844">            _mappedByIdFields = fmdArray;</span>
<span class="nc" id="L2845">            _mappedByIdFieldsSet = true;</span>
        }
<span class="nc" id="L2847">        return _mappedByIdFields;</span>
    }

    /**
     * Set whether to include schema name in generated class files
     */
    public boolean getUseSchemaElement() {
<span class="nc" id="L2854">        return _useSchemaElement;</span>
    }

    /**
     * Get whether to include schema name in generated class files
     */
    public void setUseSchemaElement(boolean useSchemaElement) {
<span class="nc" id="L2861">        this._useSchemaElement = useSchemaElement;</span>
<span class="nc" id="L2862">    }</span>

    /**
     * The class specified with the @IdClass annotation if used
     */
    public Class&lt;?&gt; getIdClass() {
<span class="nc" id="L2868">        return _idClass;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>