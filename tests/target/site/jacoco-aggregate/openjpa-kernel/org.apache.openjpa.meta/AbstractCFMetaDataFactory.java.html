<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractCFMetaDataFactory.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-kernel</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.meta</a> &gt; <span class="el_source">AbstractCFMetaDataFactory.java</span></div><h1>AbstractCFMetaDataFactory.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.meta;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.PrivilegedActionException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;

import org.apache.openjpa.conf.OpenJPAConfiguration;
import org.apache.openjpa.conf.OpenJPAConfigurationImpl;
import org.apache.openjpa.lib.meta.ClassArgParser;
import org.apache.openjpa.lib.meta.ClasspathMetaDataIterator;
import org.apache.openjpa.lib.meta.FileMetaDataIterator;
import org.apache.openjpa.lib.meta.JarFileURLMetaDataIterator;
import org.apache.openjpa.lib.meta.MetaDataFilter;
import org.apache.openjpa.lib.meta.MetaDataIterator;
import org.apache.openjpa.lib.meta.MetaDataParser;
import org.apache.openjpa.lib.meta.MetaDataSerializer;
import org.apache.openjpa.lib.meta.ResourceMetaDataIterator;
import org.apache.openjpa.lib.meta.URLMetaDataIterator;
import org.apache.openjpa.lib.meta.ZipFileMetaDataIterator;
import org.apache.openjpa.lib.meta.ZipStreamMetaDataIterator;
import org.apache.openjpa.lib.util.ClassUtil;
import org.apache.openjpa.lib.util.Files;
import org.apache.openjpa.lib.util.J2DoPrivHelper;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.lib.util.StringUtil;
import org.apache.openjpa.util.GeneralException;
import org.apache.openjpa.util.UserException;

/**
 * Base class for factory implementations built around XML metadata files
 * in the common format.
 *
 * @author Abe White
 * @since 0.4.0
 */
<span class="nc" id="L74">public abstract class AbstractCFMetaDataFactory</span>
    extends AbstractMetaDataFactory {

<span class="nc" id="L77">    private static final Localizer _loc = Localizer.forPackage</span>
<span class="nc" id="L78">        (AbstractMetaDataFactory.class);</span>

<span class="nc" id="L80">    protected Collection&lt;File&gt; files = null;</span>
<span class="nc" id="L81">    protected Collection&lt;URL&gt; urls = null;</span>
<span class="nc" id="L82">    protected Collection&lt;String&gt; rsrcs = null;</span>
<span class="nc" id="L83">    protected Collection&lt;String&gt; cpath = null;</span>

<span class="nc" id="L85">    private Set&lt;String&gt; _typeNames = null;</span>
    public static final String PERSISTENCE_UNIT_ROOT_URL = &quot;PersistenceUnitRootUrl&quot;;
    public static final String MAPPING_FILE_NAMES = &quot;MappingFileNames&quot;;
    public static final String JAR_FILE_URLS = &quot;JarFiles&quot;;

    /**
     * Set of {@link File}s of metadata files or directories supplied by user.
     */
    public void setFiles(Collection&lt;File&gt; files) {
<span class="nc" id="L94">        this.files = files;</span>
<span class="nc" id="L95">    }</span>

    /**
     * Set of semicolon-separated {@link File}s of metadata files or
     * directories supplied by user via auto-configuration.
     */
    public void setFiles(String files) {
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (StringUtil.isEmpty(files))</span>
<span class="nc" id="L103">            this.files = null;</span>
        else {
<span class="nc" id="L105">            String[] strs = StringUtil.split(files, &quot;;&quot;, 0);</span>
<span class="nc" id="L106">            this.files = new HashSet&lt;&gt;((int) (strs.length * 1.33 + 1));</span>

            File file;
<span class="nc bnc" id="L109" title="All 2 branches missed.">            for (int i = 0; i &lt; strs.length; i++) {</span>
<span class="nc" id="L110">                file = new File(strs[i]);</span>
<span class="nc" id="L111">                if ((AccessController.doPrivileged(</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">                    J2DoPrivHelper.existsAction(file))).booleanValue())</span>
<span class="nc" id="L113">                    this.files.add(file);</span>
            }
        }
<span class="nc" id="L116">    }</span>

    /**
     * Set of {@link URL}s of metadata files or jars supplied by user.
     */
    public void setURLs(Collection&lt;URL&gt; urls) {
<span class="nc" id="L122">        this.urls = urls;</span>
<span class="nc" id="L123">    }</span>

    /**
     * Set of semicolon-separated {@link URL}s of metadata files or jars
     * supplied by user via auto-configuration.
     */
    public void setURLs(String urls) {
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (StringUtil.isEmpty(urls))</span>
<span class="nc" id="L131">            this.urls = null;</span>
        else {
<span class="nc" id="L133">            String[] strs = StringUtil.split(urls, &quot;;&quot;, 0);</span>
<span class="nc" id="L134">            this.urls = new HashSet&lt;&gt;((int) (strs.length * 1.33 + 1));</span>
            try {
<span class="nc bnc" id="L136" title="All 2 branches missed.">                for (int i = 0; i &lt; strs.length; i++)</span>
<span class="nc" id="L137">                    this.urls.add(new URL(strs[i]));</span>
<span class="nc" id="L138">            } catch (MalformedURLException mue) {</span>
<span class="nc" id="L139">                throw new UserException(mue);</span>
<span class="nc" id="L140">            }</span>
        }
<span class="nc" id="L142">    }</span>

    /**
     * Set of resource paths of metadata files or jars supplied by user.
     */
    public void setResources(Collection&lt;String&gt; rsrcs) {
<span class="nc" id="L148">        this.rsrcs = rsrcs;</span>
<span class="nc" id="L149">    }</span>

    /**
     * Set of semicolon-separated resource paths of metadata files or jars
     * supplied by user via auto-configuration.
     */
    public void setResources(String rsrcs) {
        // keep list mutable so subclasses can add implicit locations
<span class="nc bnc" id="L157" title="All 2 branches missed.">        this.rsrcs = (StringUtil.isEmpty(rsrcs)) ? null</span>
<span class="nc" id="L158">          : new ArrayList&lt;&gt;(Arrays.asList(StringUtil.split(rsrcs, &quot;;&quot;, 0)));</span>
<span class="nc" id="L159">    }</span>

    /**
     * Set of classpath directories or jars to scan for metadata supplied
     * by user.
     */
    public void setClasspathScan(Collection&lt;String&gt; cpath) {
<span class="nc" id="L166">        this.cpath = cpath;</span>
<span class="nc" id="L167">    }</span>

    /**
     * Set of classpath directories or jars to scan for metadata supplied
     * by user via auto-configuration.
     */
    public void setClasspathScan(String cpath) {
        // keep list mutable so subclasses can add implicit locations
<span class="nc bnc" id="L175" title="All 2 branches missed.">        this.cpath = (StringUtil.isEmpty(cpath)) ? null</span>
<span class="nc" id="L176">          : new ArrayList&lt;&gt;(Arrays.asList(StringUtil.split(cpath, &quot;;&quot;, 0)));</span>
<span class="nc" id="L177">    }</span>

    @Override
    public boolean store(ClassMetaData[] metas, QueryMetaData[] queries,
        SequenceMetaData[] seqs, int mode, Map&lt;File,String&gt; output) {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (mode == MODE_NONE)</span>
<span class="nc" id="L183">            return true;</span>
<span class="nc bnc" id="L184" title="All 4 branches missed.">        if (isMappingOnlyFactory() &amp;&amp; (mode &amp; MODE_MAPPING) == 0)</span>
<span class="nc" id="L185">            return true;</span>

<span class="nc bnc" id="L187" title="All 4 branches missed.">        if (!strict &amp;&amp; (mode &amp; MODE_META) != 0)</span>
<span class="nc" id="L188">            mode |= MODE_MAPPING;</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        Class&lt;?&gt; cls = (metas.length == 0) ? null : metas[0].getDescribedType();</span>
<span class="nc" id="L190">        ClassLoader loader = repos.getConfiguration().</span>
<span class="nc" id="L191">            getClassResolverInstance().getClassLoader(cls, null);</span>
<span class="nc" id="L192">        Map&lt;String,ClassMetaData&gt; clsNames = new HashMap&lt;&gt;</span>
        	((int) (metas.length * 1.33 + 1));
<span class="nc bnc" id="L194" title="All 2 branches missed.">        for (int i = 0; i &lt; metas.length; i++)</span>
<span class="nc" id="L195">            clsNames.put(metas[i].getDescribedType().getName(), metas[i]);</span>

        // assign default files if in metadata mode (in other modes we assume
        // the files would have to be read already to create the metadatas)
<span class="nc" id="L199">        Set metaFiles = null;</span>
<span class="nc" id="L200">        Set queryFiles = null;</span>
<span class="nc bnc" id="L201" title="All 4 branches missed.">        if (isMappingOnlyFactory() || (mode &amp; MODE_META) != 0)</span>
<span class="nc" id="L202">            metaFiles = assignDefaultMetaDataFiles(metas, queries, seqs, mode,</span>
                clsNames);
<span class="nc bnc" id="L204" title="All 4 branches missed.">        if (!isMappingOnlyFactory() &amp;&amp; (mode &amp; MODE_QUERY) != 0)</span>
<span class="nc" id="L205">            queryFiles = assignDefaultQueryFiles(queries, clsNames);</span>

        // parse all files to be sure we don't delete existing metadata when
        // writing out new metadata, then serialize
        Serializer ser;
        Parser parser;
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (mode != MODE_QUERY) {</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            int sermode = (isMappingOnlyFactory()) ? mode : mode | MODE_META;</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if ((mode &amp; MODE_ANN_MAPPING) != 0)</span>
<span class="nc" id="L214">                ser = newAnnotationSerializer();</span>
            else
<span class="nc" id="L216">                ser = newSerializer();</span>
<span class="nc" id="L217">            ser.setMode(sermode);</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">            if (metaFiles != null) {</span>
<span class="nc" id="L219">                parser = newParser(false);</span>
<span class="nc" id="L220">                parser.setMode(sermode);</span>
<span class="nc" id="L221">                parser.setClassLoader(loader);</span>
<span class="nc" id="L222">                parse(parser, metaFiles);</span>

<span class="nc" id="L224">                MetaDataRepository pr = parser.getRepository();</span>
<span class="nc" id="L225">                pr.setSourceMode(mode);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">                if (isMappingOnlyFactory())</span>
<span class="nc" id="L227">                    pr.setResolve(MODE_NONE);</span>
                else
<span class="nc" id="L229">                    pr.setResolve(MODE_MAPPING, false);</span>
<span class="nc" id="L230">                ser.addAll(pr);</span>
            }

<span class="nc bnc" id="L233" title="All 2 branches missed.">            for (int i = 0; i &lt; metas.length; i++)</span>
<span class="nc" id="L234">                ser.addMetaData(metas[i]);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if ((mode &amp; MODE_MAPPING) != 0)</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">                for (int i = 0; i &lt; seqs.length; i++)</span>
<span class="nc" id="L237">                    ser.addSequenceMetaData(seqs[i]);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">            for (int i = 0; i &lt; queries.length; i++)</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                if (queries[i].getSourceMode() != MODE_QUERY</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">                    &amp;&amp; (queries[i].getSourceMode() &amp; mode) != 0)</span>
<span class="nc" id="L241">                    ser.addQueryMetaData(queries[i]);</span>

<span class="nc" id="L243">            int flags = MetaDataSerializer.PRETTY;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if ((store &amp; STORE_VERBOSE) != 0)</span>
<span class="nc" id="L245">                flags |= MetaDataSerializer.VERBOSE;</span>
<span class="nc" id="L246">            serialize(ser, output, flags);</span>
        }

        // do we have any queries stored in query files?
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (!isMappingOnlyFactory()) {</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            boolean qFiles = queryFiles != null;</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">            for (int i = 0; !qFiles &amp;&amp; i &lt; queries.length; i++)</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">                qFiles = queries[i].getSourceMode() == MODE_QUERY;</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (qFiles) {</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                if ((mode &amp; MODE_ANN_MAPPING) != 0)</span>
<span class="nc" id="L256">                    ser = newAnnotationSerializer();</span>
                else
<span class="nc" id="L258">                    ser = newSerializer();</span>
<span class="nc" id="L259">                ser.setMode(MODE_QUERY);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                if (queryFiles != null) {</span>
<span class="nc" id="L261">                    parser = newParser(false);</span>
<span class="nc" id="L262">                    parser.setMode(MODE_QUERY);</span>
<span class="nc" id="L263">                    parser.setClassLoader(loader);</span>
<span class="nc" id="L264">                    parse(parser, queryFiles);</span>
<span class="nc" id="L265">                    ser.addAll(parser.getRepository());</span>
                }
<span class="nc bnc" id="L267" title="All 2 branches missed.">                for (int i = 0; i &lt; queries.length; i++)</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">                    if (queries[i].getSourceMode() == MODE_QUERY)</span>
<span class="nc" id="L269">                        ser.addQueryMetaData(queries[i]);</span>
<span class="nc" id="L270">                serialize(ser, output, MetaDataSerializer.PRETTY);</span>
            }
        }
<span class="nc" id="L273">        return true;</span>
    }

    @Override
    public boolean drop(Class[] cls, int mode, ClassLoader envLoader) {
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (mode == MODE_NONE)</span>
<span class="nc" id="L279">            return true;</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">        if (isMappingOnlyFactory() &amp;&amp; (mode &amp; MODE_MAPPING) == 0)</span>
<span class="nc" id="L281">            return true;</span>

<span class="nc" id="L283">        Parser parser = newParser(false);</span>
<span class="nc" id="L284">        MetaDataRepository pr = parser.getRepository();</span>
<span class="nc" id="L285">        pr.setSourceMode(MODE_MAPPING, false);</span>
<span class="nc" id="L286">        pr.setResolve(MODE_MAPPING, false);</span>

        // parse metadata for all these classes
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if ((mode &amp; (MODE_META | MODE_MAPPING)) != 0) {</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            parser.setMode((isMappingOnlyFactory()) ? mode</span>
<span class="nc" id="L291">                : MODE_META | MODE_MAPPING | MODE_QUERY);</span>
<span class="nc" id="L292">            parse(parser, cls);</span>
        }
<span class="nc bnc" id="L294" title="All 4 branches missed.">        if (!isMappingOnlyFactory() &amp;&amp; (mode &amp; MODE_QUERY) != 0) {</span>
<span class="nc" id="L295">            parser.setMode(MODE_QUERY);</span>
<span class="nc" id="L296">            parse(parser, cls);</span>
        }

        // remove metadatas from repository or clear their mappings
<span class="nc" id="L300">        Set files = new HashSet();</span>
<span class="nc" id="L301">        Set clsNames = null;</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if ((mode &amp; (MODE_META | MODE_MAPPING)) != 0) {</span>
<span class="nc" id="L303">            clsNames = new HashSet((int) (cls.length * 1.33 + 1));</span>
            ClassMetaData meta;
<span class="nc bnc" id="L305" title="All 2 branches missed.">            for (int i = 0; i &lt; cls.length; i++) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                if (cls[i] == null)</span>
<span class="nc" id="L307">                    clsNames.add(null);</span>
                else
<span class="nc" id="L309">                    clsNames.add(cls[i].getName());</span>
<span class="nc" id="L310">                meta = pr.getMetaData(cls[i], envLoader, false);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                if (meta != null) {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                    if (getSourceFile(meta) != null)</span>
<span class="nc" id="L313">                        files.add(getSourceFile(meta));</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">                    if ((mode &amp; MODE_META) != 0)</span>
<span class="nc" id="L315">                        pr.removeMetaData(meta);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                    else if (!isMappingOnlyFactory())</span>
<span class="nc" id="L317">                        clearMapping(meta);</span>
                }
            }
        }

        // remove query mode metadatas so we can store them separately
<span class="nc" id="L323">        QueryMetaData[] queries = pr.getQueryMetaDatas();</span>
<span class="nc bnc" id="L324" title="All 4 branches missed.">        List qqs = (!isMappingOnlyFactory() &amp;&amp; (mode &amp; MODE_QUERY) == 0)</span>
<span class="nc" id="L325">            ? null : new ArrayList();</span>
        boolean rem;
        Class def;
<span class="nc bnc" id="L328" title="All 2 branches missed.">        for (int i = 0; i &lt; queries.length; i++) {</span>
<span class="nc bnc" id="L329" title="All 4 branches missed.">            if (!isMappingOnlyFactory() &amp;&amp; queries[i].getSourceFile() != null)</span>
<span class="nc" id="L330">                files.add(queries[i].getSourceFile());</span>
<span class="nc" id="L331">            def = queries[i].getDefiningType();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            rem = (queries[i].getSourceMode() &amp; mode) != 0</span>
<span class="nc bnc" id="L333" title="All 4 branches missed.">                &amp;&amp; clsNames.contains((def == null) ? null : def.getName());</span>
<span class="nc bnc" id="L334" title="All 4 branches missed.">            if (rem || (!isMappingOnlyFactory()</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                &amp;&amp; queries[i].getSourceMode() == MODE_QUERY))</span>
<span class="nc" id="L336">                pr.removeQueryMetaData(queries[i]);</span>
<span class="nc bnc" id="L337" title="All 6 branches missed.">            if (qqs != null &amp;&amp; queries[i].getSourceMode() == MODE_QUERY &amp;&amp; !rem)</span>
<span class="nc" id="L338">                qqs.add(queries[i]);</span>
        }

        // write new metadata without removed instances
<span class="nc" id="L342">        backupAndDelete(files);</span>
        Serializer ser;
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if ((mode &amp; (MODE_META | MODE_MAPPING)) != 0) {</span>
<span class="nc" id="L345">            ser = newSerializer();</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">            ser.setMode((isMappingOnlyFactory()) ? mode : mode | MODE_META);</span>
<span class="nc" id="L347">            ser.addAll(pr);</span>
            // remove from serializer rather than from repository above so that
            // calling code can take advantage of metadata still in repos
<span class="nc bnc" id="L350" title="All 2 branches missed.">            if (isMappingOnlyFactory())</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                for (int i = 0; i &lt; cls.length; i++)</span>
<span class="nc" id="L352">                    ser.removeMetaData(pr.getMetaData(cls[i], envLoader,</span>
                        false));
<span class="nc" id="L354">            serialize(ser, null, MetaDataSerializer.PRETTY);</span>
        }
<span class="nc bnc" id="L356" title="All 4 branches missed.">        if (qqs != null &amp;&amp; !qqs.isEmpty()) {</span>
<span class="nc" id="L357">            ser = newSerializer();</span>
<span class="nc" id="L358">            ser.setMode(MODE_QUERY);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            for (int i = 0; i &lt; qqs.size(); i++)</span>
<span class="nc" id="L360">                ser.addQueryMetaData((QueryMetaData) qqs.get(i));</span>
<span class="nc" id="L361">            serialize(ser, null, MetaDataSerializer.PRETTY);</span>
        }
<span class="nc" id="L363">        return true;</span>
    }

    /**
     * Assign default source files to the given metadatas.
     *
     * @param clsNames map of class names to metadatas
     * @return set of existing files used by these metadatas, or
     * null if no existing files
     */
    private Set assignDefaultMetaDataFiles(ClassMetaData[] metas,
        QueryMetaData[] queries, SequenceMetaData[] seqs, int mode,
        Map clsNames) {
<span class="nc" id="L376">        Set files = null;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        for (int i = 0; i &lt; metas.length; i++) {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">            if (getSourceFile(metas[i]) == null)</span>
<span class="nc" id="L379">                setSourceFile(metas[i], defaultSourceFile(metas[i]));</span>
<span class="nc" id="L380">            if ((AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">                .existsAction(getSourceFile(metas[i])))).booleanValue()) {</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">                if (files == null)</span>
<span class="nc" id="L383">                    files = new HashSet();</span>
<span class="nc" id="L384">                files.add(getSourceFile(metas[i]));</span>
            }
        }
<span class="nc bnc" id="L387" title="All 2 branches missed.">        for (int i = 0; i &lt; queries.length; i++) {</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">            if (queries[i].getSourceMode() == MODE_QUERY</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                || (mode &amp; queries[i].getSourceMode()) == 0)</span>
<span class="nc" id="L390">                continue;</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">            if (queries[i].getSourceFile() == null) {</span>
<span class="nc" id="L392">                File defaultFile = defaultSourceFile(queries[i], clsNames);</span>
<span class="nc" id="L393">                queries[i].setSource(defaultFile, queries[i].getSourceScope(), queries[i].getSourceType(),</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">                    defaultFile == null ? &quot;&quot; : defaultFile.getPath());</span>
            }
<span class="nc" id="L396">            if ((AccessController.doPrivileged(</span>
<span class="nc" id="L397">                J2DoPrivHelper.existsAction(queries[i].getSourceFile())))</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                .booleanValue()) {</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                if (files == null)</span>
<span class="nc" id="L400">                    files = new HashSet();</span>
<span class="nc" id="L401">                files.add(queries[i].getSourceFile());</span>
            }
        }
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if ((mode &amp; MODE_MAPPING) != 0) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">            for (int i = 0; i &lt; seqs.length; i++) {</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                if (getSourceFile(seqs[i]) == null)</span>
<span class="nc" id="L407">                    setSourceFile(seqs[i], defaultSourceFile(seqs[i],</span>
                        clsNames));
<span class="nc" id="L409">                if ((AccessController.doPrivileged(</span>
<span class="nc" id="L410">                    J2DoPrivHelper.existsAction(getSourceFile(seqs[i]))))</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                    .booleanValue()) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                    if (files == null)</span>
<span class="nc" id="L413">                        files = new HashSet();</span>
<span class="nc" id="L414">                    files.add(getSourceFile(seqs[i]));</span>
                }
            }
        }
<span class="nc" id="L418">        return files;</span>
    }

    /**
     * Assign default source files to the given queries.
     *
     * @param clsNames map of class names to metadatas
     * @return set of existing files used by these metadatas, or
     * null if no existing files
     */
    private Set assignDefaultQueryFiles(QueryMetaData[] queries,
        Map clsNames) {
<span class="nc" id="L430">        Set files = null;</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">        for (int i = 0; i &lt; queries.length; i++) {</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">            if (queries[i].getSourceMode() != MODE_QUERY)</span>
<span class="nc" id="L433">                continue;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (queries[i].getSourceFile() == null) {</span>
<span class="nc" id="L435">                File defaultFile = defaultSourceFile(queries[i], clsNames);</span>
<span class="nc" id="L436">                queries[i].setSource(defaultFile, queries[i].getSourceScope(), queries[i].getSourceType(),</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">                    defaultFile == null ? &quot;&quot; : defaultFile.getPath());</span>
            }
<span class="nc" id="L439">            if ((AccessController.doPrivileged(</span>
<span class="nc" id="L440">                J2DoPrivHelper.existsAction(queries[i].getSourceFile())))</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                .booleanValue()) {</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">                if (files == null)</span>
<span class="nc" id="L443">                    files = new HashSet();</span>
<span class="nc" id="L444">                files.add(queries[i].getSourceFile());</span>
            }
        }
<span class="nc" id="L447">        return files;</span>
    }

    /**
     * Return true if this factory deals only with mapping data, and relies
     * on a separate factory for metadata.
     */
    protected boolean isMappingOnlyFactory() {
<span class="nc" id="L455">        return false;</span>
    }

    /**
     * Parse all given files.
     */
    protected void parse(MetaDataParser parser, Collection files) {
        try {
<span class="nc bnc" id="L463" title="All 2 branches missed.">            for (Iterator itr = files.iterator(); itr.hasNext();)</span>
<span class="nc" id="L464">                parser.parse((File) itr.next());</span>
<span class="nc" id="L465">        } catch (IOException ioe) {</span>
<span class="nc" id="L466">            throw new GeneralException(ioe);</span>
<span class="nc" id="L467">        }</span>
<span class="nc" id="L468">    }</span>

    /**
     * Parse all given classses.
     */
    protected void parse(MetaDataParser parser, Class[] cls) {
        try {
<span class="nc bnc" id="L475" title="All 2 branches missed.">            for (int i = 0; i &lt; cls.length; i++)</span>
<span class="nc" id="L476">                parser.parse(cls[i], isParseTopDown());</span>
<span class="nc" id="L477">        } catch (IOException ioe) {</span>
<span class="nc" id="L478">            throw new GeneralException(ioe);</span>
<span class="nc" id="L479">        }</span>
<span class="nc" id="L480">    }</span>

    /**
     * Whether to parse classes top down. Defaults to false.
     */
    protected boolean isParseTopDown() {
<span class="nc" id="L486">        return false;</span>
    }

    /**
     * Tell the given serialier to write its metadatas.
     */
    protected void serialize(MetaDataSerializer ser, Map&lt;File, String&gt; output,
        int flags) {
        try {
<span class="nc bnc" id="L495" title="All 2 branches missed.">            if (output == null)</span>
<span class="nc" id="L496">                ser.serialize(flags);</span>
            else
<span class="nc" id="L498">                ser.serialize(output, flags);</span>
<span class="nc" id="L499">        } catch (IOException ioe) {</span>
<span class="nc" id="L500">            throw new GeneralException(ioe);</span>
<span class="nc" id="L501">        }</span>
<span class="nc" id="L502">    }</span>

    /**
     * Backup and delete the source files for the given metadatas.
     */
    protected void backupAndDelete(Collection files) {
        File file;
<span class="nc bnc" id="L509" title="All 2 branches missed.">        for (Iterator itr = files.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L510">            file = (File) itr.next();</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">            if (Files.backup(file, false) != null)</span>
<span class="nc" id="L512">                AccessController</span>
<span class="nc" id="L513">                    .doPrivileged(J2DoPrivHelper.deleteAction(file));</span>
        }
<span class="nc" id="L515">    }</span>

    /**
     * Clear mapping information from the given metadata.
     */
    protected void clearMapping(ClassMetaData meta) {
<span class="nc" id="L521">        meta.setSourceMode(MODE_MAPPING, false);</span>
<span class="nc" id="L522">    }</span>

    /**
     * Return the current source file of the given metadata.
     */
    protected File getSourceFile(ClassMetaData meta) {
<span class="nc" id="L528">        return meta.getSourceFile();</span>
    }

    /**
     * Set the current source file of the given metadata.
     */
    protected void setSourceFile(ClassMetaData meta, File sourceFile) {
<span class="nc bnc" id="L535" title="All 2 branches missed.">        meta.setSource(sourceFile, meta.getSourceType(), sourceFile != null ?</span>
<span class="nc" id="L536">            sourceFile.getPath() : &quot;&quot;);</span>
<span class="nc" id="L537">    }</span>

    /**
     * Return the current source file of the given metadata.
     */
    protected File getSourceFile(SequenceMetaData meta) {
<span class="nc" id="L543">        return meta.getSourceFile();</span>
    }

    /**
     * Set the current source file of the given metadata.
     */
    protected void setSourceFile(SequenceMetaData meta, File sourceFile) {
<span class="nc" id="L550">        meta.setSource(sourceFile, meta.getSourceScope(),</span>
<span class="nc" id="L551">            meta.getSourceType());</span>
<span class="nc" id="L552">    }</span>

    /**
     * Return the default file for the given metadata.
     */
    protected abstract File defaultSourceFile(ClassMetaData meta);

    /**
     * Return a default file for the given query.
     */
    protected abstract File defaultSourceFile(QueryMetaData query,
        Map clsNames);

    /**
     * Return a default file for the given sequence.
     */
    protected abstract File defaultSourceFile(SequenceMetaData seq,
        Map clsNames);

    /**
     * Create a new metadata parser.
     *
     * @param loading if true, this will be the cached parser used for
     * loading metadata
     */
    protected abstract Parser newParser(boolean loading);

    /**
     * Create a new metadata serializer.
     */
    protected abstract Serializer newSerializer();

    /**
     * Create a new annotation metadata serializer.
     */
    protected abstract Serializer newAnnotationSerializer();

    /**
     * Return the metadata that defines the given query, if any.
     *
     * @param clsNames map of class names to metadatas
     */
    protected ClassMetaData getDefiningMetaData(QueryMetaData query,
        Map clsNames) {
<span class="nc" id="L596">        Class def = query.getDefiningType();</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">        if (def != null)</span>
<span class="nc" id="L598">            return (ClassMetaData) clsNames.get(def.getName());</span>

        Map.Entry entry;
        String pkg;
<span class="nc bnc" id="L602" title="All 2 branches missed.">        for (Iterator itr = clsNames.entrySet().iterator(); itr.hasNext();) {</span>
<span class="nc" id="L603">            entry = (Map.Entry) itr.next();</span>
<span class="nc" id="L604">            pkg = ClassUtil.getPackageName((String) entry.getKey());</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">            if (pkg.length() == 0)</span>
<span class="nc" id="L606">                return (ClassMetaData) entry.getValue();</span>
        }
<span class="nc" id="L608">        return null;</span>
    }

    @Override
    public Set&lt;String&gt; getPersistentTypeNames(boolean devpath, ClassLoader envLoader) {
        // some configured locations might be implicit in spec, so return
        // null if we don't find any classes, rather than if we don't have
        // any locations
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (_typeNames != null)</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">            return (_typeNames.isEmpty()) ? null : _typeNames;</span>

        try {
<span class="nc" id="L620">            ClassLoader loader = repos.getConfiguration().</span>
<span class="nc" id="L621">                getClassResolverInstance().getClassLoader(getClass(),</span>
                envLoader);
<span class="nc" id="L623">            long start = System.currentTimeMillis();</span>

<span class="nc" id="L625">            Set names = parsePersistentTypeNames(loader);</span>
<span class="nc bnc" id="L626" title="All 4 branches missed.">            if (names.isEmpty() &amp;&amp; devpath)</span>
<span class="nc" id="L627">                scan(new ClasspathMetaDataIterator(null, newMetaDataFilter()),</span>
<span class="nc" id="L628">                    newClassArgParser(), names, false, null);</span>
            else // we don't cache a full dev cp scan
<span class="nc" id="L630">                _typeNames = names;</span>

<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (log.isTraceEnabled())</span>
<span class="nc" id="L633">                log.trace(_loc.get(&quot;found-pcs&quot;, String.valueOf(names.size()),</span>
<span class="nc" id="L634">                    String.valueOf(System.currentTimeMillis() - start)));</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">            return (names.isEmpty()) ? null : names;</span>
<span class="nc" id="L636">        } catch (IOException ioe) {</span>
<span class="nc" id="L637">            throw new GeneralException(ioe);</span>
        }
    }

    /**
     * Parse persistent type names.
     */
    protected Set&lt;String&gt; parsePersistentTypeNames(ClassLoader loader)
        throws IOException {
<span class="nc" id="L646">        ClassArgParser cparser = newClassArgParser();</span>
        String[] clss;
<span class="nc" id="L648">        Set&lt;String&gt; names = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">        if (files != null) {</span>
            File file;
<span class="nc bnc" id="L651" title="All 2 branches missed.">            for (Iterator itr = files.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L652">                file = (File) itr.next();</span>
<span class="nc" id="L653">                if ((AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">                    .isDirectoryAction(file))).booleanValue()) {</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">                    if (log.isTraceEnabled())</span>
<span class="nc" id="L656">                        log.trace(_loc.get(&quot;scanning-directory&quot;, file));</span>
<span class="nc" id="L657">                    scan(new FileMetaDataIterator(file, newMetaDataFilter()),</span>
                        cparser, names, true, file);
<span class="nc bnc" id="L659" title="All 2 branches missed.">                } else if (file.getName().endsWith(&quot;.jar&quot;)) {</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">                    if (log.isTraceEnabled())</span>
<span class="nc" id="L661">                        log.trace(_loc.get(&quot;scanning-jar&quot;, file));</span>
                    try {
<span class="nc" id="L663">                        ZipFile zFile = AccessController</span>
<span class="nc" id="L664">                            .doPrivileged(J2DoPrivHelper</span>
<span class="nc" id="L665">                                .newZipFileAction(file));</span>
<span class="nc" id="L666">                        scan(new ZipFileMetaDataIterator(zFile,</span>
<span class="nc" id="L667">                            newMetaDataFilter()), cparser, names, true, file);</span>
<span class="nc" id="L668">                    } catch (PrivilegedActionException pae) {</span>
<span class="nc" id="L669">                        throw (IOException) pae.getException();</span>
<span class="nc" id="L670">                    }</span>
                } else {
<span class="nc bnc" id="L672" title="All 2 branches missed.">                    if (log.isTraceEnabled())</span>
<span class="nc" id="L673">                        log.trace(_loc.get(&quot;scanning-file&quot;, file));</span>
<span class="nc" id="L674">                    clss = cparser.parseTypeNames(new FileMetaDataIterator</span>
                        (file));
<span class="nc" id="L676">                    List&lt;String&gt; newNames = Arrays.asList(clss);</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">                    if (log.isTraceEnabled())</span>
<span class="nc" id="L678">                        log.trace(_loc.get(&quot;scan-found-names&quot;, newNames, file));</span>
<span class="nc" id="L679">                    names.addAll(newNames);</span>
<span class="nc" id="L680">                    File f = AccessController</span>
<span class="nc" id="L681">                        .doPrivileged(J2DoPrivHelper</span>
<span class="nc" id="L682">                            .getAbsoluteFileAction(file));</span>
                    try {
<span class="nc" id="L684">                        mapPersistentTypeNames(AccessController</span>
<span class="nc" id="L685">                            .doPrivileged(J2DoPrivHelper.toURLAction(f)), clss);</span>
<span class="nc" id="L686">                    } catch (PrivilegedActionException pae) {</span>
<span class="nc" id="L687">                        throw (FileNotFoundException) pae.getException();</span>
<span class="nc" id="L688">                    }</span>
<span class="nc" id="L689">                }</span>
            }
        }
        URL url;
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (urls != null) {</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">            for (Iterator itr = urls.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L695">                url = (URL) itr.next();</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">                if (&quot;file&quot;.equals(url.getProtocol())) {</span>
<span class="nc" id="L697">                    File file = AccessController</span>
<span class="nc" id="L698">                        .doPrivileged(J2DoPrivHelper</span>
<span class="nc" id="L699">                            .getAbsoluteFileAction(new File(url.getFile())));</span>
<span class="nc bnc" id="L700" title="All 4 branches missed.">                    if (files != null &amp;&amp; files.contains(file)) {</span>
<span class="nc" id="L701">                        continue;</span>
<span class="nc" id="L702">                    } else if ((AccessController</span>
<span class="nc" id="L703">                        .doPrivileged(J2DoPrivHelper.isDirectoryAction(file)))</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                        .booleanValue()) {</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                        if (log.isTraceEnabled())</span>
<span class="nc" id="L706">                            log.trace(_loc.get(&quot;scanning-directory&quot;, file));</span>
<span class="nc" id="L707">                        scan(</span>
<span class="nc" id="L708">                            new FileMetaDataIterator(file, newMetaDataFilter()),</span>
                            cparser, names, true, file);
<span class="nc" id="L710">                        continue;</span>
                    }
                }
<span class="nc bnc" id="L713" title="All 2 branches missed.">                if (&quot;vfs&quot;.equals(url.getProtocol())) {</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">                    if (log.isTraceEnabled()) {</span>
<span class="nc" id="L715">                        log.trace(_loc.get(&quot;scanning-vfs-url&quot;, url));</span>
                    }

<span class="nc" id="L718">                    final URL finalUrl = url;</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">                    if (url.toString().endsWith(&quot;.jar&quot;)) {</span>
<span class="nc" id="L720">                        ZipInputStream zis = AccessController.doPrivileged(new PrivilegedAction&lt;ZipInputStream&gt;() {</span>

                            @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
                            @Override
                            public ZipInputStream run() {
                                try {
<span class="nc" id="L726">                                    Class vfs = Class.forName(&quot;org.jboss.vfs.VFS&quot;);</span>
<span class="nc" id="L727">                                    Method getChild = vfs.getDeclaredMethod(&quot;getChild&quot;, URL.class);</span>
<span class="nc" id="L728">                                    Object jarFile = getChild.invoke(null, finalUrl);</span>

<span class="nc" id="L730">                                    Class virtualFileClass = Class.forName(&quot;org.jboss.vfs.VirtualFile&quot;);</span>
<span class="nc" id="L731">                                    Method openStream = virtualFileClass.getDeclaredMethod(&quot;openStream&quot;);</span>
<span class="nc" id="L732">                                    return (ZipInputStream) openStream.invoke(jarFile);</span>
<span class="nc" id="L733">                                } catch (Exception e) {</span>
<span class="nc" id="L734">                                    log.error(_loc.get(&quot;while-scanning-vfs-url&quot;, finalUrl), e);</span>
                                }
<span class="nc" id="L736">                                return null;</span>
                            }
                        });
<span class="nc bnc" id="L739" title="All 2 branches missed.">                        if (zis != null) {</span>
<span class="nc" id="L740">                            scan(new ZipStreamMetaDataIterator(zis, newMetaDataFilter()), cparser, names, true, url);</span>
                        }
<span class="nc" id="L742">                    } else {</span>
<span class="nc" id="L743">                        final URLConnection conn = url.openConnection();</span>
<span class="nc" id="L744">                        final Object vfsContent = conn.getContent();</span>
<span class="nc" id="L745">                        File file = AccessController.doPrivileged(new PrivilegedAction&lt;File&gt;() {</span>

                            @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
                            @Override
                            public File run() {
                                try {
<span class="nc" id="L751">                                    Class virtualFileClass = Class.forName(&quot;org.jboss.vfs.VirtualFile&quot;);</span>
<span class="nc" id="L752">                                    Method getPhysicalFile = virtualFileClass.getDeclaredMethod(&quot;getPhysicalFile&quot;);</span>
<span class="nc" id="L753">                                    return (File) getPhysicalFile.invoke(vfsContent);</span>
<span class="nc" id="L754">                                } catch (Exception e) {</span>
<span class="nc" id="L755">                                    log.error(_loc.get(&quot;while-scanning-vfs-url&quot;, finalUrl), e);</span>
                                }
<span class="nc" id="L757">                                return null;</span>
                            }
                        });
<span class="nc bnc" id="L760" title="All 2 branches missed.">                        if (file != null) {</span>
<span class="nc" id="L761">                            scan(new FileMetaDataIterator(file, newMetaDataFilter()), cparser, names, true, file);</span>
                        }
                    }
<span class="nc" id="L764">                    continue;</span>
                }
<span class="nc bnc" id="L766" title="All 2 branches missed.">                if (&quot;jar&quot;.equals(url.getProtocol())) {</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">                    if (url.getPath().endsWith(&quot;!/&quot;)) {</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">                        if (log.isTraceEnabled())</span>
<span class="nc" id="L769">                            log.trace(_loc.get(&quot;scanning-jar-url&quot;, url));</span>
<span class="nc" id="L770">                        scan(new ZipFileMetaDataIterator(url,</span>
<span class="nc" id="L771">                            newMetaDataFilter()), cparser, names, true, url);</span>
                    } else {
<span class="nc bnc" id="L773" title="All 2 branches missed.">                        if (log.isTraceEnabled())</span>
<span class="nc" id="L774">                            log.trace(_loc.get(&quot;scanning-jar-url&quot;, url));</span>
<span class="nc" id="L775">                        scan(new JarFileURLMetaDataIterator(url,</span>
<span class="nc" id="L776">                            newMetaDataFilter()), cparser, names, true, url);</span>
                    }
<span class="nc bnc" id="L778" title="All 2 branches missed.">                } else if (url.getPath().endsWith(&quot;.jar&quot;)) {</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">                    if (log.isTraceEnabled())</span>
<span class="nc" id="L780">                        log.trace(_loc.get(&quot;scanning-jar-at-url&quot;, url));</span>
                    try {
<span class="nc" id="L782">                        InputStream is = (InputStream)</span>
<span class="nc" id="L783">                            AccessController.doPrivileged(</span>
<span class="nc" id="L784">                                J2DoPrivHelper.openStreamAction(url));</span>
<span class="nc" id="L785">                        scan(new ZipStreamMetaDataIterator(</span>
                            new ZipInputStream(is),
<span class="nc" id="L787">                            newMetaDataFilter()), cparser, names, true, url);</span>
<span class="nc" id="L788">                    } catch (PrivilegedActionException pae) {</span>
<span class="nc" id="L789">                        throw (IOException) pae.getException();</span>
<span class="nc" id="L790">                    }</span>
                } else {
                    // Open an InputStream from the URL and sniff for a zip header.  If it is, then this is
                    // a URL with a jar-formated InputStream, as per the JPA specification.  Otherwise, fall back
                    // to URLMetaDataIterator.
<span class="nc" id="L795">                    BufferedInputStream is = null;</span>

                    try {
<span class="nc" id="L798">                        is = new BufferedInputStream((InputStream) AccessController.</span>
<span class="nc" id="L799">                            doPrivileged(J2DoPrivHelper.openStreamAction(url)));</span>
<span class="nc" id="L800">                    } catch (PrivilegedActionException pae) {</span>
<span class="nc" id="L801">                        throw (IOException) pae.getException();</span>
<span class="nc" id="L802">                    }</span>

                    // Check for zip header magic 0x50 0x4b 0x03 0x04
<span class="nc" id="L805">                    is.mark(0);</span>
<span class="nc bnc" id="L806" title="All 6 branches missed.">                    boolean zipHeaderMatch = is.read() == 0x50 &amp;&amp; is.read() == 0x4b &amp;&amp; is.read() == 0x03 &amp;&amp;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">                        is.read() == 0x04;</span>
<span class="nc" id="L808">                    is.reset();</span>

<span class="nc bnc" id="L810" title="All 2 branches missed.">                    if (zipHeaderMatch) {</span>
                        // The URL provides a Jar-formatted InputStream, consume it with ZipStreamMetaDataIterator
<span class="nc bnc" id="L812" title="All 2 branches missed.">                        if (log.isTraceEnabled())</span>
<span class="nc" id="L813">                            log.trace(_loc.get(&quot;scanning-jar-at-url&quot;, url));</span>
<span class="nc" id="L814">                        scan(new ZipStreamMetaDataIterator(new ZipInputStream(is), newMetaDataFilter()),</span>
                            cparser, names, true, url);
                    } else {
                        // Fall back to URLMetaDataIterator
<span class="nc bnc" id="L818" title="All 2 branches missed.">                        if (log.isTraceEnabled())</span>
<span class="nc" id="L819">                            log.trace(_loc.get(&quot;scanning-url&quot;, url));</span>
<span class="nc" id="L820">                        clss = cparser.parseTypeNames(new URLMetaDataIterator(url));</span>
<span class="nc" id="L821">                        List&lt;String&gt; newNames = Arrays.asList(clss);</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">                        if (log.isTraceEnabled())</span>
<span class="nc" id="L823">                            log.trace(_loc.get(&quot;scan-found-names&quot;, newNames, url));</span>
<span class="nc" id="L824">                        names.addAll(newNames);</span>
<span class="nc" id="L825">                        mapPersistentTypeNames(url, clss);</span>
                    }
<span class="nc" id="L827">                }</span>
            }
        }
<span class="nc bnc" id="L830" title="All 2 branches missed.">        if (rsrcs != null) {</span>
            String rsrc;
            MetaDataIterator mitr;
<span class="nc bnc" id="L833" title="All 2 branches missed.">            for (Iterator itr = rsrcs.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L834">                rsrc = (String) itr.next();</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">                if (rsrc.endsWith(&quot;.jar&quot;)) {</span>
<span class="nc" id="L836">                    url = AccessController.doPrivileged(</span>
<span class="nc" id="L837">                        J2DoPrivHelper.getResourceAction(loader, rsrc));</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">                    if (url != null) {</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">                        if (log.isTraceEnabled())</span>
<span class="nc" id="L840">                            log.trace(_loc.get(&quot;scanning-jar-stream-url&quot;, url));</span>
                        try {
<span class="nc" id="L842">                            InputStream is = (InputStream)</span>
<span class="nc" id="L843">                                AccessController.doPrivileged(</span>
<span class="nc" id="L844">                                    J2DoPrivHelper.openStreamAction(url));</span>
<span class="nc" id="L845">                            scan(new ZipStreamMetaDataIterator</span>
                                (new ZipInputStream(is),
<span class="nc" id="L847">                                newMetaDataFilter()), cparser, names, true,</span>
                                url);
<span class="nc" id="L849">                        } catch (PrivilegedActionException pae) {</span>
<span class="nc" id="L850">                            throw (IOException) pae.getException();</span>
<span class="nc" id="L851">                        }</span>
                    }
                } else {
<span class="nc bnc" id="L854" title="All 2 branches missed.">                    if (log.isTraceEnabled())</span>
<span class="nc" id="L855">                        log.trace(_loc.get(&quot;scanning-resource&quot;, rsrc));</span>
<span class="nc" id="L856">                    mitr = new ResourceMetaDataIterator(rsrc, loader);</span>
<span class="nc" id="L857">                    OpenJPAConfiguration conf = repos.getConfiguration();</span>
<span class="nc" id="L858">                    Map peMap = null;</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">                    if (conf instanceof OpenJPAConfigurationImpl)</span>
<span class="nc" id="L860">                        peMap = ((OpenJPAConfigurationImpl)conf).getPersistenceEnvironment();</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">                    URL puUrl = peMap == null ? null : (URL) peMap.get(PERSISTENCE_UNIT_ROOT_URL);</span>
                    List&lt;String&gt; mappingFileNames =
<span class="nc bnc" id="L863" title="All 2 branches missed.">                        peMap == null ? null : (List&lt;String&gt;) peMap.get(MAPPING_FILE_NAMES);</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">                    List&lt;URL&gt; jars = peMap == null ? null : (List&lt;URL&gt;)peMap.get(JAR_FILE_URLS);</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">                    String puUrlString = puUrl == null ? null : puUrl.toString();</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">                    if (log.isTraceEnabled())</span>
<span class="nc" id="L867">                        log.trace(_loc.get(&quot;pu-root-url&quot;, puUrlString));</span>

<span class="nc" id="L869">                    URL puORMUrl = null;</span>
                    try {
<span class="nc bnc" id="L871" title="All 2 branches missed.">                        if (puUrlString != null) {</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">                            String puORMUrlStr = puUrlString + (puUrlString.endsWith(&quot;/&quot;) ? &quot;&quot; : &quot;/&quot;) + rsrc;</span>
<span class="nc" id="L873">                            puORMUrl = AccessController.doPrivileged(J2DoPrivHelper.createURL(puORMUrlStr));</span>
                        }
<span class="nc" id="L875">                    } catch (PrivilegedActionException e) {</span>
<span class="nc" id="L876">                        throw new IOException(&quot;Error generating puORMUrlStr.&quot;, e.getCause());</span>
<span class="nc" id="L877">                    }</span>

<span class="nc" id="L879">                    List&lt;URL&gt; urls = new ArrayList&lt;&gt;(3);</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">                    while (mitr.hasNext()) {</span>
<span class="nc" id="L881">                        url = (URL) mitr.next();</span>
<span class="nc" id="L882">                        String urlString = url.toString();</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">                        if (log.isTraceEnabled())</span>
<span class="nc" id="L884">                            log.trace(_loc.get(&quot;resource-url&quot;, urlString));</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">                        if (peMap != null) {</span>
                        	//OPENJPA-2102: decode the URL to remove such things a spaces (' ') encoded as '%20'
<span class="nc bnc" id="L887" title="All 4 branches missed.">                            if (puUrlString != null &amp;&amp; decode(urlString).indexOf(decode(puUrlString)) != -1) {</span>
<span class="nc" id="L888">                                urls.add(url);</span>
<span class="nc bnc" id="L889" title="All 4 branches missed.">                            } else if (puORMUrl != null &amp;&amp; puORMUrl.equals(url)) {</span>
                                // Check URL equality to support encapsulating URL protocols
<span class="nc" id="L891">                                urls.add(url);</span>
                            }
<span class="nc bnc" id="L893" title="All 4 branches missed.">                            if (mappingFileNames != null &amp;&amp; mappingFileNames.size() != 0) {</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">                                for (String mappingFileName : mappingFileNames) {</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">                                    if (log.isTraceEnabled())</span>
<span class="nc" id="L896">                                        log.trace(_loc.get(&quot;mapping-file-name&quot;, mappingFileName));</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">                                    if (urlString.indexOf(mappingFileName) != -1)</span>
<span class="nc" id="L898">                                        urls.add(url);</span>
<span class="nc" id="L899">                                }</span>
                            }

<span class="nc bnc" id="L902" title="All 4 branches missed.">                            if (jars != null &amp;&amp; jars.size() != 0) {</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">                                for (URL jarUrl : jars) {</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                                    if (log.isTraceEnabled())</span>
<span class="nc" id="L905">                                        log.trace(_loc.get(&quot;jar-file-url&quot;, jarUrl));</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">                                    if (urlString.indexOf(jarUrl.toString()) != -1)</span>
<span class="nc" id="L907">                                        urls.add(url);</span>
<span class="nc" id="L908">                                }</span>
                            }
                        } else {
<span class="nc" id="L911">                            urls.add(url);</span>
                        }
<span class="nc" id="L913">                    }</span>
<span class="nc" id="L914">                    mitr.close();</span>

<span class="nc bnc" id="L916" title="All 2 branches missed.">                    for (Object obj : urls) {</span>
<span class="nc" id="L917">                        url = (URL) obj;</span>
<span class="nc" id="L918">                        clss = cparser.parseTypeNames(new URLMetaDataIterator</span>
                            (url));
<span class="nc" id="L920">                        List&lt;String&gt; newNames = Arrays.asList(clss);</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">                        if (log.isTraceEnabled())</span>
<span class="nc" id="L922">                            log.trace(_loc.get(&quot;scan-found-names&quot;, newNames,</span>
                                    rsrc));
<span class="nc" id="L924">                        names.addAll(newNames);</span>
<span class="nc" id="L925">                        mapPersistentTypeNames(url, clss);</span>
<span class="nc" id="L926">                    }</span>
<span class="nc" id="L927">                }</span>
            }
        }
<span class="nc bnc" id="L930" title="All 2 branches missed.">        if (cpath != null) {</span>
<span class="nc" id="L931">            String[] dirs = (String[]) cpath.toArray(new String[cpath.size()]);</span>
<span class="nc" id="L932">            scan(new ClasspathMetaDataIterator(dirs, newMetaDataFilter()),</span>
                cparser, names, true, dirs);
        }
<span class="nc bnc" id="L935" title="All 2 branches missed.">        if (types != null)</span>
<span class="nc" id="L936">            names.addAll(types);</span>

<span class="nc bnc" id="L938" title="All 2 branches missed.">        if (log.isTraceEnabled())</span>
<span class="nc" id="L939">            log.trace(_loc.get(&quot;parse-found-names&quot;, names));</span>

<span class="nc" id="L941">        return names;</span>
    }

    /**
     * Scan for persistent type names using the given metadata iterator.
     */
    private void scan(MetaDataIterator mitr, ClassArgParser cparser, Set names,
        boolean mapNames, Object debugContext)
        throws IOException {
        Map map;
        try {
<span class="nc" id="L952">            map = cparser.mapTypeNames(mitr);</span>
        } finally {
<span class="nc" id="L954">            mitr.close();</span>
        }

        Map.Entry entry;
<span class="nc bnc" id="L958" title="All 2 branches missed.">        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {</span>
<span class="nc" id="L959">            entry = (Map.Entry) itr.next();</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">            if (mapNames)</span>
<span class="nc" id="L961">                mapPersistentTypeNames(entry.getKey(), (String[])</span>
<span class="nc" id="L962">                    entry.getValue());</span>
<span class="nc" id="L963">            List newNames = Arrays.asList((String[]) entry.getValue());</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">            if (log.isTraceEnabled())</span>
<span class="nc" id="L965">                log.trace(_loc.get(&quot;scan-found-names&quot;, newNames, debugContext));</span>
<span class="nc" id="L966">            names.addAll(newNames);</span>
<span class="nc" id="L967">        }</span>
<span class="nc" id="L968">    }</span>

    /**
     * Decodes a URL-encoded path string.  For example, an encoded
     * space (%20) is decoded into a normal space (' ') character.
     * Added via OPENJPA-2102.
     * @param s - the encoded URL string
     * @return String decoded - the decoded string.
     */
    public static String decode(String s) {
<span class="nc bnc" id="L978" title="All 2 branches missed.">       if (s == null) {</span>
<span class="nc" id="L979">          return null;</span>
       }

<span class="nc" id="L982">       int i = s.indexOf('%');</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">       if (i == -1) {</span>
<span class="nc" id="L984">          return s;</span>
       }

<span class="nc" id="L987">       StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L988">       int begin = 0;</span>

       do {
<span class="nc" id="L991">          builder.append(s, begin, i);</span>
<span class="nc" id="L992">          begin = i + 3;</span>

<span class="nc" id="L994">          char ch = (char) Integer.parseInt(s.substring(i + 1, begin), 16);</span>

<span class="nc bnc" id="L996" title="All 2 branches missed.">          if ((ch &amp; 0x80) != 0) {</span>
             // Decode &quot;modified UTF-8&quot;.

<span class="nc bnc" id="L999" title="All 2 branches missed.">             if (s.charAt(begin++) != '%') {</span>
<span class="nc" id="L1000">                throw new IllegalArgumentException();</span>
             }

<span class="nc" id="L1003">             char ch2 = (char) Integer.parseInt(s.substring(begin, begin + 2), 16);</span>
<span class="nc" id="L1004">             begin += 2;</span>

<span class="nc bnc" id="L1006" title="All 2 branches missed.">             if ((ch &amp; 0xe0) == 0xc0) {</span>
<span class="nc" id="L1007">                ch = (char) (((ch &amp; 0x1f) &lt;&lt; 6) | (ch2 &amp; 0x3f));</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">             } else if ((ch &amp; 0xf0) == 0xe0) {</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">                if (s.charAt(begin++) != '%') {</span>
<span class="nc" id="L1010">                   throw new IllegalArgumentException();</span>
                }

<span class="nc" id="L1013">                char ch3 = (char) Integer.parseInt(s.substring(begin, begin + 2), 16);</span>
<span class="nc" id="L1014">                begin += 2;</span>

<span class="nc" id="L1016">                ch = (char) (((ch &amp; 0x0f) &lt;&lt; 12) | ((ch2 &amp; 0x3f) &lt;&lt; 6) | (ch3 &amp; 0x3f));</span>
<span class="nc" id="L1017">             } else {</span>
<span class="nc" id="L1018">                throw new IllegalArgumentException();</span>
             }
          }

<span class="nc" id="L1022">          builder.append(ch);</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">       } while ((i = s.indexOf('%', begin)) != -1);</span>

<span class="nc" id="L1025">       builder.append(s, begin, s.length());</span>

<span class="nc" id="L1027">       return builder.toString();</span>
    }

    /**
     * Implement this method to map metadata resources to the persistent
     * types contained within them. The method will be called when
     * {@link #getPersistentTypeNames} is invoked.
     */
    protected void mapPersistentTypeNames(Object rsrc, String[] names) {
<span class="nc" id="L1036">    }</span>

    /**
     * Return a metadata filter that identifies metadata resources when
     * performing jar and classpath scans.
     */
    protected abstract MetaDataFilter newMetaDataFilter();

    @Override
    public void clear() {
<span class="nc" id="L1046">        super.clear();</span>
<span class="nc" id="L1047">        _typeNames = null;</span>
<span class="nc" id="L1048">    }</span>

    /**
     * Internal parser interface.
     */
    public interface Parser
        extends MetaDataParser {

        /**
         * Returns the repository for this parser. If none has been set,
         * creates a new repository and sets it.
         */
        MetaDataRepository getRepository();

        /**
         * The parse mode according to the expected document type.
         */
        void setMode(int mode);
    }

    /**
     * Internal serializer interface.
     */
    public interface Serializer
        extends MetaDataSerializer {

        /**
         * The serialization mode according to the expected document type. The
         * mode constants act as bit flags, and therefore can be combined.
         */
        void setMode(int mode);

        /**
         * Add a class meta data to the set to be serialized.
         */
        void addMetaData(ClassMetaData meta);

        /**
         * Remove a class meta data from the set to be serialized.
         */
        boolean removeMetaData(ClassMetaData meta);

        /**
         * Add a sequence meta data to the set to be serialized.
         */
        void addSequenceMetaData(SequenceMetaData meta);

        /**
         * Add a query meta data to the set to be serialized.
         */
        void addQueryMetaData(QueryMetaData meta);

        /**
         * Add all components in the given repository to the set to be
         * serialized.
         */
        void addAll (MetaDataRepository repos);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>