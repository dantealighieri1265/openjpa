<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MetaDataRepository.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-kernel</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.meta</a> &gt; <span class="el_source">MetaDataRepository.java</span></div><h1>MetaDataRepository.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.meta;

import java.io.Serializable;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;

import org.apache.openjpa.conf.OpenJPAConfiguration;
import org.apache.openjpa.enhance.DynamicPersistenceCapable;
import org.apache.openjpa.enhance.PCEnhancer;
import org.apache.openjpa.enhance.PCRegistry;
import org.apache.openjpa.enhance.PCRegistry.RegisterClassListener;
import org.apache.openjpa.enhance.PersistenceCapable;
import org.apache.openjpa.event.LifecycleEventManager;
import org.apache.openjpa.lib.conf.Configurable;
import org.apache.openjpa.lib.conf.Configuration;
import org.apache.openjpa.lib.conf.Configurations;
import org.apache.openjpa.lib.log.Log;
import org.apache.openjpa.lib.util.ClassUtil;
import org.apache.openjpa.lib.util.Closeable;
import org.apache.openjpa.lib.util.J2DoPrivHelper;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.lib.util.MultiClassLoader;
import org.apache.openjpa.lib.util.Options;
import org.apache.openjpa.lib.util.StringDistance;
import org.apache.openjpa.util.ClassResolver;
import org.apache.openjpa.util.ImplHelper;
import org.apache.openjpa.util.InternalException;
import org.apache.openjpa.util.MetaDataException;
import org.apache.openjpa.util.OpenJPAId;


/**
 * Repository of and factory for persistent metadata.
 *
 * @since 0.3.0
 * @author Abe White
 * @author Steve Kim (query metadata)
 */
public class MetaDataRepository implements PCRegistry.RegisterClassListener, Configurable, Closeable, MetaDataModes,
    Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * Constant to not validate any metadata.
     */
    public static final int VALIDATE_NONE = 0;

    /**
     * Bit flag to validate metadata.
     */
    public static final int VALIDATE_META = 1;

    /**
     * Bit flag to validate mappings.
     */
    public static final int VALIDATE_MAPPING = 2;

    /**
     * Bit flag to validate unenhanced metadata only.
     */
    public static final int VALIDATE_UNENHANCED = 4;

    /**
     * Bit flag for runtime validation. Requires that all classes are enhanced, and performs extra
     * field resolution steps.
     */
    public static final int VALIDATE_RUNTIME = 8;

<span class="nc" id="L101">    protected static final Class&lt;?&gt;[] EMPTY_CLASSES = new Class[0];</span>
<span class="nc" id="L102">    protected static final NonPersistentMetaData[] EMPTY_NON_PERSISTENT = new NonPersistentMetaData[0];</span>
    protected final ClassMetaData[] EMPTY_METAS;
    protected final FieldMetaData[] EMPTY_FIELDS;
    protected final Order[] EMPTY_ORDERS;

<span class="nc" id="L107">    private static final Localizer _loc = Localizer.forPackage(MetaDataRepository.class);</span>

    // system sequence
<span class="nc" id="L110">    private SequenceMetaData _sysSeq = null;</span>
    // cache of parsed metadata, oid class to class, and interface class
    // to metadatas
<span class="nc" id="L113">    private Map&lt;Class&lt;?&gt;, ClassMetaData&gt; _metas = new HashMap&lt;&gt;();</span>
<span class="nc" id="L114">    private Map&lt;String, ClassMetaData&gt; _metaStringMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L115">    private Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; _oids = Collections.synchronizedMap(new HashMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;());</span>
<span class="nc" id="L116">    private Map&lt;Class&lt;?&gt;, Collection&lt;Class&lt;?&gt;&gt;&gt; _impls =</span>
<span class="nc" id="L117">        Collections.synchronizedMap(new HashMap&lt;Class&lt;?&gt;, Collection&lt;Class&lt;?&gt;&gt;&gt;());</span>
<span class="nc" id="L118">    private Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; _ifaces = Collections.synchronizedMap(new HashMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;());</span>
<span class="nc" id="L119">    private Map&lt;String, QueryMetaData&gt; _queries = new HashMap&lt;&gt;();</span>
<span class="nc" id="L120">    private Map&lt;String, SequenceMetaData&gt; _seqs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L121">    private Map&lt;String, List&lt;Class&lt;?&gt;&gt;&gt; _aliases = Collections.synchronizedMap(new HashMap&lt;String, List&lt;Class&lt;?&gt;&gt;&gt;());</span>
<span class="nc" id="L122">    private Map&lt;Class&lt;?&gt;, NonPersistentMetaData&gt; _pawares =</span>
<span class="nc" id="L123">        Collections.synchronizedMap(new HashMap&lt;Class&lt;?&gt;, NonPersistentMetaData&gt;());</span>
<span class="nc" id="L124">    private Map&lt;Class&lt;?&gt;, NonPersistentMetaData&gt; _nonMapped =</span>
<span class="nc" id="L125">        Collections.synchronizedMap(new HashMap&lt;Class&lt;?&gt;, NonPersistentMetaData&gt;());</span>
<span class="nc" id="L126">    private Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; _metamodel = Collections.synchronizedMap(new HashMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;());</span>

    // map of classes to lists of their subclasses
<span class="nc" id="L129">    private Map&lt;Class&lt;?&gt;, Collection&lt;Class&lt;?&gt;&gt;&gt; _subs =</span>
<span class="nc" id="L130">            Collections.synchronizedMap(new HashMap&lt;Class&lt;?&gt;, Collection&lt;Class&lt;?&gt;&gt;&gt;());</span>

    // xml mapping
    protected final XMLMetaData[] EMPTY_XMLMETAS;
<span class="nc" id="L134">    private final Map&lt;Class&lt;?&gt;, XMLMetaData&gt; _xmlmetas = new HashMap&lt;&gt;();</span>

<span class="nc" id="L136">    private transient OpenJPAConfiguration _conf = null;</span>
<span class="nc" id="L137">    private transient Log _log = null;</span>
<span class="nc" id="L138">    private transient InterfaceImplGenerator _implGen = null;</span>
<span class="nc" id="L139">    private transient MetaDataFactory _factory = null;</span>

<span class="nc" id="L141">    private int _resMode = MODE_META | MODE_MAPPING;</span>
<span class="nc" id="L142">    private int _sourceMode = MODE_META | MODE_MAPPING | MODE_QUERY;</span>
<span class="nc" id="L143">    private int _validate = VALIDATE_META | VALIDATE_UNENHANCED;</span>

    // we buffer up any classes that register themselves to prevent
    // reentrancy errors if classes register during a current parse (common)
<span class="nc" id="L147">    private final Collection&lt;Class&lt;?&gt;&gt; _registered = new HashSet&lt;&gt;();</span>

    // set of metadatas we're in the process of resolving
<span class="nc" id="L150">    private final List&lt;ClassMetaData&gt; _resolving = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L151">    private final List&lt;ClassMetaData&gt; _mapping = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L152">    private final List&lt;RuntimeException&gt; _errs = new LinkedList&lt;&gt;();</span>

    // system listeners
<span class="nc" id="L155">    private LifecycleEventManager.ListenerList _listeners = new LifecycleEventManager.ListenerList(3);</span>
<span class="nc" id="L156">    private boolean _systemListenersActivated = false;</span>

<span class="nc" id="L158">    protected boolean _preload = false;</span>
<span class="nc" id="L159">    protected boolean _preloadComplete = false;</span>
<span class="nc" id="L160">    protected boolean _locking = true;</span>
    private static final String PRELOAD_STR = &quot;Preload&quot;;

    // A boolean used to decide whether or not we need to call to PCEnhancer to check whether we have any down level
    // Entities.
<span class="nc" id="L165">    private boolean _logEnhancementLevel = true;</span>

    // A boolean used to decide whether to filter Class&lt;?&gt; objects submitted by the PCRegistry listener system
<span class="nc" id="L168">    private boolean _filterRegisteredClasses = false;</span>

    // we should skip these types for the enhancement
    private Collection&lt;Class&lt;?&gt;&gt; _typesWithoutEnhancement;

    /**
     * Default constructor. Configure via {@link Configurable}.
     */
<span class="nc" id="L176">    public MetaDataRepository() {</span>
<span class="nc" id="L177">        EMPTY_METAS = newClassMetaDataArray(0);</span>
<span class="nc" id="L178">        EMPTY_FIELDS = newFieldMetaDataArray(0);</span>
<span class="nc" id="L179">        EMPTY_ORDERS = newOrderArray(0);</span>
<span class="nc" id="L180">        EMPTY_XMLMETAS = newXMLClassMetaDataArray(0);</span>

<span class="nc" id="L182">    }</span>

    /**
     * Return the configuration for the repository.
     */
    public OpenJPAConfiguration getConfiguration() {
<span class="nc" id="L188">        return _conf;</span>
    }

    /**
     * Return the metadata log.
     */
    public Log getLog() {
<span class="nc" id="L195">        return _log;</span>
    }

    /**
     * The I/O used to load metadata.
     */
    public MetaDataFactory getMetaDataFactory() {
<span class="nc" id="L202">        return _factory;</span>
    }

    /**
     * The I/O used to load metadata.
     */
    public void setMetaDataFactory(MetaDataFactory factory) {
<span class="nc" id="L209">        factory.setRepository(this);</span>
<span class="nc" id="L210">        _factory = factory;</span>
<span class="nc" id="L211">    }</span>

    /**
     * The metadata validation level. Defaults to &lt;code&gt;VALIDATE_META | VALIDATE_UNENHANCED&lt;/code&gt;.
     */
    public int getValidate() {
<span class="nc" id="L217">        return _validate;</span>
    }

    /**
     * The metadata validation level. Defaults to &lt;code&gt;VALIDATE_META | VALIDATE_UNENHANCED&lt;/code&gt;.
     */
    public void setValidate(int validate) {
<span class="nc" id="L224">        _validate = validate;</span>
<span class="nc" id="L225">    }</span>

    /**
     * The metadata validation level. Defaults to
     * &lt;code&gt;VALIDATE_META | VALIDATE_MAPPING | VALIDATE_UNENHANCED&lt;/code&gt;.
     */
    public void setValidate(int validate, boolean on) {
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (validate == VALIDATE_NONE)</span>
<span class="nc" id="L233">            _validate = validate;</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        else if (on)</span>
<span class="nc" id="L235">            _validate |= validate;</span>
        else
<span class="nc" id="L237">            _validate &amp;= ~validate;</span>
<span class="nc" id="L238">    }</span>

    /**
     * The metadata resolution mode. Defaults to &lt;code&gt;MODE_META | MODE_MAPPING&lt;/code&gt;.
     */
    public int getResolve() {
<span class="nc" id="L244">        return _resMode;</span>
    }

    /**
     * The metadata resolution mode. Defaults to &lt;code&gt;MODE_META | MODE_MAPPING&lt;/code&gt;.
     */
    public void setResolve(int mode) {
<span class="nc" id="L251">        _resMode = mode;</span>
<span class="nc" id="L252">    }</span>

    /**
     * The metadata resolution mode. Defaults to &lt;code&gt;MODE_META | MODE_MAPPING&lt;/code&gt;.
     */
    public void setResolve(int mode, boolean on) {
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (mode == MODE_NONE)</span>
<span class="nc" id="L259">            _resMode = mode;</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        else if (on)</span>
<span class="nc" id="L261">            _resMode |= mode;</span>
        else
<span class="nc" id="L263">            _resMode &amp;= ~mode;</span>
<span class="nc" id="L264">    }</span>

    /**
     * The source mode determining what metadata to load. Defaults to
     * &lt;code&gt;MODE_META | MODE_MAPPING | MODE_QUERY&lt;/code&gt;.
     */
    public int getSourceMode() {
<span class="nc" id="L271">        return _sourceMode;</span>
    }

    /**
     * The source mode determining what metadata to load. Defaults to
     * &lt;code&gt;MODE_META | MODE_MAPPING | MODE_QUERY&lt;/code&gt;.
     */
    public void setSourceMode(int mode) {
<span class="nc" id="L279">        _sourceMode = mode;</span>
<span class="nc" id="L280">    }</span>

    /**
     * The source mode determining what metadata to load. Defaults to
     * &lt;code&gt;MODE_META | MODE_MAPPING | MODE_QUERY&lt;/code&gt;.
     */
    public void setSourceMode(int mode, boolean on) {
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (mode == MODE_NONE)</span>
<span class="nc" id="L288">            _sourceMode = mode;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        else if (on)</span>
<span class="nc" id="L290">            _sourceMode |= mode;</span>
        else
<span class="nc" id="L292">            _sourceMode &amp;= ~mode;</span>
<span class="nc" id="L293">    }</span>

    /**
     * Sets whether this repository will load all known persistent classes at initialization.
     * Defaults to false.
     */
    public boolean getPreload() {
<span class="nc" id="L300">        return _preload;</span>
    }

    /**
     * Sets whether this repository will load all known persistent classes at initialization.
     * Defaults to false.
     */
    public void setPreload(boolean l) {
<span class="nc" id="L308">        _preload = l;</span>
<span class="nc" id="L309">    }</span>


     /**
     * If the openjpa.MetaDataRepository plugin value Preload=true is set, this method will load all
     * MetaData for all persistent classes and will remove locking from this class.
     */
    public synchronized void preload() {
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (_preload == false) {</span>
<span class="nc" id="L318">            return;</span>
        }
        // If pooling EMFs, this method may be invoked more than once. Only perform this work once.
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (_preloadComplete == true) {</span>
<span class="nc" id="L322">            return;</span>
        }


<span class="nc" id="L326">        MultiClassLoader multi = AccessController.doPrivileged(J2DoPrivHelper.newMultiClassLoaderAction());</span>
<span class="nc" id="L327">        multi.addClassLoader(AccessController.doPrivileged(J2DoPrivHelper.getContextClassLoaderAction()));</span>
<span class="nc" id="L328">        multi.addClassLoader(AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc" id="L329">            .getClassLoaderAction(MetaDataRepository.class)));</span>
        // If a ClassLoader was passed into Persistence.createContainerEntityManagerFactory on the PersistenceUnitInfo
        // we need to add that loader to the chain of classloaders
<span class="nc" id="L332">        ClassResolver resolver = _conf.getClassResolverInstance();</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (resolver != null) {</span>
<span class="nc" id="L334">            ClassLoader cl = resolver.getClassLoader(null, null);</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">            if (cl != null) {</span>
<span class="nc" id="L336">                multi.addClassLoader(cl);</span>
            }
        }

<span class="nc" id="L340">        Set&lt;String&gt; classes = getPersistentTypeNames(false, multi);</span>
<span class="nc bnc" id="L341" title="All 4 branches missed.">        if (classes == null || classes.size() == 0) {</span>
<span class="nc" id="L342">            throw new MetaDataException(_loc.get(&quot;repos-initializeEager-none&quot;));</span>
        }
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (_log.isTraceEnabled() == true) {</span>
<span class="nc" id="L345">            _log.trace(_loc.get(&quot;repos-initializeEager-found&quot;, classes));</span>
        }

<span class="nc" id="L348">        List&lt;Class&lt;?&gt;&gt; loaded = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        for (String c : classes) {</span>
            try {
<span class="nc" id="L351">                Class&lt;?&gt; cls = AccessController.doPrivileged((J2DoPrivHelper.getForNameAction(c, true, multi)));</span>
<span class="nc" id="L352">                loaded.add(cls);</span>
                // This call may be unnecessary?
<span class="nc" id="L354">                _factory.load(cls, MODE_ALL, multi);</span>
<span class="nc" id="L355">            } catch (PrivilegedActionException pae) {</span>
<span class="nc" id="L356">                throw new MetaDataException(_loc.get(&quot;repos-initializeEager-error&quot;), pae);</span>
<span class="nc" id="L357">            }</span>
<span class="nc" id="L358">        }</span>
<span class="nc" id="L359">        resolveAll(multi);</span>

        // Preload XML MetaData
<span class="nc bnc" id="L362" title="All 2 branches missed.">        for (Class&lt;?&gt; cls : loaded) {</span>
<span class="nc" id="L363">            ClassMetaData cmd = getCachedMetaData(cls);</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            if (cmd != null) {</span>
<span class="nc" id="L365">                getXMLMetaData(cls);</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                for (FieldMetaData fmd : cmd.getFields()) {</span>
<span class="nc" id="L367">                    getXMLMetaData(fmd.getDeclaredType());</span>
                }
            }
<span class="nc" id="L370">        }</span>

        // Hook in this class as a listener and process registered classes list to populate _aliases
        // list.
<span class="nc" id="L374">        PCRegistry.addRegisterClassListener(this);</span>
<span class="nc" id="L375">        processRegisteredClasses(multi);</span>
<span class="nc" id="L376">        _locking = false;</span>
<span class="nc" id="L377">        _preloadComplete = true;</span>
<span class="nc" id="L378">    }</span>


    /**
     * Return the metadata for the given class.
     *
     * @param cls
     *            the class to retrieve metadata for
     * @param envLoader
     *            the environmental class loader, if any
     * @param mustExist
     *            if true, throws a {@link MetaDataException} if no metadata is found
     */
    public ClassMetaData getMetaData(Class&lt;?&gt; cls, ClassLoader envLoader, boolean mustExist) {
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L393">            synchronized(this){</span>
<span class="nc" id="L394">                return getMetaDataInternal(cls, envLoader, mustExist);</span>
            }
        } else {
<span class="nc" id="L397">            return getMetaDataInternal(cls, envLoader, mustExist);</span>
        }
    }

    private ClassMetaData getMetaDataInternal(Class&lt;?&gt; cls, ClassLoader envLoader, boolean mustExist) {
<span class="nc" id="L402">        ClassMetaData meta = getMetaDataInternal(cls, envLoader);</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (meta == null) {</span>
<span class="nc bnc" id="L404" title="All 4 branches missed.">            if (cls != null &amp;&amp; DynamicPersistenceCapable.class.isAssignableFrom(cls))</span>
<span class="nc" id="L405">                cls = cls.getSuperclass();</span>

            // if cls is a generated interface, use the user interface
            // to locate metadata
<span class="nc bnc" id="L409" title="All 6 branches missed.">            if (cls != null &amp;&amp; _implGen != null &amp;&amp; _implGen.isImplType(cls))</span>
<span class="nc" id="L410">                cls = _implGen.toManagedInterface(cls);</span>
<span class="nc" id="L411">            meta = getMetaDataInternal(cls, envLoader);</span>
        }
<span class="nc bnc" id="L413" title="All 4 branches missed.">        if (meta == null &amp;&amp; mustExist) {</span>
<span class="nc bnc" id="L414" title="All 4 branches missed.">            if (cls != null &amp;&amp; !ImplHelper.isManagedType(_conf, cls))</span>
<span class="nc" id="L415">                throw new MetaDataException(_loc.get(&quot;no-meta-notpc&quot;, cls)).setFatal(false);</span>

<span class="nc" id="L417">            Set&lt;String&gt; pcNames = getPersistentTypeNames(false, envLoader);</span>
<span class="nc bnc" id="L418" title="All 4 branches missed.">            if (pcNames != null &amp;&amp; pcNames.size() &gt; 0)</span>
<span class="nc" id="L419">                throw new MetaDataException(_loc.get(&quot;no-meta-types&quot;, cls, pcNames));</span>

<span class="nc" id="L421">            throw new MetaDataException(_loc.get(&quot;no-meta&quot;, cls));</span>
        }
<span class="nc" id="L423">        resolve(meta);</span>
<span class="nc" id="L424">        return meta;</span>
    }

    /**
     * Return the metadata for the given alias name.
     *
     * @param alias
     *            the alias to class to retrieve metadata for
     * @param envLoader
     *            the environmental class loader, if any
     * @param mustExist
     *            if true, throws a {@link MetaDataException} if no metadata is found
     * @see ClassMetaData#getTypeAlias
     */
    public ClassMetaData getMetaData(String alias, ClassLoader envLoader, boolean mustExist) {
<span class="nc bnc" id="L439" title="All 4 branches missed.">        if (alias == null &amp;&amp; mustExist)</span>
<span class="nc" id="L440">            throw new MetaDataException(_loc.get(&quot;no-alias-meta&quot;, alias, _aliases));</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">        if (alias == null)</span>
<span class="nc" id="L442">            return null;</span>

        // check cache
<span class="nc" id="L445">        processRegisteredClasses(envLoader);</span>
<span class="nc" id="L446">        List&lt;Class&lt;?&gt;&gt; classList = _aliases.get(alias);</span>

        // multiple classes may have been defined with the same alias: we
        // will filter by checking against the current list of the
        // persistent types and filter based on which classes are loadable
        // via the current environment's ClassLoader
<span class="nc" id="L452">        Set&lt;String&gt; pcNames = getPersistentTypeNames(false, envLoader);</span>
<span class="nc" id="L453">        Class&lt;?&gt; cls = null;</span>
<span class="nc bnc" id="L454" title="All 4 branches missed.">        for (int i = 0; classList != null &amp;&amp; i &lt; classList.size(); i++) {</span>
<span class="nc" id="L455">            Class&lt;?&gt; c = classList.get(i);</span>
            try {
                // re-load the class in the current environment loader so
                // that we can handle redeployment of the same class name
<span class="nc" id="L459">                Class&lt;?&gt; nc = Class.forName(c.getName(), false, envLoader);</span>

                // if we have specified a list of persistent clases,
                // also check to ensure that the class is in that list
<span class="nc bnc" id="L463" title="All 6 branches missed.">                if (pcNames == null || pcNames.size() == 0 || pcNames.contains(nc.getName())) {</span>
<span class="nc" id="L464">                    cls = nc;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                    if (!classList.contains(cls))</span>
<span class="nc" id="L466">                        classList.add(cls);</span>
<span class="nc" id="L467">                    break;</span>
                }
<span class="nc" id="L469">            } catch (Throwable t) {</span>
                // this happens when the class is not loadable by
                // the environment class loader, so it was probably
                // listed elsewhere; also ignore linkage failures and
                // other class loading problems
<span class="nc" id="L474">            }</span>
        }
<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (cls != null)</span>
<span class="nc" id="L477">            return getMetaData(cls, envLoader, mustExist);</span>

        // maybe this is some type we've seen but just isn't valid
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (_aliases.containsKey(alias)) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (mustExist)</span>
<span class="nc" id="L482">                throwNoRegisteredAlias(alias);</span>
<span class="nc" id="L483">            return null;</span>
        }

        // We need to synchronize on _aliases because a ConcurrentModificationException can if there
        // is a thread in getAliasNames() AND this class isn't using any locking.
<span class="nc" id="L488">        synchronized (_aliases) {</span>
            // record that this is an invalid type
<span class="nc" id="L490">            _aliases.put(alias, null);</span>
<span class="nc" id="L491">        }</span>

<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (!mustExist)</span>
<span class="nc" id="L494">            return null;</span>
<span class="nc" id="L495">        return throwNoRegisteredAlias(alias);</span>
    }

    private ClassMetaData throwNoRegisteredAlias(String alias) {
<span class="nc" id="L499">        String close = getClosestAliasName(alias);</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (close != null)</span>
<span class="nc" id="L501">            throw new MetaDataException(_loc.get(&quot;no-alias-meta-hint&quot;, alias, _aliases, close));</span>
        else
<span class="nc" id="L503">            throw new MetaDataException(_loc.get(&quot;no-alias-meta&quot;, alias, _aliases));</span>
    }

    /**
     * @return the nearest match to the specified alias name
     * @since 1.1.0
     */
    public String getClosestAliasName(String alias) {
<span class="nc" id="L511">        Collection&lt;String&gt; aliases = getAliasNames();</span>
<span class="nc" id="L512">        return StringDistance.getClosestLevenshteinDistance(alias, aliases);</span>
    }

    /**
     * @return the registered alias names
     * @since 1.1.0
     */
    public Collection&lt;String&gt; getAliasNames() {
<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L521">            synchronized (_aliases) {</span>
<span class="nc" id="L522">                return getAliasNamesInternal();</span>
            }
        } else {
<span class="nc" id="L525">            return getAliasNamesInternal();</span>
        }
    }

    private Collection&lt;String&gt; getAliasNamesInternal() {
<span class="nc" id="L530">        Collection&lt;String&gt; aliases = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">        for(Map.Entry&lt;String, List&lt;Class&lt;?&gt;&gt;&gt; e : _aliases.entrySet()){</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">            if (e.getValue() != null) {</span>
<span class="nc" id="L533">                aliases.add(e.getKey());</span>
            }
<span class="nc" id="L535">        }</span>
<span class="nc" id="L536">        return aliases;</span>
    }

    /**
     * Internal method to get the metadata for the given class, without resolving it.
     */
    private ClassMetaData getMetaDataInternal(Class&lt;?&gt; cls, ClassLoader envLoader) {
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (cls == null)</span>
<span class="nc" id="L544">            return null;</span>

        // check cache for existing metadata, or give up if no metadata and
        // our list of configured persistent types doesn't include the class
<span class="nc" id="L548">        ClassMetaData meta = _metas.get(cls);</span>
<span class="nc bnc" id="L549" title="All 6 branches missed.">        if (meta != null &amp;&amp; ((meta.getSourceMode() &amp; MODE_META) != 0 || (_sourceMode &amp; MODE_META) == 0))</span>
<span class="nc" id="L550">            return meta;</span>

        // if runtime, cut off search if not in pc list. we don't do this at
        // dev time so that user can manipulate persistent classes he's writing
        // before adding them to the list
<span class="nc bnc" id="L555" title="All 2 branches missed.">        if ((_validate &amp; VALIDATE_RUNTIME) != 0) {</span>
<span class="nc" id="L556">            Set&lt;String&gt; pcNames = getPersistentTypeNames(false, envLoader);</span>
<span class="nc bnc" id="L557" title="All 4 branches missed.">            if (pcNames != null &amp;&amp; !pcNames.contains(cls.getName()))</span>
<span class="nc" id="L558">                return meta;</span>
        }

<span class="nc bnc" id="L561" title="All 2 branches missed.">        if (meta == null) {</span>
            // check to see if maybe we know this class has no metadata
<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (_metas.containsKey(cls))</span>
<span class="nc" id="L564">                return null;</span>

            // make sure this isn't an obviously bad class
<span class="nc bnc" id="L567" title="All 6 branches missed.">            if (cls.isPrimitive() || cls.getName().startsWith(&quot;java.&quot;) || cls == PersistenceCapable.class)</span>
<span class="nc" id="L568">                return null;</span>

            // designed to get around jikes 1.17 / JDK1.5 issue where static
            // initializers are not invoked when a class is referenced, so the
            // class never registers itself with the system
<span class="nc bnc" id="L573" title="All 2 branches missed.">            if ((_validate &amp; VALIDATE_RUNTIME) != 0) {</span>
                try {
<span class="nc" id="L575">                    Class.forName(cls.getName(), true, AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc" id="L576">                        .getClassLoaderAction(cls)));</span>
<span class="nc" id="L577">                } catch (Throwable t) {</span>
<span class="nc" id="L578">                }</span>
            }
        }

        // not in cache: load metadata or mappings depending on source mode.
        // loading metadata might also load mappings, but doesn't have to
<span class="nc" id="L584">        int mode = 0;</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if ((_sourceMode &amp; MODE_META) != 0)</span>
<span class="nc" id="L586">            mode = _sourceMode &amp; ~MODE_MAPPING;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        else if ((_sourceMode &amp; MODE_MAPPING) == 0)</span>
<span class="nc" id="L588">            mode = _sourceMode;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        if (mode != MODE_NONE) {</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L591">                _log.trace(_loc.get(&quot;load-cls&quot;, cls, toModeString(mode)));</span>
<span class="nc" id="L592">            _factory.load(cls, mode, envLoader);</span>
        }

        // check cache again
<span class="nc bnc" id="L596" title="All 2 branches missed.">        if (meta == null)</span>
<span class="nc" id="L597">            meta = _metas.get(cls);</span>
<span class="nc bnc" id="L598" title="All 6 branches missed.">        if (meta != null &amp;&amp; ((meta.getSourceMode() &amp; MODE_META) != 0 || (_sourceMode &amp; MODE_META) == 0))</span>
<span class="nc" id="L599">            return meta;</span>

        // record that this class has no metadata; checking for this later
        // speeds things up in environments with slow class loading
        // like appservers
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if (meta != null)</span>
<span class="nc" id="L605">            removeMetaData(meta);</span>
<span class="nc" id="L606">        _metas.put(cls, null);</span>
<span class="nc" id="L607">        return null;</span>
    }

    /**
     * Return a string representation of the given mode flags.
     */
    private static String toModeString(int mode) {
<span class="nc" id="L614">        StringBuilder buf = new StringBuilder(31);</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">        if ((mode &amp; MODE_META) != 0)</span>
<span class="nc" id="L616">            buf.append(&quot;[META]&quot;);</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if ((mode &amp; MODE_QUERY) != 0)</span>
<span class="nc" id="L618">            buf.append(&quot;[QUERY]&quot;);</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">        if ((mode &amp; MODE_MAPPING) != 0)</span>
<span class="nc" id="L620">            buf.append(&quot;[MAPPING]&quot;);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">        if ((mode &amp; MODE_MAPPING_INIT) != 0)</span>
<span class="nc" id="L622">            buf.append(&quot;[MAPPING_INIT]&quot;);</span>
<span class="nc" id="L623">        return buf.toString();</span>
    }

    /**
     * Prepare metadata for mapping resolution. This method might map parts of the metadata that
     * don't rely on other classes being mapped, but that other classes might rely on during their
     * own mapping (for example, primary key fields). By default, this method only calls
     * {@link ClassMetaData#defineSuperclassFields}.
     */
    protected void prepareMapping(ClassMetaData meta) {
<span class="nc" id="L633">        meta.defineSuperclassFields(false);</span>
<span class="nc" id="L634">    }</span>

    /**
     * Resolve the given metadata if needed. There are three goals:
     * &lt;ol&gt;
     * &lt;li&gt;Make sure no unresolved metadata gets back to the client.&lt;/li&gt;
     * &lt;li&gt;Avoid infinite reentrant calls for mutually-dependent metadatas by allowing unresolved
     * metadata to be returned to other metadatas.&lt;/li&gt;
     * &lt;li&gt;Always make sure the superclass metadata is resolved before the subclass metadata so that
     * the subclass can access the super's list of fields.&lt;/li&gt;
     * &lt;/ol&gt;
     * Note that the code calling this method is synchronized, so this method doesn't have to be.
     */
    private void resolve(ClassMetaData meta) {
        // return anything that has its metadata resolved, because that means
        // it is either fully resolved or must at least be in the process of
        // resolving mapping, etc since we do that right after meta resolve
<span class="nc bnc" id="L651" title="All 6 branches missed.">        if (meta == null || _resMode == MODE_NONE || (meta.getResolve() &amp; MODE_META) != 0)</span>
<span class="nc" id="L652">            return;</span>

        // resolve metadata
<span class="nc" id="L655">        List&lt;ClassMetaData&gt; resolved = resolveMeta(meta);</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">        if (resolved == null)</span>
<span class="nc" id="L657">            return;</span>

        // load mapping data
<span class="nc bnc" id="L660" title="All 2 branches missed.">        for (int i = 0; i &lt; resolved.size(); i++)</span>
<span class="nc" id="L661">            loadMapping(resolved.get(i));</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        for (int i = 0; i &lt; resolved.size(); i++)</span>
<span class="nc" id="L663">            preMapping(resolved.get(i));</span>

        // resolve mappings
<span class="nc" id="L666">        boolean err = true;</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">        if ((_resMode &amp; MODE_MAPPING) != 0)</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">            for (int i = 0; i &lt; resolved.size(); i++)</span>
<span class="nc" id="L669">                err &amp;= resolveMapping(resolved.get(i));</span>

        // throw errors encountered
        // OPENJPA-1535 Always throw a MetaDataException because callers
        // of loadRegisteredClassMetaData expect only MetaDataException
        // to be thrown.
<span class="nc bnc" id="L675" title="All 4 branches missed.">        if (err &amp;&amp; !_errs.isEmpty()) {</span>
            RuntimeException re;
<span class="nc bnc" id="L677" title="All 4 branches missed.">            if ((_errs.size() == 1) &amp;&amp; (_errs.get(0) instanceof MetaDataException)) {</span>
<span class="nc" id="L678">                re = _errs.get(0);</span>
            } else {
<span class="nc" id="L680">                re = new MetaDataException(_loc.get(&quot;resolve-errs&quot;))</span>
<span class="nc" id="L681">                    .setNestedThrowables(_errs</span>
<span class="nc" id="L682">                    .toArray(new Exception[_errs.size()]));</span>
            }
<span class="nc" id="L684">            _errs.clear();</span>
<span class="nc" id="L685">            throw re;</span>
        }
<span class="nc" id="L687">    }</span>

    /**
     * Resolve metadata mode, returning list of processed metadadatas, or null if we're still in the
     * process of resolving other metadatas.
     */
    private List&lt;ClassMetaData&gt; resolveMeta(ClassMetaData meta) {
<span class="nc bnc" id="L694" title="All 2 branches missed.">        if (meta.getPCSuperclass() == null) {</span>
            // set superclass
<span class="nc" id="L696">            Class&lt;?&gt; sup = meta.getDescribedType().getSuperclass();</span>
            ClassMetaData supMeta;
<span class="nc bnc" id="L698" title="All 4 branches missed.">            while (sup != null &amp;&amp; sup != Object.class) {</span>
<span class="nc" id="L699">                supMeta = getMetaData(sup, meta.getEnvClassLoader(), false);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">                if (supMeta != null) {</span>
<span class="nc" id="L701">                    meta.setPCSuperclass(sup);</span>
<span class="nc" id="L702">                    meta.setPCSuperclassMetaData(supMeta);</span>
<span class="nc" id="L703">                    break;</span>
                } else
<span class="nc" id="L705">                    sup = sup.getSuperclass();</span>
            }
<span class="nc bnc" id="L707" title="All 2 branches missed.">            if (meta.getDescribedType().isInterface()) {</span>
<span class="nc" id="L708">                Class&lt;?&gt;[] sups = meta.getDescribedType().getInterfaces();</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">                for (int i = 0; i &lt; sups.length; i++) {</span>
<span class="nc" id="L710">                    supMeta = getMetaData(sups[i], meta.getEnvClassLoader(), false);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">                    if (supMeta != null) {</span>
<span class="nc" id="L712">                        meta.setPCSuperclass(sup);</span>
<span class="nc" id="L713">                        meta.setPCSuperclassMetaData(supMeta);</span>
<span class="nc" id="L714">                        break;</span>
                    }
                }
            }
<span class="nc bnc" id="L718" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L719">                _log.trace(_loc.get(&quot;assigned-sup&quot;, meta, meta.getPCSuperclass()));</span>
        }

        // resolve relation primary key fields for mapping dependencies
<span class="nc" id="L723">        FieldMetaData[] fmds = meta.getDeclaredFields();</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++)</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">            if (fmds[i].isPrimaryKey())</span>
<span class="nc" id="L726">                getMetaData(fmds[i].getDeclaredType(), meta.getEnvClassLoader(), false);</span>

        // resolve metadata; if we're not in the process of resolving
        // others, this will return the set of interrelated metas that
        // resolved
<span class="nc" id="L731">        return processBuffer(meta, _resolving, MODE_META);</span>
    }

    /**
     * Load mapping information for the given metadata.
     */
    private void loadMapping(ClassMetaData meta) {
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if ((meta.getResolve() &amp; MODE_MAPPING) != 0)</span>
<span class="nc" id="L739">            return;</span>

        // load mapping information
<span class="nc bnc" id="L742" title="All 4 branches missed.">        if ((meta.getSourceMode() &amp; MODE_MAPPING) == 0 &amp;&amp; (_sourceMode &amp; MODE_MAPPING) != 0) {</span>
            // embedded-only metadata doesn't have mapping, so always loaded
<span class="nc bnc" id="L744" title="All 2 branches missed.">            if (meta.isEmbeddedOnly())</span>
<span class="nc" id="L745">                meta.setSourceMode(MODE_MAPPING, true);</span>
            else {
                // load mapping data
<span class="nc" id="L748">                int mode = _sourceMode &amp; ~MODE_META;</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                if (_log.isTraceEnabled())</span>
<span class="nc" id="L750">                    _log.trace(_loc.get(&quot;load-mapping&quot;, meta, toModeString(mode)));</span>
                try {
<span class="nc" id="L752">                    _factory.load(meta.getDescribedType(), mode, meta.getEnvClassLoader());</span>
<span class="nc" id="L753">                } catch (RuntimeException re) {</span>
<span class="nc" id="L754">                    removeMetaData(meta);</span>
<span class="nc" id="L755">                    _errs.add(re);</span>
<span class="nc" id="L756">                }</span>
            }
        }
<span class="nc" id="L759">    }</span>

    /**
     * Pre-mapping preparation.
     */
    private void preMapping(ClassMetaData meta) {
<span class="nc bnc" id="L765" title="All 2 branches missed.">        if ((meta.getResolve() &amp; MODE_MAPPING) != 0)</span>
<span class="nc" id="L766">            return;</span>

        // prepare mappings for resolve; if not resolving mappings, then
        // make sure any superclass fields defined in metadata are resolved
        try {
<span class="nc bnc" id="L771" title="All 2 branches missed.">            if ((_resMode &amp; MODE_MAPPING) != 0) {</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">                if (_log.isTraceEnabled())</span>
<span class="nc" id="L773">                    _log.trace(_loc.get(&quot;prep-mapping&quot;, meta));</span>
<span class="nc" id="L774">                prepareMapping(meta);</span>
            } else
<span class="nc" id="L776">                meta.defineSuperclassFields(false);</span>
<span class="nc" id="L777">        } catch (RuntimeException re) {</span>
<span class="nc" id="L778">            removeMetaData(meta);</span>
<span class="nc" id="L779">            _errs.add(re);</span>
<span class="nc" id="L780">        }</span>
<span class="nc" id="L781">    }</span>

    /**
     * Resolve and initialize mapping.
     *
     * @return false if we're still in the process of resolving mappings
     */
    private boolean resolveMapping(ClassMetaData meta) {
<span class="nc" id="L789">        List&lt;ClassMetaData&gt; mapped = processBuffer(meta, _mapping, MODE_MAPPING);</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">        if (mapped == null)</span>
<span class="nc" id="L791">            return false;</span>

        // initialize mapping for runtime use
<span class="nc bnc" id="L794" title="All 2 branches missed.">        if ((_resMode &amp; MODE_MAPPING_INIT) != 0) {</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">            for (int i = 0; i &lt; mapped.size(); i++) {</span>
<span class="nc" id="L796">                meta = mapped.get(i);</span>
                try {
<span class="nc" id="L798">                    meta.resolve(MODE_MAPPING_INIT);</span>
<span class="nc" id="L799">                } catch (RuntimeException re) {</span>
<span class="nc" id="L800">                    removeMetaData(meta);</span>
<span class="nc" id="L801">                    _errs.add(re);</span>
<span class="nc" id="L802">                }</span>
            }
        }
<span class="nc" id="L805">        return true;</span>
    }

    /**
     * Process the given metadata and the associated buffer.
     */
    private List&lt;ClassMetaData&gt; processBuffer(ClassMetaData meta, List&lt;ClassMetaData&gt; buffer, int mode) {
        // add the metadata to the buffer unless an instance for the same entity
        // is already there
<span class="nc bnc" id="L814" title="All 2 branches missed.">        for (ClassMetaData cmd : buffer)</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">            if (cmd.getDescribedType().equals(meta.getDescribedType()))</span>
<span class="nc" id="L816">                return null;</span>

        // if we're already processing a metadata, just buffer this one; when
        // the initial metadata finishes processing, we traverse the buffer
        // and process all the others that were introduced during reentrant
        // calls
<span class="nc" id="L822">        buffer.add(meta);</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">        if (buffer.size() != 1)</span>
<span class="nc" id="L824">            return null;</span>

        // continually pop a metadata and process it until we run out; note
        // that each processing call might place more metas in the buffer as
        // one class tries to access metadata for another
        ClassMetaData buffered;
<span class="nc" id="L830">        List&lt;ClassMetaData&gt; processed = new ArrayList&lt;&gt;(5);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">        while (!buffer.isEmpty()) {</span>
<span class="nc" id="L832">            buffered = buffer.get(0);</span>
            try {
<span class="nc" id="L834">                buffered.resolve(mode);</span>
<span class="nc" id="L835">                processed.add(buffered);</span>
<span class="nc" id="L836">                buffer.remove(buffered);</span>
<span class="nc" id="L837">            } catch (RuntimeException re) {</span>
<span class="nc" id="L838">                _errs.add(re);</span>

                // any exception during resolution of one type means we can't
                // resolve any of the related types, so clear buffer. this also
                // ensures that if two types relate to each other and one
                // dies, we don't get into infinite cycles
<span class="nc bnc" id="L844" title="All 2 branches missed.">                for (ClassMetaData cmd : buffer) {</span>
<span class="nc" id="L845">                    removeMetaData(cmd);</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">                    if (cmd != buffered) {</span>
<span class="nc" id="L847">                        _errs.add(new MetaDataException(_loc.get(&quot;prev-errs&quot;, cmd, buffered)));</span>
                    }
<span class="nc" id="L849">                }</span>
<span class="nc" id="L850">                buffer.clear();</span>
<span class="nc" id="L851">            }</span>
        }

<span class="nc" id="L854">        return processed;</span>
    }

    /**
     * Return all the metadata instances currently in the repository.
     */
    public ClassMetaData[] getMetaDatas() {
<span class="nc bnc" id="L861" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L862">            synchronized(this){</span>
<span class="nc" id="L863">                return getMetaDatasInternal();</span>
            }
        } else {
<span class="nc" id="L866">            return getMetaDatasInternal();</span>
        }
    }

    private ClassMetaData[] getMetaDatasInternal() {
            // prevent concurrent mod errors when resolving one metadata
            // introduces others
<span class="nc" id="L873">            ClassMetaData[] metas = _metas.values().toArray(new ClassMetaData[_metas.size()]);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">            for (int i = 0; i &lt; metas.length; i++)</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">                if (metas[i] != null)</span>
<span class="nc" id="L876">                    getMetaData(metas[i].getDescribedType(), metas[i].getEnvClassLoader(), true);</span>

<span class="nc" id="L878">            List&lt;ClassMetaData&gt; resolved = new ArrayList&lt;&gt;(_metas.size());</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">            for (ClassMetaData meta : _metas.values()) {</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">                if (meta != null)</span>
<span class="nc" id="L881">                    resolved.add(meta);</span>
<span class="nc" id="L882">            }</span>
<span class="nc" id="L883">            metas = resolved.toArray(newClassMetaDataArray(resolved.size()));</span>
<span class="nc" id="L884">            Arrays.sort(metas);</span>
<span class="nc" id="L885">            return metas;</span>
    }

    /**
     * Return the cached metadata for the given class, without any resolution. Return null if none.
     */
    public ClassMetaData getCachedMetaData(Class&lt;?&gt; cls) {
<span class="nc" id="L892">        return _metas.get(cls);</span>
    }

    /**
     * Create a new metadata, populate it with default information, add it to the repository, and
     * return it. Use the default access type.
     */
    public ClassMetaData addMetaData(Class&lt;?&gt; cls) {
<span class="nc" id="L900">        return addMetaData(cls, AccessCode.UNKNOWN);</span>
    }

    /**
     * Create a new metadata, populate it with default information, add it to the repository, and
     * return it.
     *
     * @param access
     *            the access type to use in populating metadata
     */
    public ClassMetaData addMetaData(Class&lt;?&gt; cls, int access) {
<span class="nc" id="L911">        return addMetaData(cls, access, false);</span>
    }

    /**
     * Create a new metadata, populate it with default information, add it to the repository, and
     * return it.
     *
     * @param access
     *            the access type to use in populating metadata
     */
    public ClassMetaData addMetaData(Class&lt;?&gt; cls, int access, boolean ignoreTransient) {
<span class="nc bnc" id="L922" title="All 4 branches missed.">        if (cls == null || cls.isPrimitive())</span>
<span class="nc" id="L923">            return null;</span>

<span class="nc" id="L925">        ClassMetaData meta = newClassMetaData(cls);</span>
<span class="nc" id="L926">        _factory.getDefaults().populate(meta, access, ignoreTransient);</span>

        // synchronize on this rather than the map, because all other methods
        // that access _metas are synchronized on this
<span class="nc bnc" id="L930" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L931">            synchronized(this){</span>
<span class="nc" id="L932">                return metasPutInternal(cls, meta);</span>
            }
        } else {
<span class="nc" id="L935">            return metasPutInternal(cls, meta);</span>
        }

    }

    private ClassMetaData metasPutInternal(Class&lt;?&gt; cls, ClassMetaData meta){
<span class="nc bnc" id="L941" title="All 2 branches missed.">            if (_pawares.containsKey(cls))</span>
<span class="nc" id="L942">                throw new MetaDataException(_loc.get(&quot;pc-and-aware&quot;, cls));</span>
<span class="nc" id="L943">            _metas.put(cls, meta);</span>
<span class="nc" id="L944">        return meta;</span>
    }

    /**
     * Create a new class metadata instance.
     */
    protected ClassMetaData newClassMetaData(Class&lt;?&gt; type) {
<span class="nc" id="L951">        return new ClassMetaData(type, this);</span>
    }

    /**
     * Create a new array of the proper class metadata subclass.
     */
    protected ClassMetaData[] newClassMetaDataArray(int length) {
<span class="nc" id="L958">        return new ClassMetaData[length];</span>
    }

    /**
     * Create a new field metadata instance.
     */
    protected FieldMetaData newFieldMetaData(String name, Class&lt;?&gt; type, ClassMetaData owner) {
<span class="nc" id="L965">        return new FieldMetaData(name, type, owner);</span>
    }

    /**
     * Create a new array of the proper field metadata subclass.
     */
    protected FieldMetaData[] newFieldMetaDataArray(int length) {
<span class="nc" id="L972">        return new FieldMetaData[length];</span>
    }

    /**
     * Create a new array of the proper xml class metadata subclass.
     */
    protected XMLMetaData[] newXMLClassMetaDataArray(int length) {
<span class="nc" id="L979">        return new XMLClassMetaData[length];</span>
    }

    /**
     * Create a new embedded class metadata instance.
     */
    protected ClassMetaData newEmbeddedClassMetaData(ValueMetaData owner) {
<span class="nc" id="L986">        return new ClassMetaData(owner);</span>
    }

    /**
     * Create a new value metadata instance.
     */
    protected ValueMetaData newValueMetaData(FieldMetaData owner) {
<span class="nc" id="L993">        return new ValueMetaDataImpl(owner);</span>
    }

    /**
     * Create an {@link Order} for the given field and declaration. This method delegates to
     * {@link #newRelatedFieldOrder} and {@link #newValueOrder(FieldMetaData, boolean)} by default.
     */
    protected Order newOrder(FieldMetaData owner, String name, boolean asc) {
        // paths can start with (or equal) '#element'
<span class="nc bnc" id="L1002" title="All 2 branches missed.">        if (name.startsWith(Order.ELEMENT))</span>
<span class="nc" id="L1003">            name = name.substring(Order.ELEMENT.length());</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">        if (name.length() == 0)</span>
<span class="nc" id="L1005">            return newValueOrder(owner, asc);</span>

        // next token should be '.'
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (name.charAt(0) == '.')</span>
<span class="nc" id="L1009">            name = name.substring(1);</span>

        // related field
<span class="nc" id="L1012">        ClassMetaData meta = owner.getElement().getTypeMetaData();</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">        if (meta == null)</span>
<span class="nc" id="L1014">            throw new MetaDataException(_loc.get(&quot;nonpc-field-orderable&quot;, owner, name));</span>
<span class="nc" id="L1015">        FieldMetaData rel = getOrderByField(meta, name);</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">        if (rel == null)</span>
<span class="nc" id="L1017">            throw new MetaDataException(_loc.get(&quot;bad-field-orderable&quot;, owner, name));</span>
<span class="nc" id="L1018">        return newRelatedFieldOrder(owner, rel, asc);</span>
    }

    public FieldMetaData getOrderByField(ClassMetaData meta, String orderBy) {
<span class="nc" id="L1022">        FieldMetaData field = meta.getField(orderBy);</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">        if (field != null)</span>
<span class="nc" id="L1024">            return field;</span>
<span class="nc" id="L1025">        int dotIdx = orderBy.indexOf(&quot;.&quot;);</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">        if (dotIdx == -1)</span>
<span class="nc" id="L1027">            return null;</span>
<span class="nc" id="L1028">        String fieldName = orderBy.substring(0, dotIdx);</span>
<span class="nc" id="L1029">        FieldMetaData field1 = meta.getField(fieldName);</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">        if (field1 == null)</span>
<span class="nc" id="L1031">            return null;</span>
<span class="nc" id="L1032">        ClassMetaData meta1 = field1.getEmbeddedMetaData();</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        if (meta1 == null)</span>
<span class="nc" id="L1034">            return null;</span>
<span class="nc" id="L1035">        String mappedBy1 = orderBy.substring(dotIdx + 1);</span>
<span class="nc" id="L1036">        return getOrderByField(meta1, mappedBy1);</span>
    }

    /**
     * Order by the field value.
     */
    protected Order newValueOrder(FieldMetaData owner, boolean asc) {
<span class="nc" id="L1043">        return new InMemoryValueOrder(asc, getConfiguration());</span>
    }

    /**
     * Order by a field of the related type.
     */
    protected Order newRelatedFieldOrder(FieldMetaData owner, FieldMetaData rel, boolean asc) {
<span class="nc" id="L1050">        return new InMemoryRelatedFieldOrder(rel, asc, getConfiguration());</span>
    }

    /**
     * Create an array of orders of the given size.
     */
    protected Order[] newOrderArray(int size) {
<span class="nc" id="L1057">        return new Order[size];</span>
    }

    /**
     * Remove a metadata instance from the repository.
     *
     * @return true if removed, false if not in this repository
     */
    public boolean removeMetaData(ClassMetaData meta) {
<span class="nc bnc" id="L1066" title="All 2 branches missed.">        if (meta == null)</span>
<span class="nc" id="L1067">            return false;</span>
<span class="nc" id="L1068">        return removeMetaData(meta.getDescribedType());</span>
    }

    /**
     * Remove a metadata instance from the repository.
     *
     * @return true if removed, false if not in this repository
     */
    public boolean removeMetaData(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        if(_locking){</span>
<span class="nc" id="L1078">            synchronized(this){</span>
<span class="nc" id="L1079">                return removeMetaDataInternal(cls);</span>
            }
        }else{
<span class="nc" id="L1082">            return removeMetaDataInternal(cls);</span>
        }
    }

    private boolean removeMetaDataInternal(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L1087" title="All 2 branches missed.">            if (cls == null)</span>
<span class="nc" id="L1088">                return false;</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">            if (_metas.remove(cls) != null) {</span>
<span class="nc" id="L1090">                Class&lt;?&gt; impl = _ifaces.remove(cls);</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">                if (impl != null)</span>
<span class="nc" id="L1092">                    _metas.remove(impl);</span>
<span class="nc" id="L1093">                return true;</span>
            }
<span class="nc" id="L1095">            return false;</span>
    }
    /**
     * Add the given metadata as declared interface implementation.
     */
    void addDeclaredInterfaceImpl(ClassMetaData meta, Class&lt;?&gt; iface) {
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L1102">            synchronized (_impls) {</span>
<span class="nc" id="L1103">                addDeclaredInterfaceImplInternal(meta, iface);</span>
<span class="nc" id="L1104">            }</span>
        } else {
<span class="nc" id="L1106">            addDeclaredInterfaceImplInternal(meta, iface);</span>
        }
<span class="nc" id="L1108">    }</span>

   private void addDeclaredInterfaceImplInternal(ClassMetaData meta, Class&lt;?&gt; iface) {
<span class="nc" id="L1111">            Collection&lt;Class&lt;?&gt;&gt; vals = _impls.get(iface);</span>

            // check to see if the superclass already declares to avoid dups
<span class="nc bnc" id="L1114" title="All 2 branches missed.">            if (vals != null) {</span>
<span class="nc" id="L1115">                ClassMetaData sup = meta.getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">                for (; sup != null; sup = sup.getPCSuperclassMetaData())</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">                    if (vals.contains(sup.getDescribedType()))</span>
<span class="nc" id="L1118">                        return;</span>
            }
<span class="nc" id="L1120">            addToCollection(_impls, iface, meta.getDescribedType(), false);</span>
<span class="nc" id="L1121">        }</span>
    /**
     * Set the implementation for the given managed interface.
     */
    void setInterfaceImpl(ClassMetaData meta, Class&lt;?&gt; impl) {
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L1127">            synchronized (this) {</span>
<span class="nc" id="L1128">                setInterfaceImplInternal(meta, impl);</span>
<span class="nc" id="L1129">            }</span>
        } else {
<span class="nc" id="L1131">            setInterfaceImplInternal(meta, impl);</span>
        }
<span class="nc" id="L1133">    }</span>

    private void setInterfaceImplInternal(ClassMetaData meta, Class&lt;?&gt; impl) {
<span class="nc bnc" id="L1136" title="All 2 branches missed.">            if (!meta.isManagedInterface())</span>
<span class="nc" id="L1137">                throw new MetaDataException(_loc.get(&quot;not-managed-interface&quot;, meta, impl));</span>
<span class="nc" id="L1138">            _ifaces.put(meta.getDescribedType(), impl);</span>
<span class="nc" id="L1139">            addDeclaredInterfaceImpl(meta, meta.getDescribedType());</span>
<span class="nc" id="L1140">            ClassMetaData sup = meta.getPCSuperclassMetaData();</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">            while (sup != null) {</span>
                // record superclass interface info while we can as well as we
                // will only register concrete superclass in PCRegistry
<span class="nc" id="L1144">                sup.clearSubclassCache();</span>
<span class="nc" id="L1145">                addToCollection(_subs, sup.getDescribedType(), impl, true);</span>
<span class="nc" id="L1146">                sup = sup.getPCSuperclassMetaData();</span>
        }
<span class="nc" id="L1148">    }</span>

    InterfaceImplGenerator getImplGenerator() {
<span class="nc" id="L1151">        return _implGen;</span>
    }

    /**
     * Return the least-derived class metadata for the given application identity object.
     *
     * @param oid
     *            the oid to get the metadata for
     * @param envLoader
     *            the environmental class loader, if any
     * @param mustExist
     *            if true, throws a {@link MetaDataException} if no metadata is found
     */
    public ClassMetaData getMetaData(Object oid, ClassLoader envLoader, boolean mustExist) {
<span class="nc bnc" id="L1165" title="All 4 branches missed.">        if (oid == null &amp;&amp; mustExist)</span>
<span class="nc" id="L1166">            throw new MetaDataException(_loc.get(&quot;no-oid-meta&quot;, oid, &quot;?&quot;, _oids.toString()));</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">        if (oid == null)</span>
<span class="nc" id="L1168">            return null;</span>

<span class="nc bnc" id="L1170" title="All 2 branches missed.">        if (oid instanceof OpenJPAId) {</span>
<span class="nc" id="L1171">            Class&lt;?&gt; cls = ((OpenJPAId) oid).getType();</span>
<span class="nc" id="L1172">            return getMetaData(cls, envLoader, mustExist);</span>
        }

        // check cache
<span class="nc" id="L1176">        processRegisteredClasses(envLoader);</span>
<span class="nc" id="L1177">        Class&lt;?&gt; cls = _oids.get(oid.getClass());</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">        if (cls != null)</span>
<span class="nc" id="L1179">            return getMetaData(cls, envLoader, mustExist);</span>

        // maybe this is some type we've seen but just isn't valid
<span class="nc bnc" id="L1182" title="All 2 branches missed.">        if (_oids.containsKey(oid.getClass())) {</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">            if (mustExist)</span>
<span class="nc" id="L1184">                throw new MetaDataException(_loc.get(&quot;no-oid-meta&quot;, oid, oid.getClass(), _oids));</span>
<span class="nc" id="L1185">            return null;</span>
        }

        // if still not match, register any classes that look similar to the
        // oid class and check again
<span class="nc" id="L1190">        resolveIdentityClass(oid);</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">        if (processRegisteredClasses(envLoader).length &gt; 0) {</span>
<span class="nc" id="L1192">            cls = _oids.get(oid.getClass());</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">            if (cls != null)</span>
<span class="nc" id="L1194">                return getMetaData(cls, envLoader, mustExist);</span>
        }

        // record that this is an invalid type
<span class="nc" id="L1198">        _oids.put(oid.getClass(), null);</span>

<span class="nc bnc" id="L1200" title="All 2 branches missed.">        if (!mustExist)</span>
<span class="nc" id="L1201">            return null;</span>
<span class="nc" id="L1202">        throw new MetaDataException(_loc.get(&quot;no-oid-meta&quot;, oid, oid.getClass(), _oids)).setFailedObject(oid);</span>
    }

    /**
     * Make some guesses about the name of a target class for an unknown application identity class.
     */
    private void resolveIdentityClass(Object oid) {
<span class="nc bnc" id="L1209" title="All 2 branches missed.">        if (oid == null)</span>
<span class="nc" id="L1210">            return;</span>

<span class="nc" id="L1212">        Class&lt;?&gt; oidClass = oid.getClass();</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">        if (_log.isTraceEnabled())</span>
<span class="nc" id="L1214">            _log.trace(_loc.get(&quot;resolve-identity&quot;, oidClass));</span>

<span class="nc" id="L1216">        ClassLoader cl = AccessController.doPrivileged(J2DoPrivHelper.getClassLoaderAction(oidClass));</span>
        String className;
<span class="nc bnc" id="L1218" title="All 4 branches missed.">        while (oidClass != null &amp;&amp; oidClass != Object.class) {</span>
<span class="nc" id="L1219">            className = oidClass.getName();</span>

            // we take a brute-force approach: try to load all the class'
            // substrings. this will handle the following common naming cases:
            //
            // com.company.MyClass$ID -&gt; com.company.MyClass
            // com.company.MyClassId -&gt; com.company.MyClass
            // com.company.MyClassOid -&gt; com.company.MyClass
            // com.company.MyClassPK -&gt; com.company.MyClass
            //
            // this isn't the fastest thing possible, but this method will
            // only be called once per JVM per unknown app id class
<span class="nc bnc" id="L1231" title="All 2 branches missed.">            for (int i = className.length(); i &gt; 1; i--) {</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">                if (className.charAt(i - 1) == '.')</span>
<span class="nc" id="L1233">                    break;</span>

                try {
<span class="nc" id="L1236">                    Class.forName(className.substring(0, i), true, cl);</span>
<span class="nc" id="L1237">                } catch (Exception e) {</span>
<span class="nc" id="L1238">                } // consume all exceptions</span>
            }

            // move up the OID hierarchy
<span class="nc" id="L1242">            oidClass = oidClass.getSuperclass();</span>
        }
<span class="nc" id="L1244">    }</span>

    /**
     * Return all least-derived metadatas with some mapped assignable type that implement the given
     * class.
     *
     * @param cls
     *            the class or interface to retrieve implementors for
     * @param envLoader
     *            the environmental class loader, if any
     * @param mustExist
     *            if true, throws a {@link MetaDataException} if no metadata is found
     */
    public ClassMetaData[] getImplementorMetaDatas(Class&lt;?&gt; cls, ClassLoader envLoader, boolean mustExist) {
<span class="nc bnc" id="L1258" title="All 4 branches missed.">        if (cls == null &amp;&amp; mustExist)</span>
<span class="nc" id="L1259">            throw new MetaDataException(_loc.get(&quot;no-meta&quot;, cls));</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">        if (cls == null)</span>
<span class="nc" id="L1261">            return EMPTY_METAS;</span>

        // get impls of given interface / abstract class
<span class="nc" id="L1264">        loadRegisteredClassMetaData(envLoader);</span>
<span class="nc" id="L1265">        Collection&lt;Class&lt;?&gt;&gt; vals = _impls.get(cls);</span>
<span class="nc" id="L1266">        ClassMetaData[] mapped = null;</span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">        if (vals != null) {</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">            if (_locking) {</span>
<span class="nc" id="L1269">                synchronized (vals) {</span>
<span class="nc" id="L1270">                    mapped = getImplementorMetaDatasInternal(vals, envLoader, mustExist);</span>
<span class="nc" id="L1271">                }</span>
            } else {
<span class="nc" id="L1273">                mapped = getImplementorMetaDatasInternal(vals, envLoader, mustExist);</span>
            }
        }

<span class="nc bnc" id="L1277" title="All 4 branches missed.">        if (mapped == null &amp;&amp; mustExist)</span>
<span class="nc" id="L1278">            throw new MetaDataException(_loc.get(&quot;no-meta&quot;, cls));</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">        if (mapped == null)</span>
<span class="nc" id="L1280">            return EMPTY_METAS;</span>
<span class="nc" id="L1281">        return mapped;</span>
    }

    private ClassMetaData[] getImplementorMetaDatasInternal(Collection&lt;Class&lt;?&gt;&gt; classes, ClassLoader envLoader,
        boolean mustExist) {
<span class="nc" id="L1286">        Collection&lt;ClassMetaData&gt; mapped = new ArrayList&lt;&gt;(classes.size());</span>
<span class="nc" id="L1287">        ClassMetaData meta = null;</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">        for (Class&lt;?&gt; c : classes) {</span>
<span class="nc" id="L1289">            meta = getMetaData(c, envLoader, true);</span>
<span class="nc bnc" id="L1290" title="All 4 branches missed.">            if (meta.isMapped() || meta.getMappedPCSubclassMetaDatas().length &gt; 0) {</span>
<span class="nc" id="L1291">                mapped.add(meta);</span>
            }
<span class="nc" id="L1293">        }</span>
<span class="nc" id="L1294">        return mapped.toArray(new ClassMetaData[mapped.size()]);</span>
    }
    /**
     * Gets the metadata corresponding to the given persistence-aware class. Returns null, if the
     * given class is not registered as persistence-aware.
     */
    public NonPersistentMetaData getPersistenceAware(Class&lt;?&gt; cls) {
<span class="nc" id="L1301">        return _pawares.get(cls);</span>
    }

    public boolean skipMetadata(final Class&lt;?&gt; cls) {
<span class="nc bnc" id="L1305" title="All 4 branches missed.">        if (cls == null || cls.isEnum()) {</span>
<span class="nc" id="L1306">            return true;</span>
        }
<span class="nc bnc" id="L1308" title="All 2 branches missed.">        if (_typesWithoutEnhancement == null) {</span>
<span class="nc" id="L1309">            return false;</span>
        }
<span class="nc" id="L1311">        return _typesWithoutEnhancement.stream().anyMatch(it -&gt; it.isAssignableFrom(cls));</span>
    }

    /**
     * Gets all the metadatas for persistence-aware classes
     *
     * @return empty array if no class has been registered as pers-aware
     */
    public NonPersistentMetaData[] getPersistenceAwares() {
<span class="nc bnc" id="L1320" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L1321">            synchronized (_pawares) {</span>
<span class="nc" id="L1322">                return getPersistenceAwaresInternal();</span>
            }
        } else {
<span class="nc" id="L1325">            return getPersistenceAwaresInternal();</span>
        }
    }

    private NonPersistentMetaData[] getPersistenceAwaresInternal() {
<span class="nc bnc" id="L1330" title="All 2 branches missed.">            if (_pawares.isEmpty())</span>
<span class="nc" id="L1331">                return EMPTY_NON_PERSISTENT;</span>
<span class="nc" id="L1332">            return _pawares.values().toArray(new NonPersistentMetaData[_pawares.size()]);</span>
    }

    /**
     * Add the given class as persistence-aware.
     *
     * @param cls
     *            non-null and must not alreaddy be added as persitence-capable
     */
    public NonPersistentMetaData addPersistenceAware(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L1342" title="All 2 branches missed.">        if (cls == null)</span>
<span class="nc" id="L1343">            return null;</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L1345">            synchronized (this) {</span>
<span class="nc" id="L1346">                return addPersistenceAwareInternal(cls);</span>
            }
        } else {
<span class="nc" id="L1349">            return addPersistenceAwareInternal(cls);</span>
        }
    }

    private NonPersistentMetaData addPersistenceAwareInternal(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L1354" title="All 2 branches missed.">            if (_pawares.containsKey(cls))</span>
<span class="nc" id="L1355">                return _pawares.get(cls);</span>
<span class="nc bnc" id="L1356" title="All 2 branches missed.">            if (getCachedMetaData(cls) != null)</span>
<span class="nc" id="L1357">                throw new MetaDataException(_loc.get(&quot;pc-and-aware&quot;, cls));</span>
<span class="nc" id="L1358">            NonPersistentMetaData meta =</span>
                new NonPersistentMetaData(cls, this, NonPersistentMetaData.TYPE_PERSISTENCE_AWARE);
<span class="nc" id="L1360">            _pawares.put(cls, meta);</span>
<span class="nc" id="L1361">            return meta;</span>
    }

    /**
     * Remove a persitence-aware class from the repository
     *
     * @return true if removed
     */
    public boolean removePersistenceAware(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L1370" title="All 2 branches missed.">        return _pawares.remove(cls) != null;</span>
    }

    /**
     * Gets the metadata corresponding to the given non-mapped interface. Returns null, if the given
     * interface is not registered as persistence-aware.
     */
    public NonPersistentMetaData getNonMappedInterface(Class&lt;?&gt; iface) {
<span class="nc" id="L1378">        return _nonMapped.get(iface);</span>
    }

    /**
     * Gets the corresponding metadatas for all registered, non-mapped interfaces
     *
     * @return empty array if no non-mapped interface has been registered.
     */
    public NonPersistentMetaData[] getNonMappedInterfaces() {
<span class="nc bnc" id="L1387" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L1388">            synchronized (_nonMapped) {</span>
<span class="nc" id="L1389">                return getNonMappedInterfacesInternal();</span>
            }
        } else {
<span class="nc" id="L1392">            return getNonMappedInterfacesInternal();</span>
        }
    }

    private NonPersistentMetaData[] getNonMappedInterfacesInternal() {
<span class="nc bnc" id="L1397" title="All 2 branches missed.">            if (_nonMapped.isEmpty())</span>
<span class="nc" id="L1398">                return EMPTY_NON_PERSISTENT;</span>
<span class="nc" id="L1399">            return _nonMapped.values().toArray(new NonPersistentMetaData[_nonMapped.size()]);</span>
    }

    /**
     * Add the given non-mapped interface to the repository.
     *
     * @param iface
     *            the non-mapped interface
     */
    public NonPersistentMetaData addNonMappedInterface(Class&lt;?&gt; iface) {
<span class="nc bnc" id="L1409" title="All 2 branches missed.">        if (iface == null)</span>
<span class="nc" id="L1410">            return null;</span>
<span class="nc bnc" id="L1411" title="All 2 branches missed.">        if (!iface.isInterface())</span>
<span class="nc" id="L1412">            throw new MetaDataException(_loc.get(&quot;not-non-mapped&quot;, iface));</span>
<span class="nc bnc" id="L1413" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L1414">            synchronized (this) {</span>
<span class="nc" id="L1415">                return addNonMappedInterfaceInternal(iface);</span>
            }
        } else {
<span class="nc" id="L1418">            return addNonMappedInterfaceInternal(iface);</span>
        }
    }

    private NonPersistentMetaData addNonMappedInterfaceInternal(Class&lt;?&gt; iface) {
<span class="nc bnc" id="L1423" title="All 2 branches missed.">            if (_nonMapped.containsKey(iface))</span>
<span class="nc" id="L1424">                return _nonMapped.get(iface);</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">            if (getCachedMetaData(iface) != null)</span>
<span class="nc" id="L1426">                throw new MetaDataException(_loc.get(&quot;non-mapped-pc&quot;, iface));</span>
<span class="nc" id="L1427">            NonPersistentMetaData meta =</span>
                new NonPersistentMetaData(iface, this, NonPersistentMetaData.TYPE_NON_MAPPED_INTERFACE);
<span class="nc" id="L1429">            _nonMapped.put(iface, meta);</span>
<span class="nc" id="L1430">            return meta;</span>
        }

    /**
     * Remove a non-mapped interface from the repository
     *
     * @return true if removed
     */
    public boolean removeNonMappedInterface(Class&lt;?&gt; iface) {
<span class="nc bnc" id="L1439" title="All 2 branches missed.">        return _nonMapped.remove(iface) != null;</span>
    }

    /**
     * Clear the cache of parsed metadata. This method also clears the internal
     * {@link MetaDataFactory MetaDataFactory}'s cache.
     */
    public void clear() {
<span class="nc bnc" id="L1447" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L1448">            _log.trace(_loc.get(&quot;clear-repos&quot;, this));</span>
<span class="nc bnc" id="L1449" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L1450">            synchronized (this) {</span>
<span class="nc" id="L1451">                clearInternal();</span>
<span class="nc" id="L1452">            }</span>
        } else {
<span class="nc" id="L1454">            clearInternal();</span>
        }
<span class="nc" id="L1456">    }</span>

    private void clearInternal(){
        // Recreating these datastructures is probably faster than calling clear. Future change?
<span class="nc" id="L1460">            _metas.clear();</span>
<span class="nc" id="L1461">            _oids.clear();</span>
<span class="nc" id="L1462">            _subs.clear();</span>
<span class="nc" id="L1463">            _impls.clear();</span>
<span class="nc" id="L1464">            _queries.clear();</span>
<span class="nc" id="L1465">            _seqs.clear();</span>
<span class="nc" id="L1466">            _registered.clear();</span>
<span class="nc" id="L1467">            _factory.clear();</span>
<span class="nc" id="L1468">            _aliases.clear();</span>
<span class="nc" id="L1469">            _pawares.clear();</span>
<span class="nc" id="L1470">            _nonMapped.clear();</span>
<span class="nc" id="L1471">            _metaStringMap.clear();</span>
<span class="nc" id="L1472">    }</span>
    /**
     * Return the set of configured persistent classes, or null if the user did not configure any.
     *
     * @param devpath
     *            if true, search for metadata files in directories in the classpath if no classes
     *            are configured explicitly
     * @param envLoader
     *            the class loader to use, or null for default
     */
    public Set&lt;String&gt; getPersistentTypeNames(boolean devpath, ClassLoader envLoader) {
<span class="nc bnc" id="L1483" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L1484">            synchronized (this) {</span>
<span class="nc" id="L1485">                return getPersistentTypeNamesInternal(devpath, envLoader);</span>
            }
        } else {
<span class="nc" id="L1488">            return getPersistentTypeNamesInternal(devpath, envLoader);</span>
        }
    }

    private Set&lt;String&gt; getPersistentTypeNamesInternal(boolean devpath, ClassLoader envLoader) {
<span class="nc" id="L1493">        return _factory.getPersistentTypeNames(devpath, envLoader);</span>
    }
    /**
     * Load the persistent classes named in configuration.
     * This ensures that all subclasses and application identity classes of
     * each type are known in advance, without having to rely on the
     * application loading the classes before performing operations that
     * might involve them.
     *
     * @param devpath if true, search for metadata files in directories
     * in the classpath if the no classes are configured explicitly
     * @param envLoader the class loader to use, or null for default
     * @return the loaded classes, or empty collection if none
     */
    public Collection&lt;Class&lt;?&gt;&gt; loadPersistentTypes(boolean devpath, ClassLoader envLoader) {
<span class="nc" id="L1508">        return loadPersistentTypes(devpath, envLoader, false);</span>
    }
    /**
     * Load the persistent classes named in configuration. This ensures that all subclasses and
     * application identity classes of each type are known in advance, without having to rely on the
     * application loading the classes before performing operations that might involve them.
     *
     * @param devpath
     *            if true, search for metadata files in directories in the classpath if the no
     *            classes are configured explicitly
     * @param envLoader
     *            the class loader to use, or null for default
     * @param mustExist
     *            if true then empty list of classes or any unloadable but specified class will
     *            raise an exception.
     * @return the loaded classes, or empty collection if none
     */
    public Collection&lt;Class&lt;?&gt;&gt; loadPersistentTypes(boolean devpath, ClassLoader envLoader, boolean mustExist) {
<span class="nc bnc" id="L1526" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L1527">            synchronized (this) {</span>
<span class="nc" id="L1528">                return loadPersistentTypesInternal(devpath, envLoader, mustExist);</span>
            }
        } else {
<span class="nc" id="L1531">            return loadPersistentTypesInternal(devpath, envLoader, mustExist);</span>
        }
    }

    private Collection&lt;Class&lt;?&gt;&gt; loadPersistentTypesInternal(boolean devpath, ClassLoader envLoader,
        boolean mustExist) {
<span class="nc" id="L1537">            Set&lt;String&gt; names = getPersistentTypeNames(devpath, envLoader);</span>
<span class="nc bnc" id="L1538" title="All 4 branches missed.">            if (names == null || names.isEmpty()) {</span>
<span class="nc bnc" id="L1539" title="All 2 branches missed.">                if (!mustExist)</span>
<span class="nc" id="L1540">                    return Collections.emptyList();</span>
                else
<span class="nc" id="L1542">                    throw new MetaDataException(_loc.get(&quot;eager-no-class-found&quot;));</span>
            }

            // attempt to load classes so that they get processed
<span class="nc" id="L1546">            ClassLoader clsLoader = _conf.getClassResolverInstance().getClassLoader(getClass(), envLoader);</span>
<span class="nc" id="L1547">            List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;(names.size());</span>
            Class&lt;?&gt; cls;
<span class="nc bnc" id="L1549" title="All 2 branches missed.">            for (String className : names) {</span>
<span class="nc" id="L1550">                cls = classForName(className, clsLoader);</span>
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                if (_factory.isMetaClass(cls)) {</span>
<span class="nc" id="L1552">                    setMetaModel(cls);</span>
<span class="nc" id="L1553">                    continue;</span>
                }
<span class="nc bnc" id="L1555" title="All 2 branches missed.">                if (skipMetadata(cls)) {</span>
<span class="nc" id="L1556">                    continue;</span>
                }
<span class="nc bnc" id="L1558" title="All 2 branches missed.">                if (cls != null) {</span>
<span class="nc" id="L1559">                    classes.add(cls);</span>

                    // if the class is an interface, load its metadata to kick
                    // off the impl generator
<span class="nc bnc" id="L1563" title="All 2 branches missed.">                    if (cls.isInterface())</span>
<span class="nc" id="L1564">                        getMetaData(cls, clsLoader, false);</span>
<span class="nc bnc" id="L1565" title="All 4 branches missed.">                } else if (cls == null &amp;&amp; mustExist) {</span>
<span class="nc" id="L1566">                    throw new MetaDataException(_loc.get(&quot;eager-class-not-found&quot;, className));</span>
                }
<span class="nc" id="L1568">            }</span>
<span class="nc" id="L1569">            return classes;</span>
    }

    /**
     * Return the class for the given name, or null if not loadable.
     */
    private Class&lt;?&gt; classForName(String name, ClassLoader loader) {
        try {
<span class="nc" id="L1577">            return Class.forName(name, true, loader);</span>
<span class="nc" id="L1578">        } catch (Exception e) {</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">            if ((_validate &amp; VALIDATE_RUNTIME) != 0) {</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">                if (_log.isWarnEnabled())</span>
<span class="nc" id="L1581">                    _log.warn(_loc.get(&quot;bad-discover-class&quot;, name, loader));</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">            } else if (_log.isInfoEnabled())</span>
<span class="nc" id="L1583">                _log.info(_loc.get(&quot;bad-discover-class&quot;, name, loader));</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L1585">                _log.trace(e);</span>
<span class="nc" id="L1586">        } catch (NoSuchMethodError nsme) {</span>
<span class="nc bnc" id="L1587" title="All 2 branches missed.">            if (nsme.getMessage().indexOf(&quot;.pc&quot;) == -1)</span>
<span class="nc" id="L1588">                throw nsme;</span>

            // if the error is about a method that uses the PersistenceCapable
            // 'pc' method prefix, perform some logging and continue. This
            // probably just means that the class is not yet enhanced.
<span class="nc bnc" id="L1593" title="All 2 branches missed.">            if ((_validate &amp; VALIDATE_RUNTIME) != 0) {</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">                if (_log.isWarnEnabled())</span>
<span class="nc" id="L1595">                    _log.warn(_loc.get(&quot;bad-discover-class&quot;, name, loader));</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">            } else if (_log.isInfoEnabled())</span>
<span class="nc" id="L1597">                _log.info(_loc.get(&quot;bad-discover-class&quot;, name, loader));</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L1599">                _log.trace(nsme);</span>
<span class="nc" id="L1600">        }</span>
<span class="nc" id="L1601">        return null;</span>
    }

    /**
     * Return all known subclasses for the given class mapping. Note that this method only works
     * during runtime when the repository is registered as a {@link RegisterClassListener}.
     */
    Collection&lt;Class&lt;?&gt;&gt; getPCSubclasses(Class&lt;?&gt; cls) {
<span class="nc" id="L1609">        Collection&lt;Class&lt;?&gt;&gt; subs = _subs.get(cls);</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">        if (subs == null)</span>
<span class="nc" id="L1611">            return Collections.emptyList();</span>
<span class="nc" id="L1612">        return subs;</span>
    }

    // //////////////////////////////////////
    // RegisterClassListener implementation
    // //////////////////////////////////////

    @Override
    public void register(Class&lt;?&gt; cls) {
        // buffer registered classes until an oid metadata request is made,
        // at which point we'll parse everything in the buffer
<span class="nc" id="L1623">        synchronized (_registered) {</span>
<span class="nc" id="L1624">            _registered.add(cls);</span>
<span class="nc" id="L1625">            registerAlias(cls);</span>
<span class="nc" id="L1626">        }</span>
<span class="nc" id="L1627">    }</span>

    /**
     * Parses the metadata for all registered classes.
     */
    private void loadRegisteredClassMetaData(ClassLoader envLoader) {
<span class="nc" id="L1633">        Class&lt;?&gt;[] reg = processRegisteredClasses(envLoader);</span>
<span class="nc bnc" id="L1634" title="All 2 branches missed.">        for (int i = 0; i &lt; reg.length; i++) {</span>
            try {
<span class="nc" id="L1636">                getMetaData(reg[i], envLoader, false);</span>
<span class="nc" id="L1637">            } catch (MetaDataException me) {</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">                if (_log.isWarnEnabled())</span>
<span class="nc" id="L1639">                    _log.warn(me);</span>
<span class="nc" id="L1640">            }</span>
        }
<span class="nc" id="L1642">    }</span>

    /**
     * Updates our data structures with the latest registered classes.
     * 
     * This method is synchronized to make sure that all data structures are fully updated
     *  before other threads attempt to call this method
     */
    synchronized Class&lt;?&gt;[] processRegisteredClasses(ClassLoader envLoader) {

        Class&lt;?&gt;[] reg;
        /*Synchronize `_registered` cache to block MetaDataRepository.register() from adding
         * to the cache while we copy, causing a ConcurrentModificationException
         */
<span class="nc" id="L1656">        synchronized (_registered) {</span>
<span class="nc bnc" id="L1657" title="All 2 branches missed.">            if (_registered.isEmpty()) {</span>
<span class="nc" id="L1658">                return EMPTY_CLASSES;</span>
            }

            // copy into new collection to avoid concurrent mod errors on reentrant
            // registrations
<span class="nc" id="L1663">            reg = _registered.toArray(new Class[_registered.size()]);</span>
<span class="nc" id="L1664">            _registered.clear();</span>
<span class="nc" id="L1665">        }</span>

<span class="nc" id="L1667">        Collection&lt;String&gt; pcNames = getPersistentTypeNames(false, envLoader);</span>
<span class="nc" id="L1668">        Collection&lt;Class&lt;?&gt;&gt; failed = null;</span>
<span class="nc bnc" id="L1669" title="All 2 branches missed.">        for (int i = 0; i &lt; reg.length; i++) {</span>
            // Don't process types that aren't listed by the user; it may belong to a different persistence unit.
<span class="nc bnc" id="L1671" title="All 6 branches missed.">            if (pcNames != null &amp;&amp; !pcNames.isEmpty() &amp;&amp; !pcNames.contains(reg[i].getName())) {</span>
<span class="nc" id="L1672">                continue;</span>
            }

            // If the compatibility option &quot;filterPCRegistryClasses&quot; is enabled, then verify that the type is
            // accessible to the envLoader/Thread Context ClassLoader
<span class="nc bnc" id="L1677" title="All 2 branches missed.">            if (_filterRegisteredClasses) {</span>
<span class="nc bnc" id="L1678" title="All 2 branches missed.">                Log log = (_conf == null) ? null : _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);</span>
<span class="nc bnc" id="L1679" title="All 2 branches missed.">                ClassLoader loadCL = (envLoader != null) ?</span>
<span class="nc" id="L1680">                    envLoader :</span>
<span class="nc" id="L1681">                    AccessController.doPrivileged(J2DoPrivHelper.getContextClassLoaderAction());</span>

                try {
<span class="nc" id="L1684">                    Class&lt;?&gt; classFromAppClassLoader = Class.forName(reg[i].getName(), true, loadCL);</span>

<span class="nc bnc" id="L1686" title="All 2 branches missed.">                    if (!reg[i].equals(classFromAppClassLoader)) {</span>
                        // This is a class that belongs to a ClassLoader not associated with the Application,
                        // so it should be processed.
<span class="nc bnc" id="L1689" title="All 4 branches missed.">                        if (log != null &amp;&amp; log.isTraceEnabled()) {</span>
<span class="nc" id="L1690">                            log.trace(</span>
<span class="nc" id="L1691">                                &quot;Metadata Repository will ignore Class &quot; + reg[i].getName() +</span>
                                &quot;, since it originated from a ClassLoader not associated with the application.&quot;);
                        }
<span class="nc" id="L1694">                        continue;</span>
                    }
<span class="nc" id="L1696">                } catch (ClassNotFoundException cnfe) {</span>
                    // Catch exception and log its occurrence, and permit MDR processing to continue to preserve
                    // original behavior.
<span class="nc bnc" id="L1699" title="All 4 branches missed.">                    if (log != null &amp;&amp; log.isTraceEnabled()) {</span>
<span class="nc" id="L1700">                        log.trace(&quot;The Class &quot; + reg[i].getName() + &quot; was identified as a persistent class &quot; +</span>
                            &quot;by configuration, but the Class could not be found.&quot;);
                    }
<span class="nc" id="L1703">                }</span>
            }

<span class="nc" id="L1706">            checkEnhancementLevel(reg[i]);</span>
            try {
<span class="nc" id="L1708">                processRegisteredClass(reg[i]);</span>
<span class="nc" id="L1709">            } catch (Throwable t) {</span>
<span class="nc bnc" id="L1710" title="All 2 branches missed.">                if (!_conf.getRetryClassRegistration())</span>
<span class="nc" id="L1711">                    throw new MetaDataException(_loc.get(&quot;error-registered&quot;, reg[i]), t);</span>

<span class="nc bnc" id="L1713" title="All 2 branches missed.">                if (_log.isWarnEnabled())</span>
<span class="nc" id="L1714">                    _log.warn(_loc.get(&quot;failed-registered&quot;, reg[i]), t);</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">                if (failed == null)</span>
<span class="nc" id="L1716">                    failed = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1717">                failed.add(reg[i]);</span>
<span class="nc" id="L1718">            }</span>
        }
<span class="nc bnc" id="L1720" title="All 2 branches missed.">        if (failed != null) {</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">            if (_locking) {</span>
<span class="nc" id="L1722">                synchronized (_registered) {</span>
<span class="nc" id="L1723">                    _registered.addAll(failed);</span>
<span class="nc" id="L1724">                }</span>
            } else {
<span class="nc" id="L1726">                _registered.addAll(failed);</span>
            }
        }
<span class="nc" id="L1729">        return reg;</span>
    }

    /**
     * Updates our datastructures with the given registered class. Relies on the fact that a child
     * class cannot register itself without also registering its parent class by specifying its
     * persistence capable superclass in the registration event.
     */
    private void processRegisteredClass(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L1738" title="All 2 branches missed.">        if (_log.isTraceEnabled())</span>
<span class="nc" id="L1739">            _log.trace(_loc.get(&quot;process-registered&quot;, cls));</span>

        // update subclass lists; synchronize on this because accessing _metas
        // requires it
<span class="nc" id="L1743">        Class&lt;?&gt; leastDerived = cls;</span>
<span class="nc" id="L1744">        synchronized (this) {</span>
            ClassMetaData meta;
<span class="nc bnc" id="L1746" title="All 2 branches missed.">            for (Class&lt;?&gt; anc = cls; (anc = PCRegistry.getPersistentSuperclass(anc)) != null;) {</span>
<span class="nc" id="L1747">                addToCollection(_subs, anc, cls, true);</span>
<span class="nc" id="L1748">                meta = _metas.get(anc);</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">                if (meta != null)</span>
<span class="nc" id="L1750">                    meta.clearSubclassCache();</span>
<span class="nc" id="L1751">                leastDerived = anc;</span>
            }
<span class="nc" id="L1753">        }</span>

        // update oid mappings if this is a base concrete class
<span class="nc" id="L1756">        Object oid = null;</span>
        try {
<span class="nc" id="L1758">            oid = PCRegistry.newObjectId(cls);</span>
<span class="nc" id="L1759">        } catch (InternalException ie) {</span>
            // thrown for single field identity with null pk field value
<span class="nc" id="L1761">        }</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">        if (oid != null) {</span>
<span class="nc" id="L1763">            Class&lt;?&gt; existing = _oids.get(oid.getClass());</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">            if (existing != null) {</span>
                // if there is already a class for this OID, then we know
                // that multiple classes are using the same OID: therefore,
                // put the least derived PC superclass into the map. This
                // gets around the problem of an abstract PC superclass
                // using application identity (since newObjectId
                // will return null for abstract classes).
<span class="nc" id="L1771">                Class&lt;?&gt; sup = cls;</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">                while (PCRegistry.getPersistentSuperclass(sup) != null)</span>
<span class="nc" id="L1773">                    sup = PCRegistry.getPersistentSuperclass(sup);</span>

<span class="nc" id="L1775">                _oids.put(oid.getClass(), sup);</span>
<span class="nc bnc" id="L1776" title="All 4 branches missed.">            } else if (existing == null || cls.isAssignableFrom(existing))</span>
<span class="nc" id="L1777">                _oids.put(oid.getClass(), cls);</span>
        }

        // update mappings from interfaces and non-pc superclasses to
        // pc implementing types
<span class="nc bnc" id="L1782" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L1783">            synchronized (_impls) {</span>
<span class="nc" id="L1784">                updateImpls(cls, leastDerived, cls);</span>
<span class="nc" id="L1785">            }</span>
        } else {
<span class="nc" id="L1787">            updateImpls(cls, leastDerived, cls);</span>
        }

        // set alias for class
<span class="nc" id="L1791">        registerAlias(cls);</span>
<span class="nc" id="L1792">    }</span>


    /**
     * Register the given class to the list of known aliases.
     * The alias is registered only if the class has been enhanced.
     *
     */
    void registerAlias(Class&lt;?&gt; cls) {
<span class="nc" id="L1801">        registerAlias(PCRegistry.getTypeAlias(cls), cls);</span>
<span class="nc" id="L1802">    }</span>

    public void registerAlias(String alias, Class&lt;?&gt; cls) {
<span class="nc bnc" id="L1805" title="All 2 branches missed.">        if (alias == null)</span>
<span class="nc" id="L1806">            return;</span>
        try {
<span class="nc bnc" id="L1808" title="All 2 branches missed.">            if (alias != null) {</span>
<span class="nc" id="L1809">                List&lt;Class&lt;?&gt;&gt; classes = _aliases.get(alias);</span>
<span class="nc bnc" id="L1810" title="All 2 branches missed.">                if (classes == null)</span>
<span class="nc" id="L1811">                    classes = new ArrayList&lt;&gt;(3);</span>
<span class="nc bnc" id="L1812" title="All 2 branches missed.">                if (!classes.contains(cls)) {</span>
<span class="nc" id="L1813">                    classes.add(cls);</span>
<span class="nc" id="L1814">                    _aliases.put(alias, classes);</span>
                }
            }
<span class="nc" id="L1817">        } catch (IllegalStateException ise) {</span>
            // the class has not been registered to PCRegistry
<span class="nc" id="L1819">        }</span>
<span class="nc" id="L1820">    }</span>

    /**
     * Update the list of implementations of base classes and interfaces.
     */
    private void updateImpls(Class&lt;?&gt; cls, Class&lt;?&gt; leastDerived, Class&lt;?&gt; check) {
        // allow users to query on common non-pc superclasses
<span class="nc" id="L1827">        Class&lt;?&gt; sup = check.getSuperclass();</span>
<span class="nc bnc" id="L1828" title="All 6 branches missed.">        if (leastDerived == cls &amp;&amp; sup != null &amp;&amp; sup != Object.class) {</span>
<span class="nc" id="L1829">            addToCollection(_impls, sup, cls, false);</span>
<span class="nc" id="L1830">            updateImpls(cls, leastDerived, sup);</span>
        }

        // allow users to query on any implemented interfaces unless defaults
        // say the user must implement persistent interfaces explicitly in meta
<span class="nc bnc" id="L1835" title="All 2 branches missed.">        if (!_factory.getDefaults().isDeclaredInterfacePersistent())</span>
<span class="nc" id="L1836">            return;</span>
<span class="nc" id="L1837">        Class&lt;?&gt;[] ints = check.getInterfaces();</span>
<span class="nc bnc" id="L1838" title="All 2 branches missed.">        for (int i = 0; i &lt; ints.length; i++) {</span>
            // don't map java-standard interfaces
<span class="nc bnc" id="L1840" title="All 2 branches missed.">            if (ints[i].getName().startsWith(&quot;java.&quot;))</span>
<span class="nc" id="L1841">                continue;</span>

            // only map least-derived interface implementors
<span class="nc bnc" id="L1844" title="All 4 branches missed.">            if (leastDerived == cls || isLeastDerivedImpl(ints[i], cls)) {</span>
<span class="nc" id="L1845">                addToCollection(_impls, ints[i], cls, false);</span>
<span class="nc" id="L1846">                updateImpls(cls, leastDerived, ints[i]);</span>
            }
        }
<span class="nc" id="L1849">    }</span>

    /**
     * Return true if the given class is the least-derived persistent implementor of the given
     * interface, false otherwise.
     */
    private boolean isLeastDerivedImpl(Class&lt;?&gt; inter, Class&lt;?&gt; cls) {
<span class="nc" id="L1856">        Class&lt;?&gt; parent = PCRegistry.getPersistentSuperclass(cls);</span>
<span class="nc bnc" id="L1857" title="All 2 branches missed.">        while (parent != null) {</span>
<span class="nc bnc" id="L1858" title="All 2 branches missed.">            if (Arrays.asList(parent.getInterfaces()).contains(inter))</span>
<span class="nc" id="L1859">                return false;</span>
<span class="nc" id="L1860">            parent = PCRegistry.getPersistentSuperclass(parent);</span>
        }
<span class="nc" id="L1862">        return true;</span>
    }

    /**
     * Add the given value to the collection cached in the given map under the given key.
     */
    private void addToCollection(Map&lt;Class&lt;?&gt;, Collection&lt;Class&lt;?&gt;&gt;&gt; map, 
            Class&lt;?&gt; key, Class&lt;?&gt; value, boolean inheritance) {
<span class="nc bnc" id="L1870" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L1871">            synchronized (map) {</span>
<span class="nc" id="L1872">                addToCollectionInternal(map, key, value, inheritance);</span>
<span class="nc" id="L1873">            }</span>
        } else {
<span class="nc" id="L1875">            addToCollectionInternal(map, key, value, inheritance);</span>
        }
<span class="nc" id="L1877">    }</span>

    private void addToCollectionInternal(Map&lt;Class&lt;?&gt;, Collection&lt;Class&lt;?&gt;&gt;&gt; map, 
            Class&lt;?&gt; key, Class&lt;?&gt; value, boolean inheritance) {
<span class="nc" id="L1881">        Collection&lt;Class&lt;?&gt;&gt; coll = map.get(key);</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">        if (coll == null) {</span>
<span class="nc bnc" id="L1883" title="All 2 branches missed.">            if (inheritance) {</span>
<span class="nc" id="L1884">                InheritanceComparator comp = new InheritanceComparator();</span>
<span class="nc" id="L1885">                comp.setBase(key);</span>
<span class="nc" id="L1886">                coll = new TreeSet&lt;Class&lt;?&gt;&gt;(comp);</span>
<span class="nc" id="L1887">            } else</span>
<span class="nc" id="L1888">                coll = new LinkedList&lt;Class&lt;?&gt;&gt;();</span>
<span class="nc" id="L1889">            map.put(key, coll);</span>
        }
<span class="nc" id="L1891">        coll.add(value);</span>
<span class="nc" id="L1892">    }</span>

    /**
     * Puts the meta class corresponding to the given entity class.
     */
    public void setMetaModel(Class&lt;?&gt; m2) {
<span class="nc" id="L1898">        Class&lt;?&gt; cls = _factory.getManagedClass(m2);</span>
<span class="nc bnc" id="L1899" title="All 2 branches missed.">        if (cls != null)</span>
<span class="nc" id="L1900">            _metamodel.put(cls, m2);</span>
<span class="nc" id="L1901">    }</span>

    /**
     * Puts the meta class corresponding to the given persistent class.
     */
    public void setMetaModel(ClassMetaData meta, Class&lt;?&gt; m2) {
<span class="nc" id="L1907">        _metamodel.put(meta.getDescribedType(), m2);</span>
<span class="nc" id="L1908">    }</span>

    /**
     * Gets the meta class corresponding to the given persistent class.
     */
    public Class&lt;?&gt; getMetaModel(ClassMetaData meta, boolean load) {
<span class="nc" id="L1914">        return getMetaModel(meta.getDescribedType(), load);</span>
    }

    /**
     * Gets the meta class corresponding to the given class. If load is false, returns the meta
     * class if has been set for the given persistent class earlier. If the load is true then also
     * attempts to apply the current naming policy to derive meta class name and attempts to load
     * the meta class.
     */
    public Class&lt;?&gt; getMetaModel(Class&lt;?&gt; entity, boolean load) {
<span class="nc bnc" id="L1924" title="All 2 branches missed.">        if (_metamodel.containsKey(entity))</span>
<span class="nc" id="L1925">            return _metamodel.get(entity);</span>
<span class="nc" id="L1926">        String m2 = _factory.getMetaModelClassName(entity.getName());</span>
        try {
<span class="nc" id="L1928">            ClassLoader loader = AccessController.doPrivileged(J2DoPrivHelper.getClassLoaderAction(entity));</span>
<span class="nc" id="L1929">            Class&lt;?&gt; m2cls = AccessController.doPrivileged(J2DoPrivHelper.getForNameAction(m2, true, loader));</span>
<span class="nc" id="L1930">            _metamodel.put(entity, m2cls);</span>
<span class="nc" id="L1931">            return m2cls;</span>
<span class="nc" id="L1932">        } catch (Throwable t) {</span>
<span class="nc bnc" id="L1933" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L1934">                _log.warn(_loc.get(&quot;meta-no-model&quot;, m2, entity, t));</span>
        }
<span class="nc" id="L1936">        return null;</span>
    }

    // /////////////////////////////
    // Configurable implementation
    // /////////////////////////////

    @Override
    public void setConfiguration(Configuration conf) {
<span class="nc" id="L1945">        _conf = (OpenJPAConfiguration) conf;</span>
<span class="nc" id="L1946">        _log = _conf.getLog(OpenJPAConfiguration.LOG_METADATA);</span>
<span class="nc" id="L1947">        _filterRegisteredClasses = _conf.getCompatibilityInstance().getFilterPCRegistryClasses();</span>
<span class="nc" id="L1948">        _typesWithoutEnhancement = _conf.getTypesWithoutEnhancement();</span>
<span class="nc bnc" id="L1949" title="All 4 branches missed.">        if (_typesWithoutEnhancement == null || _typesWithoutEnhancement.isEmpty()) {</span>
<span class="nc" id="L1950">            _typesWithoutEnhancement = null;</span>
        }
<span class="nc" id="L1952">    }</span>

    @Override
    public void startConfiguration() {
<span class="nc" id="L1956">    }</span>

    @Override
    public void endConfiguration() {
<span class="nc" id="L1960">        initializeMetaDataFactory();</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">        if (_implGen == null)</span>
<span class="nc" id="L1962">            _implGen = new InterfaceImplGenerator(this);</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">        if (_preload == true) {</span>
<span class="nc" id="L1964">            _oids = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1965">            _impls = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1966">            _ifaces = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1967">            _aliases = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1968">            _pawares = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1969">            _nonMapped = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1970">            _subs = new HashMap&lt;&gt;();</span>
            // Wait till we're done loading MetaData to flip _lock boolean.
        }
<span class="nc" id="L1973">    }</span>

    private void initializeMetaDataFactory() {
<span class="nc bnc" id="L1976" title="All 2 branches missed.">        if (_factory == null) {</span>
<span class="nc" id="L1977">            MetaDataFactory mdf = _conf.newMetaDataFactoryInstance();</span>
<span class="nc bnc" id="L1978" title="All 2 branches missed.">            if (mdf == null)</span>
<span class="nc" id="L1979">                throw new MetaDataException(_loc.get(&quot;no-metadatafactory&quot;));</span>
<span class="nc" id="L1980">            setMetaDataFactory(mdf);</span>
        }
<span class="nc" id="L1982">    }</span>

    // ////////////////
    // Query metadata
    // ////////////////

    /**
     * Return query metadata for the given class, name, and classloader.
     */
    public QueryMetaData getQueryMetaData(Class&lt;?&gt; cls, String name, ClassLoader envLoader, boolean mustExist) {
<span class="nc bnc" id="L1992" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L1993">            synchronized (this) {</span>
<span class="nc" id="L1994">                return getQueryMetaDataInternal(cls, name, envLoader, mustExist);</span>
            }
        } else {
<span class="nc" id="L1997">            return getQueryMetaDataInternal(cls, name, envLoader, mustExist);</span>
        }
    }

    private QueryMetaData getQueryMetaDataInternal(Class&lt;?&gt; cls, String name, ClassLoader envLoader,
        boolean mustExist) {
<span class="nc" id="L2003">            QueryMetaData meta = getQueryMetaDataInternal(cls, name, envLoader);</span>
<span class="nc bnc" id="L2004" title="All 2 branches missed.">            if (meta == null) {</span>
                // load all the metadatas for all the known classes so that
                // query names are seen and registered
<span class="nc" id="L2007">                resolveAll(envLoader);</span>
<span class="nc" id="L2008">                meta = getQueryMetaDataInternal(cls, name, envLoader);</span>
            }

<span class="nc bnc" id="L2011" title="All 4 branches missed.">            if (meta == null &amp;&amp; mustExist) {</span>
<span class="nc bnc" id="L2012" title="All 2 branches missed.">                if (cls == null) {</span>
<span class="nc" id="L2013">                    throw new MetaDataException(_loc.get(&quot;no-named-query-null-class&quot;, getPersistentTypeNames(false,</span>
                        envLoader), name));
                } else {
<span class="nc" id="L2016">                    throw new MetaDataException(_loc.get(&quot;no-named-query&quot;, cls, name));</span>
                }
            }

<span class="nc" id="L2020">            return meta;</span>
    }

    /**
     * Resolve all known metadata classes.
     */
    private void resolveAll(ClassLoader envLoader) {
<span class="nc" id="L2027">        Collection&lt;Class&lt;?&gt;&gt; types = loadPersistentTypes(false, envLoader);</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">        for (Class&lt;?&gt; c : types) {</span>
<span class="nc" id="L2029">            getMetaData(c, envLoader, false);</span>
<span class="nc" id="L2030">        }</span>
<span class="nc" id="L2031">    }</span>

    /**
     * Return query metadata for the given class, name, and classloader.
     */
    private QueryMetaData getQueryMetaDataInternal(Class&lt;?&gt; cls, String name, ClassLoader envLoader) {
<span class="nc bnc" id="L2037" title="All 2 branches missed.">        if (name == null)</span>
<span class="nc" id="L2038">            return null;</span>

        // check cache
<span class="nc" id="L2041">        QueryMetaData qm = _queries.get(name);</span>
<span class="nc bnc" id="L2042" title="All 2 branches missed.">        if (qm != null)</span>
<span class="nc" id="L2043">            return qm;</span>

        // see if factory can figure out a scope for this query
<span class="nc bnc" id="L2046" title="All 2 branches missed.">        if (cls == null)</span>
<span class="nc" id="L2047">            cls = _factory.getQueryScope(name, envLoader);</span>

        // get metadata for class, which will find queries in metadata file
<span class="nc bnc" id="L2050" title="All 4 branches missed.">        if (cls != null &amp;&amp; getMetaData(cls, envLoader, false) != null) {</span>
<span class="nc" id="L2051">            qm = _queries.get(name);</span>
<span class="nc bnc" id="L2052" title="All 2 branches missed.">            if (qm != null)</span>
<span class="nc" id="L2053">                return qm;</span>
        }
<span class="nc bnc" id="L2055" title="All 2 branches missed.">        if ((_sourceMode &amp; MODE_QUERY) == 0)</span>
<span class="nc" id="L2056">            return null;</span>

        // not in cache; load
<span class="nc" id="L2059">        _factory.load(cls, MODE_QUERY , envLoader);</span>
<span class="nc" id="L2060">        return _queries.get(name);</span>
    }

    /**
     * Return the cached query metadata.
     */
    public QueryMetaData[] getQueryMetaDatas() {
<span class="nc bnc" id="L2067" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2068">            synchronized (this) {</span>
<span class="nc" id="L2069">                return _queries.values().toArray(new QueryMetaData[_queries.size()]);</span>
            }
        } else {
<span class="nc" id="L2072">            return _queries.values().toArray(new QueryMetaData[_queries.size()]);</span>
        }
    }


    public QueryMetaData getCachedQueryMetaData(Class&lt;?&gt; cls, String name) {
<span class="nc" id="L2078">        return getCachedQueryMetaData(name);</span>
    }

    /**
     * Return the cached query metadata for the given name.
     */
    public QueryMetaData getCachedQueryMetaData(String name) {
<span class="nc bnc" id="L2085" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2086">            synchronized (this) {</span>
<span class="nc" id="L2087">                return _queries.get(name);</span>
            }
        } else {
<span class="nc" id="L2090">            return _queries.get(name);</span>
        }
    }

    /**
     * Add a new query metadata to the repository and return it.
     */
    public QueryMetaData addQueryMetaData(Class&lt;?&gt; cls, String name) {
<span class="nc bnc" id="L2098" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2099">            synchronized (this) {</span>
<span class="nc" id="L2100">                QueryMetaData meta = newQueryMetaData(cls, name);</span>
<span class="nc" id="L2101">                _queries.put(name, meta);</span>
<span class="nc" id="L2102">                return meta;</span>
            }
        }else{
<span class="nc" id="L2105">            QueryMetaData meta = newQueryMetaData(cls, name);</span>
<span class="nc" id="L2106">            _queries.put(name, meta);</span>
<span class="nc" id="L2107">            return meta;</span>
        }
    }

    public QueryMetaData addQueryMetaData(QueryMetaData meta) {
<span class="nc bnc" id="L2112" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2113">            synchronized (this) {</span>
<span class="nc" id="L2114">                final QueryMetaData queryMetaData = _queries.get(meta.getName());</span>
<span class="nc bnc" id="L2115" title="All 2 branches missed.">                return queryMetaData != null ? queryMetaData : _queries.put(meta.getName(), meta);</span>
            }
        } else {
<span class="nc" id="L2118">            final QueryMetaData queryMetaData = _queries.get(meta.getName());</span>
<span class="nc bnc" id="L2119" title="All 2 branches missed.">            return queryMetaData != null ? queryMetaData : _queries.put(meta.getName(), meta);</span>
        }
    }

    /**
     * Create a new query metadata instance.
     */
    public QueryMetaData newQueryMetaData(Class&lt;?&gt; cls, String name) {
<span class="nc" id="L2127">        QueryMetaData meta =</span>
<span class="nc" id="L2128">            new QueryMetaData(name, _conf.getCompatibilityInstance().getConvertPositionalParametersToNamed());</span>
<span class="nc" id="L2129">        meta.setDefiningType(cls);</span>
<span class="nc" id="L2130">        return meta;</span>
    }

    /**
     * Remove the given query metadata from the repository.
     */
    public boolean removeQueryMetaData(QueryMetaData meta) {
<span class="nc bnc" id="L2137" title="All 2 branches missed.">        if (meta == null)</span>
<span class="nc" id="L2138">            return false;</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2140">            synchronized (this) {</span>
<span class="nc bnc" id="L2141" title="All 2 branches missed.">                return _queries.remove(meta.getName()) != null;</span>
            }
        } else {
<span class="nc bnc" id="L2144" title="All 2 branches missed.">            return _queries.remove(meta.getName()) != null;</span>
        }
    }

    /**
     * Remove query metadata for the given class name if in the repository.
     */
    public boolean removeQueryMetaData(Class&lt;?&gt; cls, String name) {
<span class="nc bnc" id="L2152" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2153">            synchronized (this) {</span>
<span class="nc bnc" id="L2154" title="All 2 branches missed.">                if (name == null)</span>
<span class="nc" id="L2155">                    return false;</span>
<span class="nc bnc" id="L2156" title="All 2 branches missed.">                return _queries.remove(name) != null;</span>
            }
        } else {
<span class="nc bnc" id="L2159" title="All 2 branches missed.">            if (name == null)</span>
<span class="nc" id="L2160">                return false;</span>
<span class="nc bnc" id="L2161" title="All 2 branches missed.">            return _queries.remove(name) != null;</span>
        }
    }

    /**
     * Searches all cached query metadata by name.
     */
    public QueryMetaData searchQueryMetaDataByName(String name) {
<span class="nc" id="L2169">        return _queries.get(name);</span>
    }

    /**
     * Return a unique key for a given class / name. The class argument can be null.
     */
    protected static Object getQueryKey(Class&lt;?&gt; cls, String name) {
<span class="nc bnc" id="L2176" title="All 2 branches missed.">        if (cls == null)</span>
<span class="nc" id="L2177">            return name;</span>
<span class="nc" id="L2178">        QueryKey key = new QueryKey();</span>
<span class="nc" id="L2179">        key.clsName = cls.getName();</span>
<span class="nc" id="L2180">        key.name = name;</span>
<span class="nc" id="L2181">        return key;</span>
    }

    // ///////////////////
    // Sequence metadata
    // ///////////////////

    /**
     * Return sequence metadata for the given name and classloader.
     */
    public SequenceMetaData getSequenceMetaData(String name, ClassLoader envLoader, boolean mustExist) {
<span class="nc bnc" id="L2192" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2193">            synchronized (this) {</span>
<span class="nc" id="L2194">                return getSequenceMetaDataInternal(name, envLoader, mustExist);</span>
            }
        } else {
<span class="nc" id="L2197">            return getSequenceMetaDataInternal(name, envLoader, mustExist);</span>
        }
    }

    private SequenceMetaData getSequenceMetaDataInternal(String name, ClassLoader envLoader, boolean mustExist) {
<span class="nc" id="L2202">            SequenceMetaData meta = getSequenceMetaDataInternal(name, envLoader);</span>
<span class="nc bnc" id="L2203" title="All 4 branches missed.">            if (meta == null &amp;&amp; SequenceMetaData.NAME_SYSTEM.equals(name)) {</span>
<span class="nc bnc" id="L2204" title="All 2 branches missed.">                if (_sysSeq == null)</span>
<span class="nc" id="L2205">                    _sysSeq = newSequenceMetaData(name);</span>
<span class="nc" id="L2206">                return _sysSeq;</span>
            }
<span class="nc bnc" id="L2208" title="All 4 branches missed.">            if (meta == null &amp;&amp; mustExist)</span>
<span class="nc" id="L2209">                throw new MetaDataException(_loc.get(&quot;no-named-sequence&quot;, name));</span>
<span class="nc" id="L2210">            return meta;</span>
    }

    /**
     * Used internally by metadata to retrieve sequence metadatas based on possibly-unqualified
     * sequence name.
     */
    SequenceMetaData getSequenceMetaData(ClassMetaData context, String name, boolean mustExist) {
        // try with given name
<span class="nc" id="L2219">        MetaDataException e = null;</span>
        try {
<span class="nc" id="L2221">            SequenceMetaData seq = getSequenceMetaData(name, context.getEnvClassLoader(), mustExist);</span>
<span class="nc bnc" id="L2222" title="All 2 branches missed.">            if (seq != null)</span>
<span class="nc" id="L2223">                return seq;</span>
<span class="nc" id="L2224">        } catch (MetaDataException mde) {</span>
<span class="nc" id="L2225">            e = mde;</span>
<span class="nc" id="L2226">        }</span>

        // if given name already fully qualified, give up
<span class="nc bnc" id="L2229" title="All 2 branches missed.">        if (name.indexOf('.') != -1) {</span>
<span class="nc bnc" id="L2230" title="All 2 branches missed.">            if (e != null)</span>
<span class="nc" id="L2231">                throw e;</span>
<span class="nc" id="L2232">            return null;</span>
        }

        // try with qualified name
<span class="nc" id="L2236">        name = ClassUtil.getPackageName(context.getDescribedType()) + &quot;.&quot; + name;</span>
        try {
<span class="nc" id="L2238">            return getSequenceMetaData(name, context.getEnvClassLoader(), mustExist);</span>
<span class="nc" id="L2239">        } catch (MetaDataException mde) {</span>
            // throw original exception
<span class="nc bnc" id="L2241" title="All 2 branches missed.">            if (e != null)</span>
<span class="nc" id="L2242">                throw e;</span>
<span class="nc" id="L2243">            throw mde;</span>
        }
    }

    /**
     * Return sequence metadata for the given name and classloader.
     */
    private SequenceMetaData getSequenceMetaDataInternal(String name, ClassLoader envLoader) {
<span class="nc bnc" id="L2251" title="All 2 branches missed.">        if (name == null)</span>
<span class="nc" id="L2252">            return null;</span>

        // check cache
<span class="nc" id="L2255">        SequenceMetaData meta = _seqs.get(name);</span>
<span class="nc bnc" id="L2256" title="All 2 branches missed.">        if (meta == null) {</span>
            // load metadata for registered classes to hopefully find sequence
            // definition
<span class="nc" id="L2259">            loadRegisteredClassMetaData(envLoader);</span>
<span class="nc" id="L2260">            meta = _seqs.get(name);</span>
        }
<span class="nc" id="L2262">        return meta;</span>
    }

    /**
     * Return the cached sequence metadata.
     */
    public SequenceMetaData[] getSequenceMetaDatas() {
<span class="nc bnc" id="L2269" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2270">            synchronized (this) {</span>
<span class="nc" id="L2271">                return _seqs.values().toArray(new SequenceMetaData[_seqs.size()]);</span>
            }
        } else {
<span class="nc" id="L2274">            return _seqs.values().toArray(new SequenceMetaData[_seqs.size()]);</span>
        }
    }

    /**
     * Return the cached a sequence metadata for the given name.
     */
    public SequenceMetaData getCachedSequenceMetaData(String name) {
<span class="nc bnc" id="L2282" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2283">            synchronized (this) {</span>
<span class="nc" id="L2284">                return _seqs.get(name);</span>
            }
        } else {
<span class="nc" id="L2287">            return _seqs.get(name);</span>
        }
    }

    /**
     * Add a new sequence metadata to the repository and return it.
     */
    public SequenceMetaData addSequenceMetaData(String name) {
<span class="nc bnc" id="L2295" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2296">            synchronized (this) {</span>
<span class="nc" id="L2297">                SequenceMetaData meta = newSequenceMetaData(name);</span>
<span class="nc" id="L2298">                _seqs.put(name, meta);</span>
<span class="nc" id="L2299">                return meta;</span>
            }
        } else {
<span class="nc" id="L2302">            SequenceMetaData meta = newSequenceMetaData(name);</span>
<span class="nc" id="L2303">            _seqs.put(name, meta);</span>
<span class="nc" id="L2304">            return meta;</span>
        }
    }

    /**
     * Create a new sequence metadata instance.
     */
    protected SequenceMetaData newSequenceMetaData(String name) {
<span class="nc" id="L2312">        return new SequenceMetaData(name, this);</span>
    }

    /**
     * Remove the given sequence metadata from the repository.
     */
    public boolean removeSequenceMetaData(SequenceMetaData meta) {
<span class="nc bnc" id="L2319" title="All 2 branches missed.">        if (meta == null)</span>
<span class="nc" id="L2320">            return false;</span>
<span class="nc bnc" id="L2321" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2322">            synchronized (this) {</span>
<span class="nc bnc" id="L2323" title="All 2 branches missed.">                return _seqs.remove(meta.getName()) != null;</span>
            }
        } else {
<span class="nc bnc" id="L2326" title="All 2 branches missed.">            return _seqs.remove(meta.getName()) != null;</span>
        }
    }

    /**
     * Remove sequence metadata for the name if in the repository.
     */
    public boolean removeSequenceMetaData(String name) {
<span class="nc bnc" id="L2334" title="All 2 branches missed.">        if (name == null)</span>
<span class="nc" id="L2335">            return false;</span>
<span class="nc bnc" id="L2336" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2337">            synchronized (this) {</span>
<span class="nc bnc" id="L2338" title="All 2 branches missed.">                return _seqs.remove(name) != null;</span>
            }
        } else {
<span class="nc bnc" id="L2341" title="All 2 branches missed.">            return _seqs.remove(name) != null;</span>
        }
    }

    /**
     * Whether any system (default) listeners have been registered.  Used as a quick test to
     * determine whether the callback/listener mechanism has been enabled.
     * @return boolean
     */
    public boolean is_systemListenersActivated() {
<span class="nc" id="L2351">        return _systemListenersActivated;</span>
    }

    /**
     * Add the given system lifecycle listener.
     */
    public void addSystemListener(Object listener) {
<span class="nc bnc" id="L2358" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2359">            synchronized (this) {</span>
                // copy to avoid issues with ListenerList and avoid unncessary
                // locking on the list during runtime
<span class="nc" id="L2362">                LifecycleEventManager.ListenerList listeners = new LifecycleEventManager.ListenerList(_listeners);</span>
<span class="nc" id="L2363">                listeners.add(listener);</span>
<span class="nc" id="L2364">                _listeners = listeners;</span>
<span class="nc" id="L2365">                _systemListenersActivated = true;</span>
<span class="nc" id="L2366">            }</span>
        } else {
<span class="nc" id="L2368">            LifecycleEventManager.ListenerList listeners = new LifecycleEventManager.ListenerList(_listeners);</span>
<span class="nc" id="L2369">            listeners.add(listener);</span>
<span class="nc" id="L2370">            _listeners = listeners;</span>
<span class="nc" id="L2371">            _systemListenersActivated = true;</span>
        }
<span class="nc" id="L2373">    }</span>

    /**
     * Remove the given system lifecycle listener.
     */
    public boolean removeSystemListener(Object listener) {
<span class="nc bnc" id="L2379" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2380">            synchronized (this) {</span>
<span class="nc" id="L2381">                return removeSystemListenerInternal(listener);</span>
            }
        } else {
<span class="nc" id="L2384">            return removeSystemListenerInternal(listener);</span>
        }
    }

    private boolean removeSystemListenerInternal(Object listener) {
<span class="nc bnc" id="L2389" title="All 2 branches missed.">            if (!_listeners.contains(listener))</span>
<span class="nc" id="L2390">                return false;</span>

            // copy to avoid issues with ListenerList and avoid unncessary
            // locking on the list during runtime
<span class="nc" id="L2394">            LifecycleEventManager.ListenerList listeners = new LifecycleEventManager.ListenerList(_listeners);</span>
<span class="nc" id="L2395">            listeners.remove(listener);</span>
<span class="nc" id="L2396">            _listeners = listeners;</span>
<span class="nc" id="L2397">            return true;</span>
    }

    /**
     * Return the system lifecycle listeners
     */
    public LifecycleEventManager.ListenerList getSystemListeners() {
<span class="nc" id="L2404">        return _listeners;</span>
    }

    /**
     * Free the resources used by this repository. Closes all user sequences.
     */
    @Override
    public void close() {
<span class="nc bnc" id="L2412" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2413">            synchronized (this) {</span>
<span class="nc" id="L2414">                closeInternal();</span>
<span class="nc" id="L2415">            }</span>
        } else {
<span class="nc" id="L2417">            closeInternal();</span>
        }
<span class="nc" id="L2419">    }</span>

    private void closeInternal() {
<span class="nc" id="L2422">            SequenceMetaData[] smds = getSequenceMetaDatas();</span>
<span class="nc bnc" id="L2423" title="All 2 branches missed.">            for (int i = 0; i &lt; smds.length; i++)</span>
<span class="nc" id="L2424">                smds[i].close();</span>
<span class="nc" id="L2425">            clear();</span>
<span class="nc" id="L2426">    }</span>

    /**
     * Query key struct.
     */
    private static class QueryKey implements Serializable {

        
        private static final long serialVersionUID = 1L;
        public String clsName;
        public String name;

        @Override
        public int hashCode() {
<span class="nc bnc" id="L2440" title="All 2 branches missed.">            int clsHash = (clsName == null) ? 0 : clsName.hashCode();</span>
<span class="nc bnc" id="L2441" title="All 2 branches missed.">            int nameHash = (name == null) ? 0 : name.hashCode();</span>
<span class="nc" id="L2442">            return clsHash + nameHash;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L2447" title="All 2 branches missed.">            if (obj == this)</span>
<span class="nc" id="L2448">                return true;</span>
<span class="nc bnc" id="L2449" title="All 2 branches missed.">            if (!(obj instanceof QueryKey))</span>
<span class="nc" id="L2450">                return false;</span>

<span class="nc" id="L2452">            QueryKey qk = (QueryKey) obj;</span>
<span class="nc bnc" id="L2453" title="All 4 branches missed.">            return Objects.equals(clsName, qk.clsName) &amp;&amp; Objects.equals(name, qk.name);</span>
        }
    }

    /**
     * Return XML metadata for a given field metadata
     *
     * @return XML metadata
     */
    public XMLMetaData getXMLMetaData(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L2463" title="All 2 branches missed.">        if (_locking) {</span>
<span class="nc" id="L2464">            synchronized (this) {</span>
<span class="nc" id="L2465">                return getXMLMetaDataInternal(cls);</span>
            }
        } else {
<span class="nc" id="L2468">            return getXMLMetaDataInternal(cls);</span>
        }
    }

    private XMLMetaData getXMLMetaDataInternal(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L2473" title="All 2 branches missed.">        if (cls == null) {</span>
<span class="nc" id="L2474">            return null;</span>
        }
        // check if cached before
<span class="nc" id="L2477">        XMLMetaData xmlmeta = _xmlmetas.get(cls);</span>
<span class="nc bnc" id="L2478" title="All 2 branches missed.">        if (xmlmeta != null)</span>
<span class="nc" id="L2479">            return xmlmeta;</span>

        // load JAXB XML metadata
<span class="nc" id="L2482">        _factory.loadXMLMetaData(cls);</span>

<span class="nc" id="L2484">        xmlmeta = _xmlmetas.get(cls);</span>

<span class="nc" id="L2486">        return xmlmeta;</span>
    }

    /**
     * Create a new metadata, populate it with default information, add it to the repository, and
     * return it.
     *
     * @param type the access type to use in populating metadata
     */
    public XMLClassMetaData addXMLClassMetaData(Class&lt;?&gt; type) {
<span class="nc" id="L2496">        XMLClassMetaData meta = newXMLClassMetaData(type);</span>
<span class="nc bnc" id="L2497" title="All 2 branches missed.">        if(_locking){</span>
<span class="nc" id="L2498">            synchronized(this){</span>
<span class="nc" id="L2499">                _xmlmetas.put(type, meta);</span>
<span class="nc" id="L2500">            }</span>
        }else{
<span class="nc" id="L2502">            _xmlmetas.put(type, meta);</span>
        }
<span class="nc" id="L2504">        return meta;</span>
    }

    /**
     * Return the cached XMLClassMetaData for the given class Return null if none.
     */
    public XMLMetaData getCachedXMLMetaData(Class&lt;?&gt; cls) {
<span class="nc" id="L2511">        return _xmlmetas.get(cls);</span>
    }

    /**
     * Create a new xml class metadata
     *
     * @return a XMLClassMetaData
     */
    protected XMLClassMetaData newXMLClassMetaData(Class&lt;?&gt; type) {
<span class="nc" id="L2520">        return new XMLClassMetaData(type);</span>
    }

    /**
     * Create a new xml field meta, add it to the fieldMap in the given xml class metadata
     *
     * @return a XMLFieldMetaData
     */
    public XMLFieldMetaData newXMLFieldMetaData(Class&lt;?&gt; type, String name) {
<span class="nc" id="L2529">        return new XMLFieldMetaData(type, name);</span>
    }

    public static boolean needsPreload(OpenJPAConfiguration conf) {
<span class="nc bnc" id="L2533" title="All 2 branches missed.">        if (conf == null)</span>
<span class="nc" id="L2534">            return false;</span>
<span class="nc" id="L2535">        Options o = Configurations.parseProperties(Configurations.getProperties(conf.getMetaDataRepository()));</span>
<span class="nc bnc" id="L2536" title="All 4 branches missed.">        if (o.getBooleanProperty(PRELOAD_STR) == true || o.getBooleanProperty(PRELOAD_STR.toLowerCase()) == true) {</span>
<span class="nc" id="L2537">            return true;</span>
        }
<span class="nc" id="L2539">        return false;</span>
    }

    /**
     * This private worker ensures that a message is logged when an Entity is enhanced by a version of the enhancer that
     * is older than the current version.
     */
    private void checkEnhancementLevel(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L2547" title="All 2 branches missed.">        if (_logEnhancementLevel == false) {</span>
<span class="nc" id="L2548">            return;</span>
        }
<span class="nc" id="L2550">        Log log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);</span>
<span class="nc" id="L2551">        boolean res = PCEnhancer.checkEnhancementLevel(cls, _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME));</span>
<span class="nc bnc" id="L2552" title="All 4 branches missed.">        if (log.isTraceEnabled() == false &amp;&amp; res == true) {</span>
            // Since trace isn't enabled flip the flag so we only log this once.
<span class="nc" id="L2554">            _logEnhancementLevel = false;</span>
<span class="nc" id="L2555">            log.info(_loc.get(&quot;down-level-entity&quot;));</span>
        }
<span class="nc" id="L2557">    }</span>

    /**
     * This method returns the ClassMetaData whose described type name matches the typeName parameter. It ONLY operates
     * against MetaData that is currently known by this repository. Note: This method call WILL NOT resolve any
     * metadata.
     */
    public ClassMetaData getCachedMetaData(String typeName) {
<span class="nc" id="L2565">        ClassMetaData cmd = _metaStringMap.get(typeName);</span>
<span class="nc bnc" id="L2566" title="All 2 branches missed.">        if (cmd == null) {</span>
<span class="nc bnc" id="L2567" title="All 2 branches missed.">            for (ClassMetaData c : getMetaDatas()) {</span>
<span class="nc bnc" id="L2568" title="All 2 branches missed.">                if (c.getDescribedType().getName().equals(typeName)) {</span>
<span class="nc" id="L2569">                    _metaStringMap.put(typeName, c);</span>
<span class="nc" id="L2570">                    return c;</span>
                }
            }
        }
<span class="nc" id="L2574">        return cmd;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>