<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Compatibility.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-kernel</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.conf</a> &gt; <span class="el_source">Compatibility.java</span></div><h1>Compatibility.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.conf;

/**
 * Struct encompassing backwards-compatibility options.
 */
<span class="nc" id="L24">public class Compatibility {</span>

    /**
     * If a JPQL statement is not compliant with the JPA specification,
     * fail to parse it.
     *
     * @since 1.1.0
     */
    public static final int JPQL_STRICT = 0;

    /**
     * If a JPQL statement is not compliant with the JPA specification,
     * warn the first time that statement is parsed.
     *
     * @since 1.1.0
     */
    public static final int JPQL_WARN = 1;

    /**
     * Allow non-compliant extensions of JPQL.
     *
     * @since 1.1.0
     */
    public static final int JPQL_EXTENDED = 2;

<span class="nc" id="L49">    private boolean _strictIdValues = false;</span>
<span class="nc" id="L50">    private boolean _hollowLookups = true;</span>
<span class="nc" id="L51">    private boolean _checkStore = false;</span>
<span class="nc" id="L52">    private boolean _copyIds = false;</span>
<span class="nc" id="L53">    private boolean _closeOnCommit = true;</span>
<span class="nc" id="L54">    private boolean _quotedNumbers = false;</span>
<span class="nc" id="L55">    private boolean _nonOptimisticVersionCheck = false;</span>
<span class="nc" id="L56">    private int _jpql = JPQL_WARN;</span>
<span class="nc" id="L57">    private boolean _storeMapCollectionInEntityAsBlob = false;</span>
<span class="nc" id="L58">    private boolean _flushBeforeDetach = false;</span>
<span class="nc" id="L59">    private boolean _cascadeWithDetach = false;</span>
<span class="nc" id="L60">    private boolean _useJPA2DefaultOrderColumnName = true;</span>
<span class="nc" id="L61">    private boolean _copyOnDetach = false;</span>
<span class="nc" id="L62">    private boolean _privatePersistentProperties = false;</span>
<span class="nc" id="L63">    private boolean _autoOff = true;</span>
<span class="nc" id="L64">    private boolean _superclassDiscriminatorStrategyByDefault = true;</span>
<span class="nc" id="L65">    private boolean _isAbstractMappingUniDirectional = false;</span>
<span class="nc" id="L66">    private boolean _isNonDefaultMappingAllowed = false;</span>
<span class="nc" id="L67">    private boolean _reloadOnDetach = false;</span>
<span class="nc" id="L68">    private boolean _ignoreDetachedStateFieldForProxySerialization = false;</span>
<span class="nc" id="L69">    private boolean _checkDatabaseForCascadePersistToDetachedEntity = false;</span>
<span class="nc" id="L70">    private boolean _overrideContextClassloader = true;</span>
<span class="nc" id="L71">    private boolean _parseAnnotationsForQueryMode = true;</span>
<span class="nc" id="L72">    private boolean _convertPositionalParametersToNamed = false;</span>

<span class="nc" id="L74">    private boolean _useListAttributeForArrays = false;</span>
<span class="nc" id="L75">    private boolean _metaFactoriesAreStrict = false;</span>
<span class="nc" id="L76">    private boolean _resetFlushFlagForCascadePersist = true;//OPENJPA-2051</span>
<span class="nc" id="L77">    private boolean _singletonLifecycleEventManager = false;</span>
<span class="nc" id="L78">    private boolean _filterPCRegistryClasses = false; // OPENJPA-2288</span>
<span class="nc" id="L79">    private boolean _returnNullOnEmptyAggregateResult = true;   // OPENJPA-1794</span>
<span class="nc" id="L80">    private boolean _cacheNonDefaultFetchPlanQueries = false; // OPENJPA-2414</span>

    /**
     * Whether to require exact identity value types when creating object
     * ids from a class and value. Defaults to false.
     */
    public boolean getStrictIdentityValues() {
<span class="nc" id="L87">        return _strictIdValues;</span>
    }

    /**
     * Whether to require exact identity value types when creating object
     * ids from a class and value. Defaults to false.
     */
    public void setStrictIdentityValues(boolean strictVals) {
<span class="nc" id="L95">        _strictIdValues = strictVals;</span>
<span class="nc" id="L96">    }</span>

    /**
     * Whether to turn collection/map tracing off in case of more number of modifications.
     * Defaults to true.
     */
    public boolean getAutoOff() {
<span class="nc" id="L103">        return _autoOff;</span>
    }

    /**
     * Whether to turn collection/map tracing off in case of more number of modifications.
     * Defaults to true.
     */
    public void setAutoOff(boolean autoOff) {
<span class="nc" id="L111">        _autoOff = autoOff;</span>
<span class="nc" id="L112">    }</span>

    /**
     * Whether to add class criteria for super class discreminator strategy.
     * Defaults to false.
     */
    public boolean getSuperclassDiscriminatorStrategyByDefault() {
<span class="nc" id="L119">        return _superclassDiscriminatorStrategyByDefault;</span>
    }

    /**
     * Whether to add class criteria for super class discreminator strategy.
     * Defaults to false.
     */
    public void setSuperclassDiscriminatorStrategyByDefault(boolean superclassDiscriminatorStrategyByDefault) {
<span class="nc" id="L127">        _superclassDiscriminatorStrategyByDefault = superclassDiscriminatorStrategyByDefault;</span>
<span class="nc" id="L128">    }</span>

    /**
     * Whether to interpret quoted numbers in query strings as numbers.
     * OpenJPA versions 0.3.1 and prior treated them as numbers; more recent
     * versions treat them as strings.
     */
    public boolean getQuotedNumbersInQueries() {
<span class="nc" id="L136">        return _quotedNumbers;</span>
    }

    /**
     * Whether to interpret quoted numbers in query strings as numbers.
     * OpenJPA versions 0.3.1 and prior treated them as numbers; more recent
     * versions treat them as strings.
     */
    public void setQuotedNumbersInQueries(boolean quotedNumbers) {
<span class="nc" id="L145">        _quotedNumbers = quotedNumbers;</span>
<span class="nc" id="L146">    }</span>

    /**
     * Whether to return hollow instances to broker lookups with a
     * &lt;code&gt;validate&lt;/code&gt; parameter of false. OpenJPA versions prior to
     * 0.4.0 did not return hollow instances without special configuration
     * (the &lt;code&gt;ObjectLookupMode&lt;/code&gt;). Beginning with 0.4.0, hollow
     * objects are the default.
     */
    public boolean getValidateFalseReturnsHollow() {
<span class="nc" id="L156">        return _hollowLookups;</span>
    }

    /**
     * Whether to return hollow instances to broker lookups with a
     * &lt;code&gt;validate&lt;/code&gt; parameter of false. OpenJPA versions prior to
     * 0.4.0 did not return hollow instances without special configuration
     * (the &lt;code&gt;ObjectLookupMode&lt;/code&gt;). Beginning with 0.4.0, hollow
     * objects are the default.
     */
    public void setValidateFalseReturnsHollow(boolean hollow) {
<span class="nc" id="L167">        _hollowLookups = hollow;</span>
<span class="nc" id="L168">    }</span>

    /**
     * Whether to check the datastore for the existence of a nontransactional
     * cached object in broker lookups with a &lt;code&gt;validate&lt;/code&gt; parameter
     * of true. OpenJPA versions prior to 0.4.0 checked the datastore.
     */
    public boolean getValidateTrueChecksStore() {
<span class="nc" id="L176">        return _checkStore;</span>
    }

    /**
     * Whether to check the datastore for the existence of a nontransactional
     * cached object in broker lookups with a &lt;code&gt;validate&lt;/code&gt; parameter
     * of true. OpenJPA versions prior to 0.4.0 checked the datastore.
     */
    public void setValidateTrueChecksStore(boolean check) {
<span class="nc" id="L185">        _checkStore = check;</span>
<span class="nc" id="L186">    }</span>

    /**
     * Whether to copy identity objects before returning them to client code.
     * Versions of OpenJPA prior to 0.3.0 always copied identity objects. Also,
     * you should configure OpenJPA to copy identity objects if you mutate them
     * after use.
     */
    public boolean getCopyObjectIds() {
<span class="nc" id="L195">        return _copyIds;</span>
    }

    /**
     * Whether to copy identity objects before returning them to client code.
     * Versions of OpenJPA prior to 0.3.0 always copied identity objects. Also,
     * you should configure OpenJPA to copy identity objects if you mutate them
     * after use.
     */
    public void setCopyObjectIds(boolean copy) {
<span class="nc" id="L205">        _copyIds = copy;</span>
<span class="nc" id="L206">    }</span>

    /**
     * Whether to close the broker when the managed transaction commits.
     * Versions of OpenJPA prior to 0.3.0 did not close the broker.
     */
    public boolean getCloseOnManagedCommit() {
<span class="nc" id="L213">        return _closeOnCommit;</span>
    }

    /**
     * Whether to close the broker when the managed transaction commits.
     * Versions of OpenJPA prior to 0.3.0 did not close the broker.
     */
    public void setCloseOnManagedCommit(boolean close) {
<span class="nc" id="L221">        _closeOnCommit = close;</span>
<span class="nc" id="L222">	}</span>

    /**
     * Whether or not to perform a version check on instances being updated
     * in a datastore transaction. Version of OpenJPA prior to 0.4.1 always
     * forced a version check.
     */
    public void setNonOptimisticVersionCheck(boolean nonOptimisticVersionCheck){
<span class="nc" id="L230">        _nonOptimisticVersionCheck = nonOptimisticVersionCheck;</span>
<span class="nc" id="L231">    }</span>

    /**
     * Whether or not to perform a version check on instances being updated
     * in a datastore transaction. Version of OpenJPA prior to 0.4.1 always
     * forced a version check.
     */
    public boolean getNonOptimisticVersionCheck() {
<span class="nc" id="L239">        return _nonOptimisticVersionCheck;</span>
    }

    /**
     * Whether or not JPQL extensions are allowed. Defaults to
     * {@link #JPQL_STRICT}.
     *
     * @since 1.1.0
     * @see #JPQL_WARN
     * @see #JPQL_STRICT
     * @see #JPQL_EXTENDED
     */
    public int getJPQL() {
<span class="nc" id="L252">        return _jpql;</span>
    }

    /**
     * Whether or not JPQL extensions are allowed. Possible values: &quot;warn&quot;,
     * &quot;strict&quot;, &quot;extended&quot;.
     *
     * @since 1.1.0
     * @see #JPQL_WARN
     * @see #JPQL_STRICT
     * @see #JPQL_EXTENDED
     */
    public void setJPQL(String jpql) {
<span class="nc bnc" id="L265" title="All 2 branches missed.">        if (&quot;warn&quot;.equals(jpql))</span>
<span class="nc" id="L266">            _jpql = JPQL_WARN;</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">        else if (&quot;strict&quot;.equals(jpql))</span>
<span class="nc" id="L268">            _jpql = JPQL_STRICT;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        else if (&quot;extended&quot;.equals(jpql))</span>
<span class="nc" id="L270">            _jpql = JPQL_EXTENDED;</span>
        else
<span class="nc" id="L272">            throw new IllegalArgumentException(jpql);</span>
<span class="nc" id="L273">    }</span>

    /**
     * Whether if map and collection in entity are stored as blob.
     * Defaults to &lt;code&gt;false&lt;/code&gt;.
     *
     * @since 1.1.0
     */

    public boolean getStoreMapCollectionInEntityAsBlob() {
<span class="nc" id="L283">        return _storeMapCollectionInEntityAsBlob;</span>
    }

    /**
     * Whether if map and collection in entity are stored as blob.
     * Defaults to &lt;code&gt;false&lt;/code&gt;.
     *
     * @since 1.1.0
     */
    public void setStoreMapCollectionInEntityAsBlob(boolean storeAsBlob) {
<span class="nc" id="L293">        _storeMapCollectionInEntityAsBlob = storeAsBlob;</span>
<span class="nc" id="L294">    }</span>

    /**
     * Whether OpenJPA should flush changes before detaching or serializing an
     * entity. In JPA this is usually false, but other persistence frameworks
     * (ie JDO) may expect it to be true.
     * &lt;P&gt;Prior to version 1.0.3 and 1.2.0 changes were always flushed.
     *
     * @since 1.0.3
     * @since 1.2.0
     * @return true if changes should be flushed, otherwise false.
     */
    public boolean getFlushBeforeDetach() {
<span class="nc" id="L307">        return _flushBeforeDetach;</span>
    }

    /**
     * Whether OpenJPA should ignore the DetachedStateField value when
     * determining if our Proxy classes should be removed during serialization.
     * &lt;P&gt;Starting with version 2.0.0, when the DetachedStateFiled==true, the
     * build time $proxy classes will not be removed.
     * &lt;P&gt;Prior to version 2.0.0, the DetachedStateFiled was not used and
     * the $proxy classes were not being removed during serialization after
     * the Persistence context was cleared.
     *
     * @param ignoreDSF if true the old Proxy serialization behavior will be used.
     *
     * @since 2.0.0
     */
    public void setIgnoreDetachedStateFieldForProxySerialization(boolean ignoreDSF) {
<span class="nc" id="L324">        _ignoreDetachedStateFieldForProxySerialization = ignoreDSF;</span>
<span class="nc" id="L325">    }</span>

    /**
     * Whether OpenJPA should ignore the DetachedStateField value when
     * determining if our Proxy classes should be removed during serialization.
     * &lt;P&gt;Starting with version 2.0.0, when the DetachedStateFiled==true, the
     * build time $proxy classes will not be removed.
     * &lt;P&gt;Prior to version 2.0.0, the DetachedStateFiled was not used and
     * the $proxy classes were not being removed during serialization after
     * the Persistence context was cleared.
     *
     * @since 2.0.0
     * @return true if the old Proxy serialization will be used, otherwise false.
     */
    public boolean getIgnoreDetachedStateFieldForProxySerialization() {
<span class="nc" id="L340">        return _ignoreDetachedStateFieldForProxySerialization;</span>
    }

    public boolean getConvertPositionalParametersToNamed() {
<span class="nc" id="L344">        return _convertPositionalParametersToNamed;</span>
    }

    public void setConvertPositionalParametersToNamed(boolean c) {
<span class="nc" id="L348">        _convertPositionalParametersToNamed = c;</span>
<span class="nc" id="L349">    }</span>

    /**
     * Whether OpenJPA should flush changes before detaching or serializing an
     * entity. In JPA this is usually false, but other persistence frameworks
     * (ie JDO) may expect it to be true.
     * &lt;P&gt;Prior to version 1.0.3 and 1.2.0 changes were always flushed.
     *
     * @param beforeDetach if true changes will be flushed before detaching or
     * serializing an entity.
     *
     * @since 1.0.3
     * @since 1.2.0
     */
    public void setFlushBeforeDetach(boolean beforeDetach) {
<span class="nc" id="L364">        _flushBeforeDetach = beforeDetach;</span>
<span class="nc" id="L365">    }</span>

    /**
     * Affirms if detached entities are copy of the managed instances.
     * Before this option is introduced, detached entities were by default
     * copies of the managed entities unless the entire cache is detached, only
     * then the detachment was in-place.
     * This option changes the default behavior such that detachment is now
     * in-place by default. To emulate the previous copy-on-detach behavior
     * set this option to true.
     *
     * If the entire cache is being detached (when the persistence context is
     * closed, for example), the detachement
     *
     * @since 2.0.0
     */
    public boolean getCopyOnDetach() {
<span class="nc" id="L382">        return _copyOnDetach;</span>
    }

    /**
     * Sets if detached entities are copy of the managed instances.
     * Before this option is introduced, detached entities were by default
     * copies of the managed entities unless the entire cache is detached, only
     * then the detachment was in-place.
     * This option changes the default behavior such that detachment is now
     * in-place by default. To emulate the previous copy-on-detach behavior
     * set this option to true.
     *
     * @since 2.0.0
     */
    public void setCopyOnDetach(boolean copyOnDetach) {
<span class="nc" id="L397">        _copyOnDetach = copyOnDetach;</span>
<span class="nc" id="L398">    }</span>

    /**
     * Whether openjpa will always cascade on detach, regardless of the
     * cascade setting.
     *
     * @return true if cascade will always occur, false if cascade will only
     * occur if it is specified in metadata
     *
     * @since 2.0.0
     */
    public boolean getCascadeWithDetach() {
<span class="nc" id="L410">        return _cascadeWithDetach;</span>
    }

    /**
     * Whether openjpa should always cascade on detach, regardless of the
     * cascade setting.
     *
     * @param cascadeWithDetach true if cascade should always occur, false if
     * it should only occur if specified in metadata
     *
     * @since 2.0.0
     */
    public void setCascadeWithDetach(boolean cascadeWithDetach) {
<span class="nc" id="L423">        _cascadeWithDetach = cascadeWithDetach;</span>
<span class="nc" id="L424">    }</span>

    /**
     * Whether OpenJPA should use the new default order column name defined
     * by JPA 2.0: name; &quot;_&quot;; &quot;ORDER&quot; or the pre-JPA 2.0 default name &quot;ordr&quot;.
     *
     * @since 2.0.0
     * @return true if the JPA2 default name should be used
     */
    public boolean getUseJPA2DefaultOrderColumnName() {
<span class="nc" id="L434">        return _useJPA2DefaultOrderColumnName;</span>
    }

    /**
     * Whether OpenJPA should use the new default order column name defined
     * by JPA 2.0: name; &quot;_&quot;; &quot;ORDER&quot; or the pre-JPA 2.0 default name &quot;ordr&quot;.
     *
     * @param useJPA2 true if the JPA 2.0 default name should be used.  false if
     * the 1.x name should be used.
     *
     * @since 2.0.0
     */
    public void setUseJPA2DefaultOrderColumnName(boolean useJPA2Name) {
<span class="nc" id="L447">        _useJPA2DefaultOrderColumnName = useJPA2Name;</span>
<span class="nc" id="L448">    }</span>


    /**
     * Whether OpenJPA allows private, non-transient properties to be
     * persistent.  Prior to OpenJPA 2.0, if property access was used,
     * private properties were considered persistent. This is contrary to the
     * JPA specification, which states that persistent properties must be
     * public or protected.  The default value is false.
     *
     * @since 2.0.0
     * @return true if non-transient private properties should be persistent
     */
    public boolean getPrivatePersistentProperties() {
<span class="nc" id="L462">        return _privatePersistentProperties;</span>
    }

    /**
     * Whether OpenJPA allows private, non-transient properties to be
     * persistent.  Prior to OpenJPA 2.0, if property access was used,
     * private properties were considered persistent. This is contrary to the
     * JPA specification, which states that persistent properties must be
     * public or protected.
     *
     * @param privateProps true if non-transient private properties
     *        should be persistent
     * @since 2.0.0
     */
    public void setPrivatePersistentProperties(boolean privateProps) {
<span class="nc" id="L477">        _privatePersistentProperties = privateProps;</span>
<span class="nc" id="L478">    }</span>

    /**
     * Whether OpenJPA allows bi-directional relationship in the MappedSuperclass.
     * Prior to OpenJPA 2.0, the bi-directional relationship in the MappedSuperclass,
     * is not blocked. This is contrary to the JPA specification, which states that
     * persistent relationships defined by a mapped superclass must be
     * unidirectional.
     *
     * @param isAbstractMappingUniDirectional true if relationship defined in the
     *        MappedSuperclass must be uni-directional
     * @since 2.0.0
     */
    public void setAbstractMappingUniDirectional(boolean isAbstractMappingUniDirectional) {
<span class="nc" id="L492">        _isAbstractMappingUniDirectional = isAbstractMappingUniDirectional;</span>
<span class="nc" id="L493">    }</span>


    /**
     * Whether OpenJPA allows bi-directional relationship in the MappedSuperclass.
     * Prior to OpenJPA 2.0, the bi-directional relationship in the MappedSuperclass,
     * is not blocked. This is contrary to the JPA specification, which states that
     * persistent relationships defined by a mapped superclass must be
     * unidirectional. The default value is false.
     *
     * @since 2.0.0
     */
    public boolean isAbstractMappingUniDirectional() {
<span class="nc" id="L506">        return _isAbstractMappingUniDirectional;</span>
    }

    /**
     * Whether OpenJPA allows non-default entity relationship mapping.
     * Prior to OpenJPA 2.0, the non-default entity relationship mapping
     * is not allowed. JPA 2.0 spec relaxes this restriction. The
     * default value is false.
     * @since 2.0.0
     */
    public void setNonDefaultMappingAllowed(boolean isNonDefaultMappingAllowed) {
<span class="nc" id="L517">        _isNonDefaultMappingAllowed = isNonDefaultMappingAllowed;</span>
<span class="nc" id="L518">    }</span>

    /**
     * Whether OpenJPA allows non-default entity relationship mapping.
     * Prior to OpenJPA 2.0, the non-default entity relationship mapping
     * is not allowed. JPA 2.0 spec relaxes this restriction. The
     * default value is false.
     * @since 2.0.0
     */
    public boolean isNonDefaultMappingAllowed() {
<span class="nc" id="L528">        return _isNonDefaultMappingAllowed;</span>
    }

    /**
     * Whether OpenJPA should attempt to load fields when the DetachState
     * option is set to loaded. This also determines whether a
     * redundant copy of the version field is made. Beginning in 2.0
     * it defaults to false.
     *
     * @return the _reloadOnDetach
     *
     * @since 1.2.2
     */
    public boolean getReloadOnDetach() {
<span class="nc" id="L542">        return _reloadOnDetach;</span>
    }

    /**
     * Whether OpenJPA should attempt to load fields when the DetachState
     * option is set to loaded. This also determines whether a
     * redundant copy of the version field is made. Beginning in 2.0
     * it defaults to false.
     *
     * @param reloadOnDetach the _reloadOnDetach to set
     *
     * @since 1.2.2
     */
    public void setReloadOnDetach(boolean reloadOnDetach) {
<span class="nc" id="L556">        _reloadOnDetach = reloadOnDetach;</span>
<span class="nc" id="L557">    }</span>

    /**
     * Whether OpenJPA will check the database for an Entity when cascading a persist to another Entity. This property
     * only applies for the case where we are trying to cascade a persist to an Entity which doesn't have a StateManager
     * and we can't determine if it is detached.
     *
     * @since 2.1.1
     */
    public boolean getCheckDatabaseForCascadePersistToDetachedEntity(){
<span class="nc" id="L567">        return _checkDatabaseForCascadePersistToDetachedEntity;</span>
    }

    /**
     * Whether OpenJPA will check the database for an Entity when cascading a persist to another Entity. This property
     * only applies for the case where we are trying to cascade a persist to an Entity which doesn't have a StateManager
     * and we can't determine if it is detached.
     *
     * @since 2.1.1
     */
    public void setCheckDatabaseForCascadePersistToDetachedEntity(boolean b){
<span class="nc" id="L578">        _checkDatabaseForCascadePersistToDetachedEntity = b;</span>
<span class="nc" id="L579">    }</span>

    /**
     * Whether to temporally override the thread's Context Classloader when processing
     * ORM XML documents to avoid deadlock potential with certain Classloader hierarchy
     * configurations.  Defaults to false.
     */
    public boolean getOverrideContextClassloader() {
<span class="nc" id="L587">        return _overrideContextClassloader;</span>
    }

    /**
     * Whether to temporally override the thread's Context Classloader when processing
     * ORM XML documents to avoid deadlock potential with certain Classloader hierarchy
     * configurations.  Defaults to false.
     */
    public void setOverrideContextClassloader(boolean overrideContextClassloader) {
<span class="nc" id="L596">        _overrideContextClassloader = overrideContextClassloader;</span>
<span class="nc" id="L597">    }</span>

    /**
     * Whether OpenJPA will scan every persistent class in an XML mapping file for annotations prior to executing a
     * query. In practice this scan is rarely needed, but the option to enable it is present for compatibility with
     * prior releases.
     * @since 2.0.2
     * @return true if the annotations should be re-parsed when resolving MetaData in MODE_QUERY.
     */
    public boolean getParseAnnotationsForQueryMode() {
<span class="nc" id="L607">        return _parseAnnotationsForQueryMode;</span>
    }

    /**
     * Whether OpenJPA will scan every persistent class in an XML mapping file for annotations prior to executing a
     * query. In practice this scan is rarely needed, but the option to enable it is present for compatibility with
     * prior releases.
     * @since 2.0.2
     */
    public void setParseAnnotationsForQueryMode(boolean parseAnnotationsForQueryMode) {
<span class="nc" id="L617">        _parseAnnotationsForQueryMode = parseAnnotationsForQueryMode;</span>
<span class="nc" id="L618">    }</span>

    /**
     * This property can be used to allow OpenJPA to use ListAttributes for all types of Arrays, not just those with the
     * &amp;#064; PersistentCollection annotation. If the canonical metamodel classes were generated in an early version of
     * OpenJPA (e.g. 2.0.0, 2.0.1, or 2.1.0) it is recommended to set this property to true. If
     * you have generated your metamodel classes on later versions of OpenJPA (e.g. 2.2.0) you may
     * want to have this set to false.
     *
     * @since 2.2.0
     * @return true if OpenJPA will use ListAttributes for &lt;b&gt;all&lt;/b&gt; arrays, false if OpenJPA will use ListAttributes
     *         for &lt;b&gt;only&lt;/b&gt; arrays which use the @PersistentCollection annotation.
     */
    public boolean getUseListAttributeForArrays() {
<span class="nc" id="L632">        return _useListAttributeForArrays;</span>
    }

    /**
     * This property can be used to allow OpenJPA to use ListAttributes for all types of Arrays, not just those with the
     * &amp;#064;PersistentCollection annotation. If the canonical metamodel classes were generated in an early version of
     * OpenJPA (e.g. 2.0.0, 2.0.1, or 2.1.0) it is recommended to set this property to true. If
     * you have generated your metamodel classes on later versions of OpenJPA (e.g. 2.2.0) you may
     * want to have this set to false.
     * @since 2.2.0
     * @param useListAttribute
     *            whether OpenJPA will use ListAttributes for all arrays.
     */
    public void setUseListAttributeForArrays(boolean useListAttribute ) {
<span class="nc" id="L646">        _useListAttributeForArrays = useListAttribute;</span>
<span class="nc" id="L647">    }</span>

    /**
     * Whether the MetaDataFactory and MappingFactory should be set to strict mode. If strict mode is used a
     * MetaDataFactory will only resolve MetaData (no JDBC mappings), and a MappingFactory will only resolve Mapping
     * information.
     *
     * @since 2.2.0
     * @return Whether strict mode should be used.
     */
    public boolean getMetaFactoriesAreStrict() {
<span class="nc" id="L658">        return _metaFactoriesAreStrict;</span>
    }

    /**
     * Set whether MetaDataFactories and MappingFactories will be strictly separate.
     *
     * @since 2.2.0
     *
     * @param metaFactoriesAreStrict
     *            True if the MetaDataFactory should only process metadata, and the MappingFactory should only process
     *            mappings.
     */
    public void setMetaFactoriesAreStrict(boolean metaFactoriesAreStrict) {
<span class="nc" id="L671">        _metaFactoriesAreStrict = metaFactoriesAreStrict;</span>
<span class="nc" id="L672">    }</span>

    /**
     * Whether OpenJPA should reset the internal state (flush flag) when cascading a persist to another
     * Entity. That is, when a flush is performed, OpenJPA keep state to indicate the flush has been
     * performed.  In certain cascade persist scenarios the fact that a flush has been performed prior to
     * a cascade persist can cause certain entities to not be written to the database given the prior
     * flush.  This property, when set, will cause the flush flag to be reset in cascade scenarios. For more
     * details see JIRA OPENJPA-2051
     *
     * @since 2.0.x
     */
    public boolean getResetFlushFlagForCascadePersist(){
<span class="nc" id="L685">        return _resetFlushFlagForCascadePersist;</span>
    }

    /**
     * Whether OpenJPA should reset the internal state (flush flag) when cascading a persist to another
     * Entity. That is, when a flush is performed, OpenJPA keep state to indicate the flush has been
     * performed.  In certain cascade persist scenarios the fact that a flush has been performed prior to
     * a cascade persist can cause certain entities to not be written to the database given the prior
     * flush.  This property, when set, will cause the flush flag to be reset in cascade scenarios. For more
     * details see JIRA OPENJPA-2051
     *
     * @since 2.0.x
     */
    public void setResetFlushFlagForCascadePersist(boolean b){
<span class="nc" id="L699">        _resetFlushFlagForCascadePersist = b;</span>
<span class="nc" id="L700">    }</span>

    /**
     * Returns true if life cycle event manager is a singleton configuration.
     */
    public boolean isSingletonLifecycleEventManager() {
<span class="nc" id="L706">        return _singletonLifecycleEventManager;</span>
    }

    /**
     * This property set whether each EntityManager has its own life cycle event manager.
       By default, each EntityManager only fires events to the registered listeners to the entities
       it manages. If the life cycle event manager is a singleton, events will be fired to listeners
       registered to all instances of EntityManager in the same persistence unit.
     */
    public void setSingletonLifecycleEventManager(boolean singleton) {
<span class="nc" id="L716">        _singletonLifecycleEventManager = singleton;</span>
<span class="nc" id="L717">    }</span>

    /**
     * Whether the metadata processor should filter classes dispatched by the PCRegistry listener system.
     **/
    public boolean  getFilterPCRegistryClasses() {
<span class="nc" id="L723">        return _filterPCRegistryClasses;</span>
    }

    /**
     * Whether the metadata processor should filter classes dispatched by the PCRegistry listener system.
     **/
    public void setFilterPCRegistryClasses(boolean bool) {
<span class="nc" id="L730">        _filterPCRegistryClasses = bool;</span>
<span class="nc" id="L731">    }</span>

    /**
     * This property is used to specify whether the aggregate query functions
     * SUM, AVG, MAX, and MIN return null if there is no query result.  This will occur
     * if no rows are returned for the specified query predicate. The default is
     * false, meaning that 0 will be returned for functions operating on numeric
     * data.
     *
     * In compliance with the JPA specification, the default value is true.
     *
     * @return true if the result of an aggregate with an empty query result returns null.
     * @since
     *
     */
    public boolean getReturnNullOnEmptyAggregateResult() {
<span class="nc" id="L747">        return _returnNullOnEmptyAggregateResult;</span>
    }

    /**
     * This property is used to specify whether the aggregate query functions
     * SUM, AVG, MAX, and MIN return null if there is no query result.  This will occur
     * if no rows are returned for the specified query predicate. The default is
     * false, meaning that 0 will be returned for functions operating on numeric
     * data.
     *
     * In compliance with the JPA specification, the default value is true.
     *
     * @since
     * @param returnNullOnAggregate whether OpenJPA will return null for aggregate
     * expressions when the query result is empty.
     */
    public void setReturnNullOnAggregateResult(boolean returnNullOnEmptyAggregateResult) {
<span class="nc" id="L764">        _returnNullOnEmptyAggregateResult = returnNullOnEmptyAggregateResult;</span>
<span class="nc" id="L765">    }</span>

    /**
     * Whether the SQL generated for queries executed with a modified fetch plan are cached.
     */
    public boolean  getCacheNonDefaultFetchPlanQueries() {
<span class="nc" id="L771">        return _cacheNonDefaultFetchPlanQueries;</span>
    }

    /**
     * Whether the SQL generated for queries executed with a modified fetch plan are cached.
     */
    public void setCacheNonDefaultFetchPlanQueries(boolean bool) {
<span class="nc" id="L778">        _cacheNonDefaultFetchPlanQueries = bool;</span>
<span class="nc" id="L779">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>