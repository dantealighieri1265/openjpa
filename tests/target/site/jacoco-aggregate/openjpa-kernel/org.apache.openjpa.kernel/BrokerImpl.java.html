<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BrokerImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-kernel</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.kernel</a> &gt; <span class="el_source">BrokerImpl.java</span></div><h1>BrokerImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.kernel;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;

import javax.transaction.Status;
import javax.transaction.Synchronization;

import org.apache.commons.collections4.iterators.IteratorChain;
import org.apache.commons.collections4.map.AbstractReferenceMap.ReferenceStrength;
import org.apache.commons.collections4.map.LinkedMap;
import org.apache.commons.collections4.set.MapBackedSet;
import org.apache.openjpa.conf.Compatibility;
import org.apache.openjpa.conf.OpenJPAConfiguration;
import org.apache.openjpa.datacache.DataCache;
import org.apache.openjpa.datacache.QueryCache;
import org.apache.openjpa.datacache.TypesChangedEvent;
import org.apache.openjpa.ee.ManagedRuntime;
import org.apache.openjpa.enhance.PCRegistry;
import org.apache.openjpa.enhance.PersistenceCapable;
import org.apache.openjpa.enhance.Reflection;
import org.apache.openjpa.event.LifecycleEvent;
import org.apache.openjpa.event.LifecycleEventManager;
import org.apache.openjpa.event.RemoteCommitEventManager;
import org.apache.openjpa.event.TransactionEvent;
import org.apache.openjpa.event.TransactionEventManager;
import org.apache.openjpa.instrumentation.InstrumentationManager;
import org.apache.openjpa.kernel.exps.ExpressionParser;
import org.apache.openjpa.lib.conf.Configurations;
import org.apache.openjpa.lib.instrumentation.InstrumentationLevel;
import org.apache.openjpa.lib.log.Log;
import org.apache.openjpa.lib.util.J2DoPrivHelper;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.lib.util.ReferenceHashMap;
import org.apache.openjpa.lib.util.ReferenceHashSet;
import org.apache.openjpa.lib.util.ReferenceMap;
import org.apache.openjpa.lib.util.StringUtil;
import org.apache.openjpa.meta.ClassMetaData;
import org.apache.openjpa.meta.FieldMetaData;
import org.apache.openjpa.meta.MetaDataRepository;
import org.apache.openjpa.meta.SequenceMetaData;
import org.apache.openjpa.meta.ValueMetaData;
import org.apache.openjpa.meta.ValueStrategies;
import org.apache.openjpa.util.ApplicationIds;
import org.apache.openjpa.util.CallbackException;
import org.apache.openjpa.util.Exceptions;
import org.apache.openjpa.util.GeneralException;
import org.apache.openjpa.util.ImplHelper;
import org.apache.openjpa.util.InternalException;
import org.apache.openjpa.util.InvalidStateException;
import org.apache.openjpa.util.NoTransactionException;
import org.apache.openjpa.util.ObjectExistsException;
import org.apache.openjpa.util.ObjectId;
import org.apache.openjpa.util.ObjectNotFoundException;
import org.apache.openjpa.util.OpenJPAException;
import org.apache.openjpa.util.OptimisticException;
import org.apache.openjpa.util.RuntimeExceptionTranslator;
import org.apache.openjpa.util.StoreException;
import org.apache.openjpa.util.UnsupportedException;
import org.apache.openjpa.util.UserException;
import org.apache.openjpa.util.WrappedException;
import org.apache.openjpa.validation.ValidatingLifecycleEventManager;

/**
 * Concrete {@link Broker}. The broker handles object-level behavior,
 * but leaves all interaction with the data store to a {@link StoreManager}
 * that must be supplied at initialization.
 *
 * @author Abe White
 */
<span class="nc" id="L109">public class BrokerImpl implements Broker, FindCallbacks, Cloneable, Serializable {</span>
    private static final long serialVersionUID = 1L;

    /**
     * Incremental flush.
     */
    protected static final int FLUSH_INC = 0;

    /**
     * Flush in preparation of commit.
     */
    protected static final int FLUSH_COMMIT = 1;

    /**
     * Flush to check consistency of cache, then immediately rollback changes.
     */
    protected static final int FLUSH_ROLLBACK = 2;

    /**
     * Run persistence-by-reachability and other flush-time operations without
     * accessing the database.
     */
    protected static final int FLUSH_LOGICAL = 3;

    static final int STATUS_INIT = 0;
    static final int STATUS_TRANSIENT = 1;
    static final int STATUS_OID_ASSIGN = 2;
    static final int STATUS_COMMIT_NEW = 3;

    private static final int FLAG_ACTIVE = 2 &lt;&lt; 0;
    private static final int FLAG_STORE_ACTIVE = 2 &lt;&lt; 1;
    private static final int FLAG_CLOSE_INVOKED = 2 &lt;&lt; 2;
    private static final int FLAG_PRESTORING = 2 &lt;&lt; 3;
    private static final int FLAG_DEREFDELETING = 2 &lt;&lt; 4;
    private static final int FLAG_FLUSHING = 2 &lt;&lt; 5;
    private static final int FLAG_STORE_FLUSHING = 2 &lt;&lt; 6;
    private static final int FLAG_FLUSHED = 2 &lt;&lt; 7;
    private static final int FLAG_FLUSH_REQUIRED = 2 &lt;&lt; 8;
    private static final int FLAG_REMOTE_LISTENER = 2 &lt;&lt; 9;
    private static final int FLAG_RETAINED_CONN = 2 &lt;&lt; 10;
    private static final int FLAG_TRANS_ENDING = 2 &lt;&lt; 11;

<span class="nc" id="L151">    private static final Object[] EMPTY_OBJECTS = new Object[0];</span>

<span class="nc" id="L153">    private String _connectionFactoryName = &quot;&quot;;</span>
<span class="nc" id="L154">    private String _connectionFactory2Name = &quot;&quot;;</span>

<span class="nc" id="L156">    private static final Localizer _loc =</span>
<span class="nc" id="L157">        Localizer.forPackage(BrokerImpl.class);</span>

    //	the store manager in use; this may be a decorator such as a
    //	data cache store manager around the native store manager
<span class="nc" id="L161">    private transient DelegatingStoreManager _store = null;</span>

<span class="nc" id="L163">    private FetchConfiguration _fc = null;</span>
<span class="nc" id="L164">    private String _user = null;</span>
<span class="nc" id="L165">    private String _pass = null;</span>

    // these must be rebuilt by the facade layer during its deserialization
<span class="nc" id="L168">    private transient Log _log = null;</span>
<span class="nc" id="L169">    private transient Compatibility _compat = null;</span>
<span class="nc" id="L170">    private transient ManagedRuntime _runtime = null;</span>
<span class="nc" id="L171">    private transient LockManager _lm = null;</span>
<span class="nc" id="L172">    private transient InverseManager _im = null;</span>
<span class="nc" id="L173">    private transient ReentrantLock _lock = null;</span>
<span class="nc" id="L174">    private transient OpCallbacks _call = null;</span>
<span class="nc" id="L175">    private transient RuntimeExceptionTranslator _extrans = null;</span>
<span class="nc" id="L176">    private transient InstrumentationManager _instm = null;</span>

    // ref to producing factory and configuration
<span class="nc" id="L179">    private transient AbstractBrokerFactory _factory = null;</span>
<span class="nc" id="L180">    private transient OpenJPAConfiguration _conf = null;</span>
<span class="nc" id="L181">    private transient MetaDataRepository _repo = null;</span>

    // cache class loader associated with the broker
<span class="nc" id="L184">    private transient ClassLoader _loader = null;</span>

    // user state
<span class="nc" id="L187">    private Synchronization _sync = null;</span>
<span class="nc" id="L188">    private Map&lt;Object, Object&gt; _userObjects = null;</span>

    // managed object caches
<span class="nc" id="L191">    private ManagedCache _cache = null;</span>
<span class="nc" id="L192">    private TransactionalCache _transCache = null;</span>
<span class="nc" id="L193">    private Set&lt;StateManagerImpl&gt; _transAdditions = null;</span>
<span class="nc" id="L194">    private Set&lt;StateManagerImpl&gt; _derefCache = null;</span>
<span class="nc" id="L195">    private Set&lt;StateManagerImpl&gt; _derefAdditions = null;</span>

    // these are used for method-internal state only
<span class="nc" id="L198">    private transient Map&lt;Object, StateManagerImpl&gt; _loading = null;</span>
<span class="nc" id="L199">    private transient Set&lt;Object&gt; _operating = null;</span>
<span class="nc" id="L200">    private transient boolean _operatingDirty = true;</span>

<span class="nc" id="L202">    private Set&lt;Class&lt;?&gt;&gt; _persistedClss = null;</span>
<span class="nc" id="L203">    private Set&lt;Class&lt;?&gt;&gt; _updatedClss = null;</span>
<span class="nc" id="L204">    private Set&lt;Class&lt;?&gt;&gt; _deletedClss = null;</span>
<span class="nc" id="L205">    private Set&lt;StateManagerImpl&gt; _pending = null;</span>
<span class="nc" id="L206">    private int findAllDepth = 0;</span>

    // track instances that become transactional after the first savepoint
    // (the first uses the transactional cache)
<span class="nc" id="L210">    private Set&lt;StateManagerImpl&gt; _savepointCache = null;</span>
<span class="nc" id="L211">    private LinkedMap _savepoints = null;</span>
<span class="nc" id="L212">    private transient SavepointManager _spm = null;</span>

    // track open queries and extents so we can free their resources on close
<span class="nc" id="L215">    private transient ReferenceHashSet _queries = null;</span>
<span class="nc" id="L216">    private transient ReferenceHashSet _extents = null;</span>

    // track operation stack depth. Transient because operations cannot
    // span serialization.
<span class="nc" id="L220">    private transient int _operationCount = 0;</span>

    // options
<span class="nc" id="L223">    private boolean _nontransRead = false;</span>
<span class="nc" id="L224">    private boolean _nontransWrite = false;</span>
<span class="nc" id="L225">    private boolean _retainState = false;</span>
<span class="nc" id="L226">    private int _autoClear = CLEAR_DATASTORE;</span>
<span class="nc" id="L227">    private int _restoreState = RESTORE_IMMUTABLE;</span>
<span class="nc" id="L228">    private boolean _optimistic = false;</span>
<span class="nc" id="L229">    private boolean _ignoreChanges = false;</span>
<span class="nc" id="L230">    private boolean _multithreaded = false;</span>
<span class="nc" id="L231">    private boolean _managed = false;</span>
<span class="nc" id="L232">    private boolean _syncManaged = false;</span>
<span class="nc" id="L233">    private int _connRetainMode = CONN_RETAIN_DEMAND;</span>
<span class="nc" id="L234">    private boolean _evictDataCache = false;</span>
<span class="nc" id="L235">    private boolean _populateDataCache = true;</span>
<span class="nc" id="L236">    private boolean _largeTransaction = false;</span>
<span class="nc" id="L237">    private int _autoDetach = 0;</span>
<span class="nc" id="L238">    private int _detachState = DETACH_LOADED;</span>
<span class="nc" id="L239">    private boolean _detachedNew = true;</span>
<span class="nc" id="L240">    private boolean _orderDirty = false;</span>
<span class="nc" id="L241">    private boolean _cachePreparedQuery = true;</span>
<span class="nc" id="L242">    private boolean _cacheFinderQuery = true;</span>
<span class="nc" id="L243">    private boolean _suppressBatchOLELogging = false;</span>
<span class="nc" id="L244">    private boolean _allowReferenceToSiblingContext = false;</span>
<span class="nc" id="L245">    private boolean _postLoadOnMerge = false;</span>

    // status
<span class="nc" id="L248">    private int _flags = 0;</span>

    // this is not in status because it should not be serialized
<span class="nc" id="L251">    private transient boolean _isSerializing = false;</span>

    // transient because closed brokers can't be serialized
<span class="nc" id="L254">    private transient boolean _closed = false;</span>
<span class="nc" id="L255">    private transient RuntimeException _closedException = null;</span>

    // event managers
<span class="nc" id="L258">    private TransactionEventManager _transEventManager = null;</span>
<span class="nc" id="L259">    private int _transCallbackMode = 0;</span>
<span class="nc" id="L260">    private LifecycleEventManager _lifeEventManager = null;</span>
<span class="nc" id="L261">    private int _lifeCallbackMode = 0;</span>

    private transient DetachManagerLite _dmLite;

<span class="nc" id="L265">    private transient boolean _initializeWasInvoked = false;</span>
<span class="nc" id="L266">    private transient boolean _fromWriteBehindCallback = false;</span>
    private LinkedList&lt;FetchConfiguration&gt; _fcs;

    // Set of supported property keys. The keys in this set correspond to bean-style setter methods
    // that can be set by reflection. The keys are not qualified by any prefix.
    private static Set&lt;String&gt; _supportedPropertyNames;
    static {
<span class="nc" id="L273">        _supportedPropertyNames = new HashSet&lt;&gt;();</span>
<span class="nc" id="L274">        _supportedPropertyNames.addAll(Arrays.asList(new String[] {</span>
                &quot;AutoClear&quot;,
                &quot;AutoDetach&quot;,
                &quot;CacheFinderQuery&quot;,
                &quot;CachePreparedQuery&quot;,
                &quot;DetachedNew&quot;,
                &quot;DetachState&quot;,
                &quot;EvictFromDataCache&quot;,
                &quot;IgnoreChanges&quot;,
                &quot;LifecycleListenerCallbackMode&quot;,
                &quot;Multithreaded&quot;,
                &quot;NontransactionalRead&quot;,
                &quot;NontransactionalWrite&quot;,
                &quot;Optimistic&quot;,
                &quot;PopulateDataCache&quot;,
                &quot;RestoreState&quot;,
                &quot;RetainState&quot;,
                }));
<span class="nc" id="L292">    }</span>

<span class="nc" id="L294">    private boolean _printParameters = false;</span>
    private static final String PRINT_PARAMETERS_CONFIG_STR = &quot;PrintParameters&quot;;

    /**
     * Set the persistence manager's authentication. This is the first
     * method called after construction.
     *
     * @param user the username this broker represents; used when pooling
     * brokers to make sure that a request to the factory for
     * a connection with an explicit user is delegated to a suitable broker
     * @param pass the password for the above user
     */
    public void setAuthentication(String user, String pass) {
<span class="nc" id="L307">        _user = user;</span>
<span class="nc" id="L308">        _pass = pass;</span>
<span class="nc" id="L309">    }</span>

    /**
     * Initialize the persistence manager. This method is called
     * automatically by the factory before use.
     *
     * @param factory the factory used to create this broker
     * @param sm a concrete StoreManager implementation to
     * handle interaction with the data store
     * @param managed the transaction mode
     * @param connMode the connection retain mode
     * @param fromDeserialization whether this call happened because of a
     * deserialization or creation of a new BrokerImpl.
     */
    public void initialize(AbstractBrokerFactory factory,
        DelegatingStoreManager sm, boolean managed, int connMode,
        boolean fromDeserialization) {
<span class="nc" id="L326">        initialize(factory, sm, managed, connMode, fromDeserialization, false);</span>
<span class="nc" id="L327">    }</span>

    public void initialize(AbstractBrokerFactory factory,
        DelegatingStoreManager sm, boolean managed, int connMode,
        boolean fromDeserialization, boolean fromWriteBehindCallback) {
<span class="nc" id="L332">        _fromWriteBehindCallback = fromWriteBehindCallback;</span>
<span class="nc" id="L333">        _initializeWasInvoked = true;</span>
<span class="nc" id="L334">        _loader = AccessController.doPrivileged(</span>
<span class="nc" id="L335">            J2DoPrivHelper.getContextClassLoaderAction());</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (!fromDeserialization){</span>
<span class="nc" id="L337">            _conf = factory.getConfiguration();</span>
<span class="nc" id="L338">            _repo = _conf.getMetaDataRepositoryInstance();</span>
        }
<span class="nc" id="L340">        _compat = _conf.getCompatibilityInstance();</span>
<span class="nc" id="L341">        _factory = factory;</span>
<span class="nc" id="L342">        _log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (!fromDeserialization)</span>
<span class="nc" id="L344">            _cache = new ManagedCache(this);</span>
        // Force creation of a new operating set
<span class="nc" id="L346">        _operatingDirty = true;</span>
<span class="nc" id="L347">        initializeOperatingSet();</span>

<span class="nc" id="L349">        _connRetainMode = connMode;</span>
<span class="nc" id="L350">        _managed = managed;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">        if (managed)</span>
<span class="nc" id="L352">            _runtime = _conf.getManagedRuntimeInstance();</span>
        else
<span class="nc" id="L354">            _runtime = new LocalManagedRuntime(this);</span>

<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (!fromDeserialization) {</span>
<span class="nc" id="L357">            _lifeEventManager = _conf.getLifecycleEventManagerInstance();</span>
<span class="nc" id="L358">            _transEventManager = new TransactionEventManager();</span>
<span class="nc" id="L359">            int cmode = _repo.getMetaDataFactory().getDefaults().getCallbackMode();</span>
<span class="nc" id="L360">            setLifecycleListenerCallbackMode(cmode);</span>
<span class="nc" id="L361">            setTransactionListenerCallbackMode(cmode);</span>

            // setup default options
<span class="nc" id="L364">            _factory.configureBroker(this);</span>
        }

        // make sure to do this after configuring broker so that store manager
        // can look to broker configuration; we set both store and lock managers
        // before initializing them because they may each try to access the
        // other in their initialization
<span class="nc" id="L371">        _store = sm;</span>
<span class="nc" id="L372">        _lm = _conf.newLockManagerInstance();</span>
<span class="nc" id="L373">        _im = _conf.newInverseManagerInstance();</span>
<span class="nc" id="L374">        _spm = _conf.getSavepointManagerInstance();</span>
<span class="nc" id="L375">        _store.setContext(this);</span>
<span class="nc" id="L376">        _lm.setContext(this);</span>

<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (_connRetainMode == CONN_RETAIN_ALWAYS)</span>
<span class="nc" id="L379">            retainConnection();</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (!fromDeserialization) {</span>
<span class="nc" id="L381">            _fc = _store.newFetchConfiguration();</span>
<span class="nc" id="L382">            _fc.setContext(this);</span>
        }

<span class="nc" id="L385">        _instm = _conf.getInstrumentationManagerInstance();</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (_instm != null) {</span>
<span class="nc" id="L387">            _instm.start(InstrumentationLevel.BROKER, this);</span>
        }

<span class="nc" id="L390">        _dmLite = new DetachManagerLite(_conf);</span>
<span class="nc" id="L391">        _printParameters =</span>
<span class="nc" id="L392">            Boolean.parseBoolean(Configurations.parseProperties(_conf.getConnectionFactoryProperties()).getProperty(</span>
                PRINT_PARAMETERS_CONFIG_STR, &quot;false&quot;));

        // do it before begin event otherwise transactional listeners can't use it, see @Auditable
<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (!fromDeserialization)</span>
<span class="nc" id="L397">            _factory.addListeners(this);</span>

        // synch with the global transaction in progress, if any
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (_factory.syncWithManagedTransaction(this, false))</span>
<span class="nc" id="L401">            beginInternal();</span>
<span class="nc" id="L402">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void initializeOperatingSet() {
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if(_operatingDirty) {</span>
<span class="nc" id="L407">            _operatingDirty = false;</span>
<span class="nc" id="L408">            _operating = MapBackedSet.mapBackedSet(new IdentityHashMap&lt;&gt;());</span>
        }
<span class="nc" id="L410">    }</span>

    /**
     * Gets the unmodifiable set of instances being operated.
     */
    protected Set&lt;Object&gt; getOperatingSet() {
<span class="nc" id="L416">    	return Collections.unmodifiableSet(_operating);</span>
    }

    @Override
    public Object clone()
        throws CloneNotSupportedException {
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (_initializeWasInvoked)</span>
<span class="nc" id="L423">            throw new CloneNotSupportedException();</span>
        else {
<span class="nc" id="L425">            return super.clone();</span>
        }
    }

    /**
     * Create a {@link Map} to be used for the primary managed object cache.
     * Maps oids to state managers. By default, this creates a
     * {@link ReferenceMap} with soft values.
     */
    protected Map&lt;?,?&gt; newManagedObjectCache() {
<span class="nc" id="L435">        return new ReferenceHashMap(ReferenceStrength.HARD, ReferenceStrength.SOFT);</span>
    }

    //////////////////////////////////
    // Implementation of StoreContext
    //////////////////////////////////

    @Override
    public Broker getBroker() {
<span class="nc" id="L444">        return this;</span>
    }

    //////////////
    // Properties
    //////////////

    @Override
    public void setImplicitBehavior(OpCallbacks call,
        RuntimeExceptionTranslator ex) {
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (_call == null)</span>
<span class="nc" id="L455">            _call = call;</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (_extrans == null)</span>
<span class="nc" id="L457">            _extrans = ex;</span>
<span class="nc" id="L458">    }</span>

    RuntimeExceptionTranslator getInstanceExceptionTranslator() {
<span class="nc bnc" id="L461" title="All 2 branches missed.">        return (_operationCount == 0) ? _extrans : null;</span>
    }

    @Override
    public BrokerFactory getBrokerFactory() {
<span class="nc" id="L466">        return _factory;</span>
    }

    @Override
    public OpenJPAConfiguration getConfiguration() {
<span class="nc" id="L471">        return _conf;</span>
    }

    @Override
    public FetchConfiguration getFetchConfiguration() {
<span class="nc" id="L476">        return _fc;</span>
    }

    @Override
    public FetchConfiguration pushFetchConfiguration() {
<span class="nc" id="L481">		return pushFetchConfiguration(null);</span>
    }

    @Override
    public FetchConfiguration pushFetchConfiguration(FetchConfiguration fc) {
<span class="nc bnc" id="L486" title="All 2 branches missed.">        if (_fcs == null)</span>
<span class="nc" id="L487">            _fcs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L488">        _fcs.add(_fc);</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">        _fc = (FetchConfiguration) (fc != null ? fc : _fc).clone();</span>
<span class="nc" id="L490">        return _fc;</span>
    }

    @Override
    public void popFetchConfiguration() {
<span class="nc bnc" id="L495" title="All 4 branches missed.">        if (_fcs == null || _fcs.isEmpty())</span>
<span class="nc" id="L496">            throw new UserException(</span>
<span class="nc" id="L497">                    _loc.get(&quot;fetch-configuration-stack-empty&quot;));</span>
<span class="nc" id="L498">        _fc = _fcs.removeLast();</span>
<span class="nc" id="L499">    }</span>

    @Override
    public int getConnectionRetainMode() {
<span class="nc" id="L503">        return _connRetainMode;</span>
    }

    @Override
    public boolean isManaged() {
<span class="nc" id="L508">        return _managed;</span>
    }

    @Override
    public ManagedRuntime getManagedRuntime() {
<span class="nc" id="L513">        return _runtime;</span>
    }

    @Override
    public ClassLoader getClassLoader() {
<span class="nc" id="L518">        return _loader;</span>
    }

    @Override
    public DelegatingStoreManager getStoreManager() {
<span class="nc" id="L523">        return _store;</span>
    }

    @Override
    public LockManager getLockManager() {
<span class="nc" id="L528">        return _lm;</span>
    }

    @Override
    public InverseManager getInverseManager() {
<span class="nc" id="L533">        return _im;</span>
    }

    @Override
    public String getConnectionUserName() {
<span class="nc" id="L538">        return _user;</span>
    }

    @Override
    public String getConnectionPassword() {
<span class="nc" id="L543">        return _pass;</span>
    }

    @Override
    public boolean getMultithreaded() {
<span class="nc" id="L548">        return _multithreaded;</span>
    }

    @Override
    public void setMultithreaded(boolean multithreaded) {
<span class="nc" id="L553">        assertOpen();</span>
<span class="nc" id="L554">        _multithreaded = multithreaded;</span>
<span class="nc bnc" id="L555" title="All 4 branches missed.">        if (multithreaded &amp;&amp; _lock == null)</span>
<span class="nc" id="L556">            _lock = new ReentrantLock();</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">        else if (!multithreaded)</span>
<span class="nc" id="L558">            _lock = null;</span>
<span class="nc" id="L559">    }</span>

    @Override
    public boolean getIgnoreChanges() {
<span class="nc" id="L563">        return _ignoreChanges;</span>
    }

    @Override
    public void setIgnoreChanges(boolean val) {
<span class="nc" id="L568">        assertOpen();</span>
<span class="nc" id="L569">        _ignoreChanges = val;</span>
<span class="nc" id="L570">    }</span>

    @Override
    public boolean getNontransactionalRead() {
<span class="nc" id="L574">        return _nontransRead;</span>
    }

    @Override
    public void setNontransactionalRead(boolean val) {
<span class="nc" id="L579">        assertOpen();</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">        if ((_flags &amp; FLAG_PRESTORING) != 0)</span>
<span class="nc" id="L581">            throw new UserException(_loc.get(&quot;illegal-op-in-prestore&quot;));</span>

        // make sure the runtime supports it
<span class="nc bnc" id="L584" title="All 2 branches missed.">        if (val &amp;&amp; !_conf.supportedOptions().contains</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">            (OpenJPAConfiguration.OPTION_NONTRANS_READ))</span>
<span class="nc" id="L586">            throw new UnsupportedException(_loc.get</span>
<span class="nc" id="L587">                (&quot;nontrans-read-not-supported&quot;));</span>

<span class="nc" id="L589">        _nontransRead = val;</span>
<span class="nc" id="L590">    }</span>

    @Override
    public boolean getNontransactionalWrite() {
<span class="nc" id="L594">        return _nontransWrite;</span>
    }

    @Override
    public void setNontransactionalWrite(boolean val) {
<span class="nc" id="L599">        assertOpen();</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if ((_flags &amp; FLAG_PRESTORING) != 0)</span>
<span class="nc" id="L601">            throw new UserException(_loc.get(&quot;illegal-op-in-prestore&quot;));</span>

<span class="nc" id="L603">        _nontransWrite = val;</span>
<span class="nc" id="L604">    }</span>

    @Override
    public boolean getOptimistic() {
<span class="nc" id="L608">        return _optimistic;</span>
    }

    @Override
    public void setOptimistic(boolean val) {
<span class="nc" id="L613">        assertOpen();</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if ((_flags &amp; FLAG_ACTIVE) != 0)</span>
<span class="nc" id="L615">            throw new InvalidStateException(_loc.get(&quot;trans-active&quot;,</span>
                &quot;Optimistic&quot;));

        // make sure the runtime supports it
<span class="nc bnc" id="L619" title="All 4 branches missed.">        if (val &amp;&amp; !_conf.supportedOptions().contains(OpenJPAConfiguration.OPTION_OPTIMISTIC))</span>
<span class="nc" id="L620">            throw new UnsupportedException(_loc.get</span>
<span class="nc" id="L621">                (&quot;optimistic-not-supported&quot;));</span>

<span class="nc" id="L623">        _optimistic = val;</span>
<span class="nc" id="L624">    }</span>

    @Override
    public int getRestoreState() {
<span class="nc" id="L628">        return _restoreState;</span>
    }

    @Override
    public void setRestoreState(int val) {
<span class="nc" id="L633">        assertOpen();</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">        if ((_flags &amp; FLAG_ACTIVE) != 0)</span>
<span class="nc" id="L635">            throw new InvalidStateException(_loc.get(&quot;trans-active&quot;,</span>
                &quot;Restore&quot;));

<span class="nc" id="L638">        _restoreState = val;</span>
<span class="nc" id="L639">    }</span>

    @Override
    public boolean getRetainState() {
<span class="nc" id="L643">        return _retainState;</span>
    }

    @Override
    public void setRetainState(boolean val) {
<span class="nc" id="L648">        assertOpen();</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">        if ((_flags &amp; FLAG_PRESTORING) != 0)</span>
<span class="nc" id="L650">            throw new UserException(_loc.get(&quot;illegal-op-in-prestore&quot;));</span>
<span class="nc" id="L651">        _retainState = val;</span>
<span class="nc" id="L652">    }</span>

    @Override
    public int getAutoClear() {
<span class="nc" id="L656">        return _autoClear;</span>
    }

    @Override
    public void setAutoClear(int val) {
<span class="nc" id="L661">        assertOpen();</span>
<span class="nc" id="L662">        _autoClear = val;</span>
<span class="nc" id="L663">    }</span>

    @Override
    public int getAutoDetach() {
<span class="nc" id="L667">        return _autoDetach;</span>
    }
    /**
     * Sets automatic detachment option.
     * &lt;br&gt;
     * If the given flag contains {@link AutoDetach#DETACH_NONE} option,
     * then no other option can be specified.
     */
    @Override
    public void setAutoDetach(int detachFlags) {
<span class="nc" id="L677">         assertOpen();</span>
<span class="nc" id="L678">         assertAutoDetachValue(detachFlags);</span>
<span class="nc" id="L679">         _autoDetach = detachFlags;</span>
<span class="nc" id="L680">    }</span>

    @Override
    public void setAutoDetach(int detachFlag, boolean on) {
<span class="nc" id="L684">         assertOpen();</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">         assertAutoDetachValue(on ? _autoDetach | detachFlag : _autoDetach &amp; ~detachFlag);</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">         if (on)</span>
<span class="nc" id="L687">             _autoDetach |= detachFlag;</span>
         else
<span class="nc" id="L689">             _autoDetach &amp;= ~detachFlag;</span>
<span class="nc" id="L690">    }</span>

    @Override
    public int getDetachState() {
<span class="nc" id="L694">        return _detachState;</span>
    }

    @Override
    public void setDetachState(int mode) {
<span class="nc" id="L699">        assertOpen();</span>
<span class="nc" id="L700">        _detachState = mode;</span>
<span class="nc" id="L701">    }</span>

    @Override
    public boolean isDetachedNew() {
<span class="nc" id="L705">        return _detachedNew;</span>
    }

    @Override
    public void setDetachedNew(boolean isNew) {
<span class="nc" id="L710">        assertOpen();</span>
<span class="nc" id="L711">        _detachedNew = isNew;</span>
<span class="nc" id="L712">    }</span>

    @Override
    public boolean getSyncWithManagedTransactions() {
<span class="nc" id="L716">        return _syncManaged;</span>
    }

    @Override
    public void setSyncWithManagedTransactions(boolean sync) {
<span class="nc" id="L721">        assertOpen();</span>
<span class="nc" id="L722">        _syncManaged = sync;</span>
<span class="nc" id="L723">    }</span>

    @Override
    public boolean getEvictFromDataCache() {
<span class="nc" id="L727">        return _evictDataCache;</span>
    }

    @Override
    public void setEvictFromDataCache(boolean evict) {
<span class="nc" id="L732">        assertOpen();</span>
<span class="nc" id="L733">        _evictDataCache = evict;</span>
<span class="nc" id="L734">    }</span>

    @Override
    public boolean getPopulateDataCache() {
<span class="nc" id="L738">        return _populateDataCache;</span>
    }

    @Override
    public void setPopulateDataCache(boolean cache) {
<span class="nc" id="L743">        assertOpen();</span>
<span class="nc" id="L744">        _populateDataCache = cache;</span>
<span class="nc" id="L745">    }</span>

    @Override
    public boolean isTrackChangesByType() {
<span class="nc" id="L749">        return _largeTransaction;</span>
    }

    @Override
    public void setTrackChangesByType(boolean largeTransaction) {
<span class="nc" id="L754">        assertOpen();</span>
<span class="nc" id="L755">        _largeTransaction = largeTransaction;</span>
<span class="nc" id="L756">    }</span>

    @Override
    public Object getUserObject(Object key) {
<span class="nc" id="L760">        beginOperation(false);</span>
        try {
<span class="nc bnc" id="L762" title="All 2 branches missed.">            return (_userObjects == null) ? null : _userObjects.get(key);</span>
        } finally {
<span class="nc" id="L764">            endOperation();</span>
        }
    }

    @Override
    public Object putUserObject(Object key, Object val) {
<span class="nc" id="L770">        beginOperation(false);</span>
        try {
<span class="nc bnc" id="L772" title="All 2 branches missed.">            if (val == null)</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">                return (_userObjects == null) ? null : _userObjects.remove(key);</span>

<span class="nc bnc" id="L775" title="All 2 branches missed.">            if (_userObjects == null)</span>
<span class="nc" id="L776">                _userObjects = new HashMap&lt;&gt;();</span>
<span class="nc" id="L777">            return _userObjects.put(key, val);</span>
        } finally {
<span class="nc" id="L779">            endOperation();</span>
        }
    }

    /**
     * Get current configuration property values used by this instance.
     * This values are combination of the current configuration values
     * overwritten by values maintained by this instance such as
     * Optimistic flag.
     */
    @Override
    public Map&lt;String, Object&gt; getProperties() {
<span class="nc" id="L791">        Map&lt;String, Object&gt; props = _conf.toProperties(true);</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">        for (String s : _supportedPropertyNames) {</span>
<span class="nc" id="L793">            props.put(&quot;openjpa.&quot; + s, Reflection.getValue(this, s, true));</span>
<span class="nc" id="L794">        }</span>
<span class="nc" id="L795">        return props;</span>
    }

    /**
     * Gets the property names that can be used to corresponding setter methods of this receiver
     * to set its value.
     */
    @Override
    public Set&lt;String&gt; getSupportedProperties() {
<span class="nc" id="L804">        Set&lt;String&gt; keys = _conf.getPropertyKeys();</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">        for (String s : _supportedPropertyNames)</span>
<span class="nc" id="L806">            keys.add(&quot;openjpa.&quot; + s);</span>
<span class="nc" id="L807">        return keys;</span>
    }

    // ////////
    // Events
    // ////////

    @Override
    public void addLifecycleListener(Object listener, Class[] classes) {
<span class="nc" id="L816">        beginOperation(false);</span>
        try {
<span class="nc" id="L818">            _lifeEventManager.addListener(listener, classes);</span>
        } finally {
<span class="nc" id="L820">            endOperation();</span>
        }
<span class="nc" id="L822">    }</span>

    @Override
    public void removeLifecycleListener(Object listener) {
<span class="nc" id="L826">        beginOperation(false);</span>
        try {
<span class="nc" id="L828">            _lifeEventManager.removeListener(listener);</span>
        } finally {
<span class="nc" id="L830">            endOperation();</span>
        }
<span class="nc" id="L832">    }</span>

    @Override
    public int getLifecycleListenerCallbackMode() {
<span class="nc" id="L836">        return _lifeCallbackMode;</span>
    }

    @Override
    public void setLifecycleListenerCallbackMode(int mode) {
<span class="nc" id="L841">        beginOperation(false);</span>
        try {
<span class="nc" id="L843">            _lifeCallbackMode = mode;</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">            _lifeEventManager.setFailFast((mode &amp; CALLBACK_FAIL_FAST) != 0);</span>
        } finally {
<span class="nc" id="L846">            endOperation();</span>
        }
<span class="nc" id="L848">    }</span>

    /**
     * Give state managers access to the lifecycle event manager.
     */
    @Override
    public LifecycleEventManager getLifecycleEventManager() {
<span class="nc" id="L855">        return _lifeEventManager;</span>
    }

    /**
     * Fire given lifecycle event, handling any exceptions appropriately.
     *
     * @return whether events are being processed at this time
     */
    boolean fireLifecycleEvent(Object src, Object related, ClassMetaData meta,
        int eventType) {
<span class="nc bnc" id="L865" title="All 2 branches missed.">        if (_lifeEventManager == null)</span>
<span class="nc" id="L866">            return false;</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">        if (!_lifeEventManager.isActive(meta))</span>
<span class="nc" id="L868">            return false;</span>

<span class="nc" id="L870">        lock();</span>
        Exception[] exs;
        try {
<span class="nc" id="L873">            exs = _lifeEventManager.fireEvent(src, related, meta, eventType);</span>
        } finally {
<span class="nc" id="L875">            unlock();</span>
        }
<span class="nc" id="L877">        handleCallbackExceptions(exs, _lifeCallbackMode);</span>
<span class="nc" id="L878">        return true;</span>
    }

    /**
     * Take actions on callback exceptions depending on callback mode.
     */
    private void handleCallbackExceptions(Exception[] exceps, int mode) {
<span class="nc bnc" id="L885" title="All 4 branches missed.">        if (exceps.length == 0 || (mode &amp; CALLBACK_IGNORE) != 0)</span>
<span class="nc" id="L886">            return;</span>

        OpenJPAException ce;
<span class="nc bnc" id="L889" title="All 2 branches missed.">        if (exceps.length == 1) {</span>
            // If the exception is already a wrapped exception throw the
            // exception instead of wrapping it with a callback exception
<span class="nc bnc" id="L892" title="All 2 branches missed.">            if (exceps[0] instanceof WrappedException)</span>
<span class="nc" id="L893">                throw (WrappedException)exceps[0];</span>
            else
<span class="nc" id="L895">                ce = new CallbackException(exceps[0]);</span>
        } else {
<span class="nc" id="L897">            ce = new CallbackException(_loc.get(&quot;callback-err&quot;)).</span>
<span class="nc" id="L898">                setNestedThrowables(exceps);</span>
        }
<span class="nc bnc" id="L900" title="All 4 branches missed.">        if ((mode &amp; CALLBACK_ROLLBACK) != 0 &amp;&amp; (_flags &amp; FLAG_ACTIVE) != 0) {</span>
<span class="nc" id="L901">            ce.setFatal(true);</span>
<span class="nc" id="L902">            setRollbackOnlyInternal(ce);</span>
        }
<span class="nc bnc" id="L904" title="All 4 branches missed.">        if ((mode &amp; CALLBACK_LOG) != 0 &amp;&amp; _log.isWarnEnabled())</span>
<span class="nc" id="L905">            _log.warn(ce);</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">        if ((mode &amp; CALLBACK_RETHROW) != 0)</span>
<span class="nc" id="L907">            throw ce;</span>
<span class="nc" id="L908">    }</span>

    @Override
    public void addTransactionListener(Object tl) {
<span class="nc" id="L912">        beginOperation(false);</span>
        try {
<span class="nc" id="L914">            _transEventManager.addListener(tl);</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">            if (tl instanceof RemoteCommitEventManager)</span>
<span class="nc" id="L916">                _flags |= FLAG_REMOTE_LISTENER;</span>
        } finally {
<span class="nc" id="L918">            endOperation();</span>
        }
<span class="nc" id="L920">    }</span>

    @Override
    public void removeTransactionListener(Object tl) {
<span class="nc" id="L924">        beginOperation(false);</span>
        try {
<span class="nc bnc" id="L926" title="All 4 branches missed.">            if (_transEventManager.removeListener(tl)</span>
                &amp;&amp; (tl instanceof RemoteCommitEventManager))
<span class="nc" id="L928">                _flags &amp;= ~FLAG_REMOTE_LISTENER;</span>
        } finally {
<span class="nc" id="L930">            endOperation();</span>
        }
<span class="nc" id="L932">    }</span>

    @Override
    public Collection&lt;Object&gt; getTransactionListeners() {
<span class="nc" id="L936">        return _transEventManager.getListeners();</span>
    }

    @Override
    public int getTransactionListenerCallbackMode() {
<span class="nc" id="L941">        return _transCallbackMode;</span>
    }

    @Override
    public void setTransactionListenerCallbackMode(int mode) {
<span class="nc" id="L946">        beginOperation(false);</span>
        try {
<span class="nc" id="L948">            _transCallbackMode = mode;</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">            _transEventManager.setFailFast((mode &amp; CALLBACK_FAIL_FAST) != 0);</span>
        } finally {
<span class="nc" id="L951">            endOperation();</span>
        }
<span class="nc" id="L953">    }</span>

    /**
     * Fire given transaction event, handling any exceptions appropriately.
     */
    private void fireTransactionEvent(TransactionEvent trans) {
<span class="nc bnc" id="L959" title="All 4 branches missed.">        if (_transEventManager != null &amp;&amp; _transEventManager.hasListeners())</span>
<span class="nc" id="L960">            handleCallbackExceptions(_transEventManager.fireEvent(trans),</span>
                _transCallbackMode);
<span class="nc" id="L962">    }</span>

    /**
     * Set whether this Broker will generate verbose optimistic lock exceptions when batching
     * operations. Defaults to true.
     */
    public void setSuppressBatchOLELogging(boolean b) {
<span class="nc" id="L969">        _suppressBatchOLELogging = b;</span>
<span class="nc" id="L970">    }</span>

    /**
     * Return whether this Broker will generate verbose optimistic lock exceptions when batching
     * operations.
     */
    public boolean getSuppressBatchOLELogging() {
<span class="nc" id="L977">        return _suppressBatchOLELogging;</span>
    }
    ///////////
    // Lookups
    ///////////

    @Override
    public Object find(Object oid, boolean validate, FindCallbacks call) {
<span class="nc" id="L985">        int flags = OID_COPY | OID_ALLOW_NEW | OID_NODELETED;</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">        if (!validate)</span>
<span class="nc" id="L987">            flags |= OID_NOVALIDATE;</span>
<span class="nc" id="L988">        return find(oid, _fc, null, null, flags, call);</span>
    }

    @Override
    public Object find(Object oid, FetchConfiguration fetch, BitSet exclude,
        Object edata, int flags) {
<span class="nc" id="L994">        return find(oid, fetch, exclude, edata, flags, null);</span>
    }

    /**
     * Internal finder.
     */
    protected Object find(Object oid, FetchConfiguration fetch, BitSet exclude,
        Object edata, int flags, FindCallbacks call) {
<span class="nc bnc" id="L1002" title="All 2 branches missed.">        if (call == null)</span>
<span class="nc" id="L1003">            call = this;</span>
<span class="nc" id="L1004">        oid = call.processArgument(oid);</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">        if (oid == null) {</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">            if ((flags &amp; OID_NOVALIDATE) == 0)</span>
<span class="nc" id="L1007">                throw new ObjectNotFoundException(_loc.get(&quot;null-oid&quot;));</span>
<span class="nc" id="L1008">            return call.processReturn(oid, null);</span>
        }
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        if (fetch == null)</span>
<span class="nc" id="L1011">            fetch = _fc;</span>

<span class="nc" id="L1013">        beginOperation(true);</span>
        try {
<span class="nc" id="L1015">            assertNontransactionalRead();</span>

            // cached instance?
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            StateManagerImpl sm = getStateManagerImplById(oid,</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                (flags &amp; OID_ALLOW_NEW) != 0 || hasFlushed());</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">            if (sm != null) {</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">                if (!requiresLoad(sm, true, fetch, edata, flags))</span>
<span class="nc" id="L1022">                    return call.processReturn(oid, sm);</span>

<span class="nc bnc" id="L1024" title="All 2 branches missed.">                if (!sm.isLoading()) {</span>
                    // make sure all the configured fields are loaded; do this
                    // after making instance transactional for locking
<span class="nc bnc" id="L1027" title="All 4 branches missed.">                    if (!sm.isTransactional() &amp;&amp; useTransactionalState(fetch))</span>
<span class="nc" id="L1028">                        sm.transactional();</span>
                    boolean loaded;
                    try {
<span class="nc" id="L1031">                        loaded = sm.load(fetch, StateManagerImpl.LOAD_FGS,</span>
                            exclude, edata, false);
<span class="nc" id="L1033">                    } catch (ObjectNotFoundException onfe) {</span>
<span class="nc bnc" id="L1034" title="All 4 branches missed.">                        if ((flags &amp; OID_NODELETED) != 0</span>
                            || (flags &amp; OID_NOVALIDATE) != 0)
<span class="nc" id="L1036">                            throw onfe;</span>
<span class="nc" id="L1037">                        return call.processReturn(oid, null);</span>
<span class="nc" id="L1038">                    }</span>

                    // if no data needed to be loaded and the user wants to
                    // validate, just make sure the object exists
<span class="nc bnc" id="L1042" title="All 4 branches missed.">                    if (!loaded &amp;&amp; (flags &amp; OID_NOVALIDATE) == 0</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">                        &amp;&amp; _compat.getValidateTrueChecksStore()</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">                        &amp;&amp; !sm.isTransactional()</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                        &amp;&amp; !_store.exists(sm, edata)) {</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">                        if ((flags &amp; OID_NODELETED) == 0)</span>
<span class="nc" id="L1047">                            return call.processReturn(oid, null);</span>
<span class="nc" id="L1048">                        throw new ObjectNotFoundException(_loc.get</span>
<span class="nc" id="L1049">                            (&quot;del-instance&quot;, sm.getManagedInstance(), oid)).</span>
<span class="nc" id="L1050">                            setFailedObject(sm.getManagedInstance());</span>
                    }
                }

                // since the object was cached, we may need to upgrade lock
                // if current level is higher than level of initial load
<span class="nc bnc" id="L1056" title="All 2 branches missed.">                if ((_flags &amp; FLAG_ACTIVE) != 0) {</span>
<span class="nc" id="L1057">                    int level = fetch.getReadLockLevel();</span>
<span class="nc" id="L1058">                    _lm.lock(sm, level, fetch.getLockTimeout(), edata);</span>
<span class="nc" id="L1059">                    sm.readLocked(level, fetch.getWriteLockLevel());</span>
                }
<span class="nc" id="L1061">                return call.processReturn(oid, sm);</span>
            }

            // if there's no cached sm for a new/transient id type, we
            // it definitely doesn't exist
<span class="nc bnc" id="L1066" title="All 2 branches missed.">            if (oid instanceof StateManagerId)</span>
<span class="nc" id="L1067">                return call.processReturn(oid, null);</span>

            // initialize a new state manager for the datastore instance
<span class="nc bnc" id="L1070" title="All 2 branches missed.">            sm = newStateManagerImpl(oid, (flags &amp; OID_COPY) != 0);</span>
<span class="nc" id="L1071">            boolean load = requiresLoad(sm, false, fetch, edata, flags);</span>
<span class="nc" id="L1072">            sm = initialize(sm, load, fetch, edata);</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">            if (sm == null) {</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">                if ((flags &amp; OID_NOVALIDATE) != 0)</span>
<span class="nc" id="L1075">                    throw new ObjectNotFoundException(oid);</span>
<span class="nc" id="L1076">                return call.processReturn(oid, null);</span>
            }

            // make sure all configured fields were loaded
<span class="nc bnc" id="L1080" title="All 2 branches missed.">            if (load) {</span>
                try {
<span class="nc" id="L1082">                    sm.load(fetch, StateManagerImpl.LOAD_FGS, exclude,</span>
                        edata, false);
<span class="nc" id="L1084">                } catch (ObjectNotFoundException onfe) {</span>
<span class="nc bnc" id="L1085" title="All 4 branches missed.">                    if ((flags &amp; OID_NODELETED) != 0</span>
                        || (flags &amp; OID_NOVALIDATE) != 0)
<span class="nc" id="L1087">                        throw onfe;</span>
<span class="nc" id="L1088">                    return call.processReturn(oid, null);</span>
<span class="nc" id="L1089">                }</span>
            }
<span class="nc" id="L1091">            return call.processReturn(oid, sm);</span>
<span class="nc" id="L1092">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L1093">            throw ke;</span>
<span class="nc" id="L1094">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1095">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L1097">            endOperation();</span>
        }
    }

    /**
     * Initialize a newly-constructed state manager.
     */
    protected StateManagerImpl initialize(StateManagerImpl sm, boolean load,
        FetchConfiguration fetch, Object edata) {
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (!load) {</span>
<span class="nc" id="L1107">            sm.initialize(sm.getMetaData().getDescribedType(),</span>
                PCState.HOLLOW);
        } else {
<span class="nc bnc" id="L1110" title="All 2 branches missed.">            PCState state = (useTransactionalState(fetch))</span>
<span class="nc" id="L1111">                ? PCState.PCLEAN : PCState.PNONTRANS;</span>
<span class="nc" id="L1112">            sm.setLoading(true);</span>
            try {
<span class="nc bnc" id="L1114" title="All 2 branches missed.">                if (!_store.initialize(sm, state, fetch, edata))</span>
<span class="nc" id="L1115">                    return null;</span>
            } finally {
<span class="nc" id="L1117">                sm.setLoading(false);</span>
            }
        }
<span class="nc" id="L1120">        return sm;</span>
    }

    @Override
    public Object[] findAll(Collection oids, boolean validate,
        FindCallbacks call) {
<span class="nc" id="L1126">        int flags = OID_COPY | OID_ALLOW_NEW | OID_NODELETED;</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">        if (!validate)</span>
<span class="nc" id="L1128">            flags |= OID_NOVALIDATE;</span>
<span class="nc" id="L1129">        return findAll(oids, _fc, null, null, flags, call);</span>
    }

    @Override
    public Object[] findAll(Collection oids, FetchConfiguration fetch,
        BitSet exclude, Object edata, int flags) {
<span class="nc" id="L1135">        return findAll(oids, fetch, exclude, edata, flags, null);</span>
    }

    /**
     * Internal finder.
     */
    protected Object[] findAll(Collection oids, FetchConfiguration fetch,
        BitSet exclude, Object edata, int flags, FindCallbacks call) {
<span class="nc" id="L1143">        findAllDepth ++;</span>

        // throw any exceptions for null oids up immediately
<span class="nc bnc" id="L1146" title="All 2 branches missed.">        if (oids == null)</span>
<span class="nc" id="L1147">            throw new NullPointerException(&quot;oids == null&quot;);</span>
<span class="nc bnc" id="L1148" title="All 4 branches missed.">        if ((flags &amp; OID_NOVALIDATE) != 0 &amp;&amp; oids.contains(null))</span>
<span class="nc" id="L1149">            throw new UserException(_loc.get(&quot;null-oids&quot;));</span>

        // we have to use a map of oid-&gt;sm rather than a simple
        // array, so that we make sure not to create multiple sms for equivalent
        // oids if the user has duplicates in the given array
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        if (_loading == null)</span>
<span class="nc" id="L1155">            _loading = new HashMap&lt;&gt;((int) (oids.size() * 1.33 + 1));</span>

<span class="nc bnc" id="L1157" title="All 2 branches missed.">        if (call == null)</span>
<span class="nc" id="L1158">            call = this;</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">        if (fetch == null)</span>
<span class="nc" id="L1160">            fetch = _fc;</span>

<span class="nc" id="L1162">        beginOperation(true);</span>
        try {
<span class="nc" id="L1164">            assertNontransactionalRead();</span>

            // collection of state managers to pass to store manager
<span class="nc" id="L1167">            List&lt;OpenJPAStateManager&gt; load = null;</span>
            StateManagerImpl sm;
            boolean initialized;
<span class="nc" id="L1170">            boolean transState = useTransactionalState(fetch);</span>
            Object obj, oid;
<span class="nc" id="L1172">            int idx = 0;</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = oids.iterator(); itr.hasNext(); idx++) {</span>
                // if we've already seen this oid, skip repeats
<span class="nc" id="L1175">                obj = itr.next();</span>
<span class="nc" id="L1176">                oid = call.processArgument(obj);</span>
<span class="nc bnc" id="L1177" title="All 4 branches missed.">                if (oid == null || _loading.containsKey(obj))</span>
<span class="nc" id="L1178">                    continue;</span>

                // if we don't have a cached instance or it is not transactional
                // and is hollow or we need to validate, load it
<span class="nc bnc" id="L1182" title="All 2 branches missed.">                sm = getStateManagerImplById(oid, (flags &amp; OID_ALLOW_NEW) != 0</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">                    || hasFlushed());</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">                initialized = sm != null;</span>
<span class="nc bnc" id="L1185" title="All 2 branches missed.">                if (!initialized)</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">                    sm = newStateManagerImpl(oid, (flags &amp; OID_COPY) != 0);</span>

<span class="nc" id="L1188">                _loading.put(obj, sm);</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">                if (requiresLoad(sm, initialized, fetch, edata, flags)) {</span>
<span class="nc bnc" id="L1190" title="All 4 branches missed.">                    transState = transState || useTransactionalState(fetch);</span>
<span class="nc bnc" id="L1191" title="All 6 branches missed.">                    if (initialized &amp;&amp; !sm.isTransactional() &amp;&amp; transState)</span>
<span class="nc" id="L1192">                        sm.transactional();</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">                    if (load == null)</span>
<span class="nc" id="L1194">                        load = new ArrayList&lt;&gt;(oids.size() - idx);</span>
<span class="nc" id="L1195">                    load.add(sm);</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">                } else if (!initialized)</span>
<span class="nc" id="L1197">                    sm.initialize(sm.getMetaData().getDescribedType(),</span>
                        PCState.HOLLOW);
            }

            // pass all state managers in need of loading or validation to the
            // store manager
<span class="nc bnc" id="L1203" title="All 2 branches missed.">            if (load != null) {</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">                PCState state = (transState) ? PCState.PCLEAN</span>
<span class="nc" id="L1205">                    : PCState.PNONTRANS;</span>
<span class="nc" id="L1206">                Collection&lt;Object&gt; failed = _store.loadAll(load, state,</span>
                    StoreManager.FORCE_LOAD_NONE, fetch, edata);

                // set failed instances to null
<span class="nc bnc" id="L1210" title="All 4 branches missed.">                if (failed != null &amp;&amp; !failed.isEmpty()) {</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">                    if ((flags &amp; OID_NOVALIDATE) != 0)</span>
<span class="nc" id="L1212">                        throw newObjectNotFoundException(failed);</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">                    for (Iterator&lt;Object&gt; itr = failed.iterator(); itr.hasNext();)</span>
<span class="nc" id="L1214">                        _loading.put(itr.next(), null);</span>
                }
            }

            // create results array; make sure all configured fields are
            // loaded in each instance
<span class="nc" id="L1220">            Object[] results = new Object[oids.size()];</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">            boolean active = (_flags &amp; FLAG_ACTIVE) != 0;</span>
<span class="nc" id="L1222">            int level = fetch.getReadLockLevel();</span>
<span class="nc" id="L1223">            idx = 0;</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = oids.iterator(); itr.hasNext(); idx++) {</span>
<span class="nc" id="L1225">                oid = itr.next();</span>
<span class="nc" id="L1226">                sm = _loading.get(oid);</span>
<span class="nc bnc" id="L1227" title="All 4 branches missed.">                if (sm != null &amp;&amp; requiresLoad(sm, true, fetch, edata, flags)) {</span>
                    try {
<span class="nc" id="L1229">                        sm.load(fetch, StateManagerImpl.LOAD_FGS,</span>
                        	exclude, edata, false);
<span class="nc bnc" id="L1231" title="All 2 branches missed.">                        if (active) {</span>
<span class="nc" id="L1232">                            _lm.lock(sm, level, fetch.getLockTimeout(), edata);</span>
<span class="nc" id="L1233">                            sm.readLocked(level, fetch.getWriteLockLevel());</span>
                        }
                    }
<span class="nc" id="L1236">                    catch (ObjectNotFoundException onfe) {</span>
<span class="nc bnc" id="L1237" title="All 4 branches missed.">                        if ((flags &amp; OID_NODELETED) != 0</span>
                            || (flags &amp; OID_NOVALIDATE) != 0)
<span class="nc" id="L1239">                            throw onfe;</span>
<span class="nc" id="L1240">                        sm = null;</span>
<span class="nc" id="L1241">                    }</span>
                }
<span class="nc" id="L1243">                results[idx] = call.processReturn(oid, sm);</span>
            }
<span class="nc" id="L1245">            return results;</span>
<span class="nc" id="L1246">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L1247">            throw ke;</span>
<span class="nc" id="L1248">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1249">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L1251">            findAllDepth--;</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">            if (findAllDepth == 0)</span>
<span class="nc" id="L1253">                _loading = null;</span>
<span class="nc" id="L1254">            endOperation();</span>
        }
    }

    public boolean isLoading(Object o) {
<span class="nc bnc" id="L1259" title="All 2 branches missed.">        if(_loading == null ) {</span>
<span class="nc" id="L1260">            return false;</span>
        }
<span class="nc" id="L1262">        return _loading.containsKey(o);</span>
    }

    private boolean hasFlushed() {
<span class="nc bnc" id="L1266" title="All 2 branches missed.">        return (_flags &amp; FLAG_FLUSHED) != 0;</span>
    }

    /**
     * Return whether the given instance needs loading before being returned
     * to the user.
     */
    private boolean requiresLoad(OpenJPAStateManager sm, boolean initialized,
        FetchConfiguration fetch, Object edata, int flags) {
<span class="nc bnc" id="L1275" title="All 2 branches missed.">        if (!fetch.requiresLoad())</span>
<span class="nc" id="L1276">            return false;</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">        if ((flags &amp; OID_NOVALIDATE) == 0)</span>
<span class="nc" id="L1278">            return true;</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">        if (edata != null) // take advantage of existing result</span>
<span class="nc" id="L1280">            return true;</span>
<span class="nc bnc" id="L1281" title="All 4 branches missed.">        if (initialized &amp;&amp; sm.getPCState() != PCState.HOLLOW)</span>
<span class="nc" id="L1282">            return false;</span>
<span class="nc bnc" id="L1283" title="All 4 branches missed.">        if (!initialized &amp;&amp; sm.getMetaData().getPCSubclasses().length &gt; 0)</span>
<span class="nc" id="L1284">            return true;</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">        return !_compat.getValidateFalseReturnsHollow();</span>
    }

    /**
     * Return whether to use a transactional state.
     */
    private boolean useTransactionalState(FetchConfiguration fetch) {
<span class="nc bnc" id="L1292" title="All 6 branches missed.">        return (_flags &amp; FLAG_ACTIVE) != 0 &amp;&amp; (!_optimistic</span>
            || _autoClear == CLEAR_ALL
<span class="nc bnc" id="L1294" title="All 2 branches missed.">            || fetch.getReadLockLevel() != LOCK_NONE);</span>
    }

    @Override
    public Object findCached(Object oid, FindCallbacks call) {
<span class="nc bnc" id="L1299" title="All 2 branches missed.">        if (call == null)</span>
<span class="nc" id="L1300">            call = this;</span>
<span class="nc" id="L1301">        oid = call.processArgument(oid);</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">        if (oid == null)</span>
<span class="nc" id="L1303">            return call.processReturn(oid, null);</span>

<span class="nc" id="L1305">        beginOperation(true);</span>
        try {
<span class="nc" id="L1307">            StateManagerImpl sm = getStateManagerImplById(oid, true);</span>
<span class="nc" id="L1308">            return call.processReturn(oid, sm);</span>
        } finally {
<span class="nc" id="L1310">            endOperation();</span>
        }
    }

    @Override
    public Class&lt;?&gt; getObjectIdType(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L1316" title="All 2 branches missed.">        if (cls == null)</span>
<span class="nc" id="L1317">            return null;</span>

<span class="nc" id="L1319">        beginOperation(false);</span>
        try {
<span class="nc" id="L1321">            ClassMetaData meta = _repo.getMetaData(cls, _loader, false);</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">            if (meta == null</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">                || meta.getIdentityType() == ClassMetaData.ID_UNKNOWN)</span>
<span class="nc" id="L1324">                return null;</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">            if (meta.getIdentityType() == ClassMetaData.ID_APPLICATION)</span>
<span class="nc" id="L1326">                return meta.getObjectIdType();</span>

<span class="nc" id="L1328">            return _store.getDataStoreIdType(meta);</span>
<span class="nc" id="L1329">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L1330">            throw ke;</span>
<span class="nc" id="L1331">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1332">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L1334">            endOperation();</span>
        }
    }

    @Override
    public Object newObjectId(Class&lt;?&gt; cls, Object val) {
<span class="nc bnc" id="L1340" title="All 2 branches missed.">        if (val == null)</span>
<span class="nc" id="L1341">            return null;</span>

<span class="nc" id="L1343">        beginOperation(false);</span>
        try {
<span class="nc" id="L1345">            ClassMetaData meta = _repo.getMetaData(cls, _loader, true);</span>
<span class="nc bnc" id="L1346" title="All 3 branches missed.">            switch (meta.getIdentityType()) {</span>
            case ClassMetaData.ID_DATASTORE:
                // delegate to store manager for datastore ids
<span class="nc bnc" id="L1349" title="All 2 branches missed.">                if (val instanceof String</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">                    &amp;&amp; ((String) val).startsWith(StateManagerId.STRING_PREFIX))</span>
<span class="nc" id="L1351">                    return new StateManagerId((String) val);</span>
<span class="nc" id="L1352">                return _store.newDataStoreId(val, meta);</span>
            case ClassMetaData.ID_APPLICATION:
<span class="nc bnc" id="L1354" title="All 2 branches missed.">                if (ImplHelper.isAssignable(meta.getObjectIdType(),</span>
<span class="nc" id="L1355">                    val.getClass())) {</span>
<span class="nc bnc" id="L1356" title="All 2 branches missed.">                    if (!meta.isOpenJPAIdentity()</span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">                        &amp;&amp; meta.isObjectIdTypeShared())</span>
<span class="nc" id="L1358">                        return new ObjectId(cls, val);</span>
<span class="nc" id="L1359">                    return val;</span>
                }

                // stringified app id?
<span class="nc bnc" id="L1363" title="All 2 branches missed.">                if (val instanceof String</span>
<span class="nc" id="L1364">                    &amp;&amp; !_conf.getCompatibilityInstance().</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">                        getStrictIdentityValues()</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">                    &amp;&amp; !Modifier.isAbstract(cls.getModifiers()))</span>
<span class="nc" id="L1367">                    return PCRegistry.newObjectId(cls, (String) val);</span>

<span class="nc bnc" id="L1369" title="All 2 branches missed.">                Object[] arr = (val instanceof Object[]) ? (Object[]) val</span>
<span class="nc" id="L1370">                    : new Object[]{ val };</span>
<span class="nc" id="L1371">                return ApplicationIds.fromPKValues(arr, meta);</span>
            default:
<span class="nc" id="L1373">                throw new UserException(_loc.get(&quot;meta-unknownid&quot;, cls));</span>
            }
<span class="nc" id="L1375">        } catch (IllegalArgumentException iae) {</span>
        	// OPENJPA-365
<span class="nc" id="L1377">        	throw new UserException(_loc.get(&quot;bad-id-value&quot;, val,</span>
<span class="nc" id="L1378">                val.getClass().getName(), cls)).setCause(iae);</span>
<span class="nc" id="L1379">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L1380">            throw ke;</span>
<span class="nc" id="L1381">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L1382">            throw new UserException(_loc.get(&quot;bad-id-value&quot;, val,</span>
<span class="nc" id="L1383">                val.getClass().getName(), cls)).setCause(cce);</span>
<span class="nc" id="L1384">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1385">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L1387">            endOperation();</span>
        }
    }

    /**
     * Create a new state manager for the given oid.
     */
    private StateManagerImpl newStateManagerImpl(Object oid, boolean copy) {
        // see if we're in the process of loading this oid in a loadAll call
        StateManagerImpl sm;
<span class="nc bnc" id="L1397" title="All 2 branches missed.">        if (_loading != null) {</span>
<span class="nc" id="L1398">            sm = _loading.get(oid);</span>
<span class="nc bnc" id="L1399" title="All 4 branches missed.">            if (sm != null &amp;&amp; sm.getPersistenceCapable() == null)</span>
<span class="nc" id="L1400">                return sm;</span>
        }

        // find metadata for the oid
<span class="nc" id="L1404">        Class&lt;?&gt; pcType = _store.getManagedType(oid);</span>
        ClassMetaData meta;
<span class="nc bnc" id="L1406" title="All 2 branches missed.">        if (pcType != null)</span>
<span class="nc" id="L1407">            meta = _repo.getMetaData(pcType, _loader, true);</span>
        else
<span class="nc" id="L1409">            meta = _repo.getMetaData(oid, _loader, true);</span>

        // copy the oid if needed
<span class="nc bnc" id="L1412" title="All 4 branches missed.">        if (copy &amp;&amp; _compat.getCopyObjectIds()) {</span>
<span class="nc bnc" id="L1413" title="All 2 branches missed.">            if (meta.getIdentityType() == ClassMetaData.ID_APPLICATION)</span>
<span class="nc" id="L1414">                oid = ApplicationIds.copy(oid, meta);</span>
<span class="nc bnc" id="L1415" title="All 2 branches missed.">            else if (meta.getIdentityType() == ClassMetaData.ID_UNKNOWN)</span>
<span class="nc" id="L1416">                throw new UserException(_loc.get(&quot;meta-unknownid&quot;, meta));</span>
            else
<span class="nc" id="L1418">                oid = _store.copyDataStoreId(oid, meta);</span>
        }

<span class="nc" id="L1421">        sm = newStateManagerImpl(oid, meta);</span>
<span class="nc" id="L1422">        sm.setObjectId(oid);</span>
<span class="nc" id="L1423">        return sm;</span>
    }

    /**
     * Create a state manager for the given oid and metadata.
     */
    protected StateManagerImpl newStateManagerImpl(Object oid,
        ClassMetaData meta) {
<span class="nc" id="L1431">        return new StateManagerImpl(oid, meta, this);</span>
    }

    ///////////////
    // Transaction
    ///////////////

    @Override
    public void begin() {
<span class="nc" id="L1440">        beginOperation(true);</span>
        try {
<span class="nc bnc" id="L1442" title="All 2 branches missed.">            if ((_flags &amp; FLAG_ACTIVE) != 0)</span>
<span class="nc" id="L1443">                throw new InvalidStateException(_loc.get(&quot;active&quot;));</span>
<span class="nc" id="L1444">            _factory.syncWithManagedTransaction(this, true);</span>
<span class="nc" id="L1445">            beginInternal();</span>
        } finally {
<span class="nc" id="L1447">            endOperation();</span>
        }
<span class="nc" id="L1449">    }</span>

    /**
     * Notify the store manager of a transaction.
     */
    private void beginInternal() {
        try {
<span class="nc" id="L1456">            beginStoreManagerTransaction(_optimistic);</span>
<span class="nc" id="L1457">            _flags |= FLAG_ACTIVE;</span>

            // start locking
<span class="nc bnc" id="L1460" title="All 2 branches missed.">            if (!_optimistic) {</span>
<span class="nc" id="L1461">                _fc.setReadLockLevel(_conf.getReadLockLevelConstant());</span>
<span class="nc" id="L1462">                _fc.setWriteLockLevel(_conf.getWriteLockLevelConstant());</span>
<span class="nc" id="L1463">                _fc.setLockTimeout(_conf.getLockTimeout());</span>
            }
<span class="nc" id="L1465">            _lm.beginTransaction();</span>

<span class="nc bnc" id="L1467" title="All 2 branches missed.">            if (_transEventManager.hasBeginListeners())</span>
<span class="nc" id="L1468">                fireTransactionEvent(new TransactionEvent(this,</span>
                    TransactionEvent.AFTER_BEGIN, null, null, null, null));
<span class="nc" id="L1470">        } catch (OpenJPAException ke) {</span>
            // if we already started the transaction, don't let it commit
<span class="nc bnc" id="L1472" title="All 2 branches missed.">            if ((_flags &amp; FLAG_ACTIVE) != 0)</span>
<span class="nc" id="L1473">                setRollbackOnlyInternal(ke);</span>
<span class="nc" id="L1474">            throw ke.setFatal(true);</span>
<span class="nc" id="L1475">        } catch (RuntimeException re) {</span>
            // if we already started the transaction, don't let it commit
<span class="nc bnc" id="L1477" title="All 2 branches missed.">            if ((_flags &amp; FLAG_ACTIVE) != 0)</span>
<span class="nc" id="L1478">                setRollbackOnlyInternal(re);</span>
<span class="nc" id="L1479">            throw new StoreException(re).setFatal(true);</span>
<span class="nc" id="L1480">        }</span>

<span class="nc bnc" id="L1482" title="All 2 branches missed.">        if (_pending != null) {</span>
            StateManagerImpl sm;
<span class="nc bnc" id="L1484" title="All 2 branches missed.">            for (Iterator&lt;StateManagerImpl&gt; it = _pending.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1485">                sm = it.next();</span>
<span class="nc" id="L1486">                sm.transactional();</span>
<span class="nc bnc" id="L1487" title="All 2 branches missed.">                if (sm.isDirty())</span>
<span class="nc" id="L1488">                    setDirty(sm, true);</span>
            }
<span class="nc" id="L1490">            _pending = null;</span>
        }
<span class="nc" id="L1492">    }</span>

    @Override
    public void beginStore() {
<span class="nc" id="L1496">        beginOperation(true);</span>
        try {
<span class="nc" id="L1498">            assertTransactionOperation();</span>
<span class="nc bnc" id="L1499" title="All 2 branches missed.">            if ((_flags &amp; FLAG_STORE_ACTIVE) == 0)</span>
<span class="nc" id="L1500">                beginStoreManagerTransaction(false);</span>
<span class="nc" id="L1501">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L1502">            throw ke;</span>
<span class="nc" id="L1503">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1504">            throw new StoreException(re);</span>
        } finally {
<span class="nc" id="L1506">            endOperation();</span>
        }
<span class="nc" id="L1508">    }</span>

    /**
     * Begin a store manager transaction.
     */
    private void beginStoreManagerTransaction(boolean optimistic) {
<span class="nc bnc" id="L1514" title="All 2 branches missed.">        if (!optimistic) {</span>
<span class="nc" id="L1515">            retainConnection();</span>
<span class="nc" id="L1516">            _store.begin();</span>
<span class="nc" id="L1517">            _flags |= FLAG_STORE_ACTIVE;</span>
        } else {
<span class="nc bnc" id="L1519" title="All 2 branches missed.">            if (_connRetainMode == CONN_RETAIN_TRANS)</span>
<span class="nc" id="L1520">                retainConnection();</span>
<span class="nc" id="L1521">            _store.beginOptimistic();</span>
        }
<span class="nc" id="L1523">    }</span>

    /**
     * End the current store manager transaction. Throws an
     * exception to signal a forced rollback after failed commit, otherwise
     * returns any exception encountered during the end process.
     */
    private RuntimeException endStoreManagerTransaction(boolean rollback) {
<span class="nc" id="L1531">        boolean forcedRollback = false;</span>
<span class="nc" id="L1532">        boolean releaseConn = false;</span>
<span class="nc" id="L1533">        RuntimeException err = null;</span>
        try {
<span class="nc bnc" id="L1535" title="All 2 branches missed.">            if ((_flags &amp; FLAG_STORE_ACTIVE) != 0) {</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">                releaseConn = _connRetainMode != CONN_RETAIN_ALWAYS;</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">                if (rollback)</span>
<span class="nc" id="L1538">                    _store.rollback();</span>
                else {
                    // and notify the query cache.  notify in one batch to reduce synch
<span class="nc" id="L1541">                    QueryCache queryCache = getConfiguration().</span>
<span class="nc" id="L1542">                    getDataCacheManagerInstance().getSystemQueryCache();</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">                    if (queryCache != null) {</span>
<span class="nc" id="L1544">                        Collection&lt;Class&lt;?&gt;&gt; pers = getPersistedTypes();</span>
<span class="nc" id="L1545">                        Collection&lt;Class&lt;?&gt;&gt; del = getDeletedTypes();</span>
<span class="nc" id="L1546">                        Collection&lt;Class&lt;?&gt;&gt; up = getUpdatedTypes();</span>
<span class="nc" id="L1547">                        int size = pers.size() + del.size() + up.size();</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">                        if (size &gt; 0) {</span>
<span class="nc" id="L1549">                            Collection&lt;Class&lt;?&gt;&gt; types = new ArrayList&lt;&gt;(size);</span>
<span class="nc" id="L1550">                            types.addAll(pers);</span>
<span class="nc" id="L1551">                            types.addAll(del);</span>
<span class="nc" id="L1552">                            types.addAll(up);</span>
<span class="nc" id="L1553">                            queryCache.onTypesChanged(new TypesChangedEvent(this, types));</span>
                        }
                    }
<span class="nc" id="L1556">                    _store.commit();</span>
<span class="nc" id="L1557">                }</span>
            } else {
<span class="nc bnc" id="L1559" title="All 2 branches missed.">                releaseConn = _connRetainMode == CONN_RETAIN_TRANS;</span>
<span class="nc" id="L1560">                _store.rollbackOptimistic();</span>
            }
        }
<span class="nc" id="L1563">        catch (RuntimeException re) {</span>
<span class="nc bnc" id="L1564" title="All 2 branches missed.">            if (!rollback) {</span>
<span class="nc" id="L1565">                forcedRollback = true;</span>
<span class="nc" id="L1566">                try { _store.rollback(); } catch (RuntimeException re2) {}</span>
            }
<span class="nc" id="L1568">            err = re;</span>
        } finally {
<span class="nc" id="L1570">            _flags &amp;= ~FLAG_STORE_ACTIVE;</span>
        }

<span class="nc bnc" id="L1573" title="All 2 branches missed.">        if (releaseConn) {</span>
            try {
<span class="nc" id="L1575">                releaseConnection();</span>
<span class="nc" id="L1576">            } catch (RuntimeException re) {</span>
<span class="nc bnc" id="L1577" title="All 2 branches missed.">                if (err == null)</span>
<span class="nc" id="L1578">                    err = re;</span>
<span class="nc" id="L1579">            }</span>
        }

<span class="nc bnc" id="L1582" title="All 2 branches missed.">        if (forcedRollback)</span>
<span class="nc" id="L1583">            throw err;</span>
<span class="nc" id="L1584">        return err;</span>
    }

    @Override
    public void commit() {
<span class="nc" id="L1589">        beginOperation(false);</span>
        try {
<span class="nc" id="L1591">            assertTransactionOperation();</span>

<span class="nc" id="L1593">            javax.transaction.Transaction trans =</span>
<span class="nc" id="L1594">                _runtime.getTransactionManager().getTransaction();</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">            if (trans == null)</span>
<span class="nc" id="L1596">                throw new InvalidStateException(_loc.get(&quot;null-trans&quot;));</span>

            // this commit on the transaction will cause our
            // beforeCompletion method to be invoked
<span class="nc" id="L1600">            trans.commit();</span>
<span class="nc" id="L1601">        } catch (OpenJPAException ke) {</span>
<span class="nc bnc" id="L1602" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L1603">                _log.trace(_loc.get(&quot;end-trans-error&quot;), ke);</span>
<span class="nc" id="L1604">            throw ke;</span>
<span class="nc" id="L1605">        } catch (Exception e) {</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L1607">                _log.trace(_loc.get(&quot;end-trans-error&quot;), e);</span>
<span class="nc" id="L1608">            throw new StoreException(e);</span>
        } finally {
<span class="nc" id="L1610">            endOperation();</span>
        }
<span class="nc" id="L1612">    }</span>

    @Override
    public void rollback() {
<span class="nc" id="L1616">        beginOperation(false);</span>
        try {
<span class="nc" id="L1618">            assertTransactionOperation();</span>

<span class="nc" id="L1620">            javax.transaction.Transaction trans =</span>
<span class="nc" id="L1621">                _runtime.getTransactionManager().getTransaction();</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">            if (trans != null)</span>
<span class="nc" id="L1623">                trans.rollback();</span>
<span class="nc" id="L1624">        } catch (OpenJPAException ke) {</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L1626">                _log.trace(_loc.get(&quot;end-trans-error&quot;), ke);</span>
<span class="nc" id="L1627">            throw ke;</span>
<span class="nc" id="L1628">        } catch (Exception e) {</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L1630">                _log.trace(_loc.get(&quot;end-trans-error&quot;), e);</span>
<span class="nc" id="L1631">            throw new StoreException(e);</span>
        } finally {
<span class="nc" id="L1633">            endOperation();</span>
        }
<span class="nc" id="L1635">    }</span>

    @Override
    public boolean syncWithManagedTransaction() {
<span class="nc" id="L1639">        assertOpen();</span>
<span class="nc" id="L1640">        lock();</span>
        try {
<span class="nc bnc" id="L1642" title="All 2 branches missed.">            if ((_flags &amp; FLAG_ACTIVE) != 0)</span>
<span class="nc" id="L1643">                return true;</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">            if (!_managed)</span>
<span class="nc" id="L1645">                throw new InvalidStateException(_loc.get(&quot;trans-not-managed&quot;));</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">            if (_factory.syncWithManagedTransaction(this, false)) {</span>
<span class="nc" id="L1647">                beginInternal();</span>
<span class="nc" id="L1648">                return true;</span>
            }
<span class="nc" id="L1650">            return false;</span>
        } finally {
<span class="nc" id="L1652">            unlock();</span>
        }
    }

    @Override
    public void commitAndResume() {
<span class="nc" id="L1658">        endAndResume(true);</span>
<span class="nc" id="L1659">    }</span>

    @Override
    public void rollbackAndResume() {
<span class="nc" id="L1663">        endAndResume(false);</span>
<span class="nc" id="L1664">    }</span>

    private void endAndResume(boolean commit) {
<span class="nc" id="L1667">        beginOperation(false);</span>
        try {
<span class="nc bnc" id="L1669" title="All 2 branches missed.">            if (commit)</span>
<span class="nc" id="L1670">                commit();</span>
            else
<span class="nc" id="L1672">                rollback();</span>
<span class="nc" id="L1673">            begin();</span>
        } finally {
<span class="nc" id="L1675">            endOperation();</span>
        }
<span class="nc" id="L1677">    }</span>

    @Override
    public boolean getRollbackOnly() {
<span class="nc" id="L1681">        beginOperation(true);</span>
        try {
<span class="nc bnc" id="L1683" title="All 2 branches missed.">            if ((_flags &amp; FLAG_ACTIVE) == 0)</span>
<span class="nc" id="L1684">                return false;</span>

<span class="nc" id="L1686">            javax.transaction.Transaction trans =</span>
<span class="nc" id="L1687">                _runtime.getTransactionManager().getTransaction();</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">            if (trans == null)</span>
<span class="nc" id="L1689">                return false;</span>
<span class="nc bnc" id="L1690" title="All 2 branches missed.">            return trans.getStatus() == Status.STATUS_MARKED_ROLLBACK;</span>
<span class="nc" id="L1691">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L1692">            throw ke;</span>
<span class="nc" id="L1693">        } catch (Exception e) {</span>
<span class="nc" id="L1694">            throw new GeneralException(e);</span>
        } finally {
<span class="nc" id="L1696">            endOperation();</span>
        }
    }

    @Override
    public Throwable getRollbackCause() {
<span class="nc" id="L1702">        beginOperation(true);</span>
        try {
<span class="nc bnc" id="L1704" title="All 2 branches missed.">            if ((_flags &amp; FLAG_ACTIVE) == 0)</span>
<span class="nc" id="L1705">                return null;</span>

<span class="nc" id="L1707">            javax.transaction.Transaction trans =</span>
<span class="nc" id="L1708">                _runtime.getTransactionManager().getTransaction();</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">            if (trans == null)</span>
<span class="nc" id="L1710">                return null;</span>
<span class="nc bnc" id="L1711" title="All 2 branches missed.">            if (trans.getStatus() == Status.STATUS_MARKED_ROLLBACK)</span>
<span class="nc" id="L1712">                return _runtime.getRollbackCause();</span>

<span class="nc" id="L1714">            return null;</span>
<span class="nc" id="L1715">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L1716">            throw ke;</span>
<span class="nc" id="L1717">        } catch (Exception e) {</span>
<span class="nc" id="L1718">            throw new GeneralException(e);</span>
        } finally {
<span class="nc" id="L1720">            endOperation();</span>
        }
    }

    @Override
    public void setRollbackOnly() {
<span class="nc" id="L1726">        setRollbackOnly(new UserException());</span>
<span class="nc" id="L1727">    }</span>

    @Override
    public void setRollbackOnly(Throwable cause) {
<span class="nc" id="L1731">        beginOperation(true);</span>
        try {
<span class="nc" id="L1733">            assertTransactionOperation();</span>
<span class="nc" id="L1734">            setRollbackOnlyInternal(cause);</span>
        } finally {
<span class="nc" id="L1736">            endOperation();</span>
        }
<span class="nc" id="L1738">    }</span>

    /**
     * Mark the current transaction as rollback-only.
     */
    private void setRollbackOnlyInternal(Throwable cause) {
        try {
<span class="nc" id="L1745">            javax.transaction.Transaction trans =</span>
<span class="nc" id="L1746">                _runtime.getTransactionManager().getTransaction();</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">            if (trans == null)</span>
<span class="nc" id="L1748">                throw new InvalidStateException(_loc.get(&quot;null-trans&quot;));</span>
            // ensure tran is in a valid state to accept the setRollbackOnly
<span class="nc" id="L1750">            int tranStatus = trans.getStatus();</span>
<span class="nc bnc" id="L1751" title="All 6 branches missed.">            if ((tranStatus != Status.STATUS_NO_TRANSACTION)</span>
                    &amp;&amp; (tranStatus != Status.STATUS_ROLLEDBACK)
                    &amp;&amp; (tranStatus != Status.STATUS_COMMITTED))
<span class="nc" id="L1754">                _runtime.setRollbackOnly(cause);</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">            else if (_log.isTraceEnabled())</span>
<span class="nc" id="L1756">                _log.trace(_loc.get(&quot;invalid-tran-status&quot;, Integer.valueOf(</span>
                        tranStatus), &quot;setRollbackOnly&quot;));
<span class="nc" id="L1758">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L1759">            throw ke;</span>
<span class="nc" id="L1760">        } catch (Exception e) {</span>
<span class="nc" id="L1761">            throw new GeneralException(e);</span>
<span class="nc" id="L1762">        }</span>
<span class="nc" id="L1763">    }</span>

    @Override
    public void setSavepoint(String name) {
<span class="nc" id="L1767">        beginOperation(true);</span>
        try {
<span class="nc" id="L1769">            assertActiveTransaction();</span>
<span class="nc bnc" id="L1770" title="All 4 branches missed.">            if (_savepoints != null &amp;&amp; _savepoints.containsKey(name))</span>
<span class="nc" id="L1771">                throw new UserException(_loc.get(&quot;savepoint-exists&quot;, name));</span>

<span class="nc bnc" id="L1773" title="All 4 branches missed.">            if (hasFlushed() &amp;&amp; !_spm.supportsIncrementalFlush())</span>
<span class="nc" id="L1774">                throw new UnsupportedException(_loc.get</span>
<span class="nc" id="L1775">                    (&quot;savepoint-flush-not-supported&quot;));</span>

<span class="nc" id="L1777">            OpenJPASavepoint save = _spm.newSavepoint(name, this);</span>
<span class="nc bnc" id="L1778" title="All 4 branches missed.">            if (_savepoints == null || _savepoints.isEmpty()) {</span>
<span class="nc" id="L1779">                save.save(getTransactionalStates());</span>
<span class="nc" id="L1780">                _savepoints = new LinkedMap();</span>
            } else {
<span class="nc bnc" id="L1782" title="All 2 branches missed.">                if (_savepointCache == null)</span>
<span class="nc" id="L1783">                    save.save(Collections.EMPTY_SET);</span>
                else {
<span class="nc" id="L1785">                    save.save(_savepointCache);</span>
<span class="nc" id="L1786">                    _savepointCache.clear();</span>
                }
            }
<span class="nc" id="L1789">            _savepoints.put(name, save);</span>
<span class="nc" id="L1790">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L1791">            throw ke;</span>
<span class="nc" id="L1792">        } catch (Exception e) {</span>
<span class="nc" id="L1793">            throw new GeneralException(e);</span>
        } finally {
<span class="nc" id="L1795">            endOperation();</span>
        }
<span class="nc" id="L1797">    }</span>

    @Override
    public void releaseSavepoint() {
<span class="nc" id="L1801">        beginOperation(false);</span>
        try {
<span class="nc bnc" id="L1803" title="All 4 branches missed.">            if (_savepoints == null || _savepoints.isEmpty())</span>
<span class="nc" id="L1804">                throw new UserException(_loc.get(&quot;no-lastsavepoint&quot;));</span>
<span class="nc" id="L1805">            releaseSavepoint((String) _savepoints.get</span>
<span class="nc" id="L1806">                (_savepoints.size() - 1));</span>
        } finally {
<span class="nc" id="L1808">            endOperation();</span>
        }
<span class="nc" id="L1810">    }</span>

    @Override
    public void releaseSavepoint(String savepoint) {
<span class="nc" id="L1814">        beginOperation(false);</span>
        try {
<span class="nc" id="L1816">            assertActiveTransaction();</span>

<span class="nc bnc" id="L1818" title="All 2 branches missed.">            int index = (_savepoints == null) ? -1</span>
<span class="nc" id="L1819">                : _savepoints.indexOf(savepoint);</span>
<span class="nc bnc" id="L1820" title="All 2 branches missed.">            if (index &lt; 0)</span>
<span class="nc" id="L1821">                throw new UserException(_loc.get(&quot;no-savepoint&quot;, savepoint));</span>

            // clear old in reverse
            OpenJPASavepoint save;
<span class="nc bnc" id="L1825" title="All 2 branches missed.">            while (_savepoints.size() &gt; index + 1) {</span>
<span class="nc" id="L1826">                save = (OpenJPASavepoint) _savepoints.remove</span>
<span class="nc" id="L1827">                    (_savepoints.size() - 1);</span>
<span class="nc" id="L1828">                save.release(false);</span>
            }

<span class="nc" id="L1831">            save = (OpenJPASavepoint) _savepoints.remove(index);</span>
<span class="nc" id="L1832">            save.release(true);</span>
<span class="nc bnc" id="L1833" title="All 2 branches missed.">            if (_savepointCache != null)</span>
<span class="nc" id="L1834">                _savepointCache.clear();</span>
<span class="nc" id="L1835">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L1836">            throw ke;</span>
<span class="nc" id="L1837">        } catch (Exception e) {</span>
<span class="nc" id="L1838">            throw new GeneralException(e);</span>
        } finally {
<span class="nc" id="L1840">            endOperation();</span>
        }
<span class="nc" id="L1842">    }</span>

    @Override
    public void rollbackToSavepoint() {
<span class="nc" id="L1846">        beginOperation(false);</span>
        try {
<span class="nc bnc" id="L1848" title="All 4 branches missed.">            if (_savepoints == null || _savepoints.isEmpty())</span>
<span class="nc" id="L1849">                throw new UserException(_loc.get(&quot;no-lastsavepoint&quot;));</span>
<span class="nc" id="L1850">            rollbackToSavepoint((String) _savepoints.get</span>
<span class="nc" id="L1851">                (_savepoints.size() - 1));</span>
        } finally {
<span class="nc" id="L1853">            endOperation();</span>
        }
<span class="nc" id="L1855">    }</span>

    @Override
    public void rollbackToSavepoint(String savepoint) {
<span class="nc" id="L1859">        beginOperation(false);</span>
        try {
<span class="nc" id="L1861">            assertActiveTransaction();</span>

<span class="nc bnc" id="L1863" title="All 2 branches missed.">            int index = (_savepoints == null) ? -1</span>
<span class="nc" id="L1864">                : _savepoints.indexOf(savepoint);</span>
<span class="nc bnc" id="L1865" title="All 2 branches missed.">            if (index &lt; 0)</span>
<span class="nc" id="L1866">                throw new UserException(_loc.get(&quot;no-savepoint&quot;, savepoint));</span>

            // clear old in reverse
            OpenJPASavepoint save;
<span class="nc bnc" id="L1870" title="All 2 branches missed.">            while (_savepoints.size() &gt; index + 1) {</span>
<span class="nc" id="L1871">                save = (OpenJPASavepoint) _savepoints.remove</span>
<span class="nc" id="L1872">                    (_savepoints.size() - 1);</span>
<span class="nc" id="L1873">                save.release(false);</span>
            }

<span class="nc" id="L1876">            save = (OpenJPASavepoint) _savepoints.remove(index);</span>
<span class="nc" id="L1877">            Collection saved = save.rollback(_savepoints.values());</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">            if (_savepointCache != null)</span>
<span class="nc" id="L1879">                _savepointCache.clear();</span>
<span class="nc bnc" id="L1880" title="All 2 branches missed.">            if (hasTransactionalObjects()) {</span>
                // build up a new collection of states
<span class="nc" id="L1882">                TransactionalCache oldTransCache = _transCache;</span>
<span class="nc" id="L1883">                TransactionalCache newTransCache = new TransactionalCache</span>
                    (_orderDirty);
<span class="nc" id="L1885">                _transCache = null;</span>

                // currently there is the assumption that incremental
                // flush is either a) not allowed, or b) required
                // pre-savepoint.  this solves a number of issues including
                // storing flushed states as well as OID handling.
                // if future plugins do not follow this, we need to cache
                // more info per state
                SavepointFieldManager fm;
                StateManagerImpl sm;
<span class="nc bnc" id="L1895" title="All 2 branches missed.">                for (Iterator&lt;?&gt; itr = saved.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L1896">                    fm = (SavepointFieldManager) itr.next();</span>
<span class="nc" id="L1897">                    sm = fm.getStateManager();</span>
<span class="nc" id="L1898">                    sm.rollbackToSavepoint(fm);</span>
<span class="nc" id="L1899">                    oldTransCache.remove(sm);</span>
<span class="nc bnc" id="L1900" title="All 2 branches missed.">                    if (sm.isDirty())</span>
<span class="nc" id="L1901">                        newTransCache.addDirty(sm);</span>
                    else
<span class="nc" id="L1903">                        newTransCache.addClean(sm);</span>
                }
<span class="nc bnc" id="L1905" title="All 2 branches missed.">                for (Iterator&lt;?&gt; itr = oldTransCache.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L1906">                    sm = (StateManagerImpl) itr.next();</span>
<span class="nc" id="L1907">                    sm.rollback();</span>
<span class="nc" id="L1908">                    removeFromTransaction(sm);</span>
                }
<span class="nc" id="L1910">                _transCache = newTransCache;</span>
            }
        }
<span class="nc" id="L1913">        catch (OpenJPAException ke) {</span>
<span class="nc" id="L1914">            throw ke;</span>
<span class="nc" id="L1915">        } catch (Exception e) {</span>
<span class="nc" id="L1916">            throw new GeneralException(e);</span>
        } finally {
<span class="nc" id="L1918">            endOperation();</span>
        }
<span class="nc" id="L1920">    }</span>

    /**
     * Sets the given flag to the status.
     *
     * @since 2.3.0
     */
    protected void setStatusFlag(int flag) {
<span class="nc" id="L1928">    	_flags |= flag;</span>
<span class="nc" id="L1929">    }</span>

    /**
     * Clears the given flag from the status.
     *
     * @since 2.3.0
     */
    protected void clearStatusFlag(int flag) {
<span class="nc" id="L1937">    	_flags &amp;= ~flag;</span>
<span class="nc" id="L1938">    }</span>


    @Override
    public void flush() {
<span class="nc" id="L1943">        beginOperation(true);</span>
        try {
            // return silently if no trans is active, or if this is a reentrant
            // call, which can happen if the store manager tries to get an
            // auto-inc oid during flush
<span class="nc bnc" id="L1948" title="All 4 branches missed.">            if ((_flags &amp; FLAG_ACTIVE) == 0</span>
                || (_flags &amp; FLAG_STORE_FLUSHING) != 0)
<span class="nc" id="L1950">                return;</span>

            // make sure the runtime supports it
<span class="nc bnc" id="L1953" title="All 2 branches missed.">            if (!_conf.supportedOptions().contains(OpenJPAConfiguration.OPTION_INC_FLUSH))</span>
<span class="nc" id="L1954">                throw new UnsupportedException(_loc.get</span>
<span class="nc" id="L1955">                    (&quot;incremental-flush-not-supported&quot;));</span>
<span class="nc bnc" id="L1956" title="All 4 branches missed.">            if (_savepoints != null &amp;&amp; !_savepoints.isEmpty()</span>
<span class="nc bnc" id="L1957" title="All 2 branches missed.">                &amp;&amp; !_spm.supportsIncrementalFlush())</span>
<span class="nc" id="L1958">                throw new UnsupportedException(_loc.get</span>
<span class="nc" id="L1959">                    (&quot;savepoint-flush-not-supported&quot;));</span>

            try {
<span class="nc" id="L1962">                flushSafe(FLUSH_INC);</span>
<span class="nc" id="L1963">                _flags |= FLAG_FLUSHED;</span>
<span class="nc" id="L1964">            } catch (OpenJPAException ke) {</span>
                // rollback on flush error; objects may be in inconsistent state
<span class="nc" id="L1966">                setRollbackOnly(ke);</span>
<span class="nc" id="L1967">                throw ke.setFatal(true);</span>
<span class="nc" id="L1968">            } catch (RuntimeException re) {</span>
                // rollback on flush error; objects may be in inconsistent state
<span class="nc" id="L1970">                setRollbackOnly(re);</span>
<span class="nc" id="L1971">                throw new StoreException(re).setFatal(true);</span>
<span class="nc" id="L1972">            }</span>
        }
        finally {
<span class="nc" id="L1975">            endOperation();</span>
        }
<span class="nc" id="L1977">    }</span>

    @Override
    public void preFlush() {
<span class="nc" id="L1981">        beginOperation(true);</span>
        try {
<span class="nc bnc" id="L1983" title="All 2 branches missed.">            if ((_flags &amp; FLAG_ACTIVE) != 0)</span>
<span class="nc" id="L1984">                flushSafe(FLUSH_LOGICAL);</span>
        } finally {
<span class="nc" id="L1986">            endOperation();</span>
        }
<span class="nc" id="L1988">    }</span>

    @Override
    public void validateChanges() {
<span class="nc" id="L1992">        beginOperation(true);</span>
        try {
            // if no trans, just return; if active datastore trans, flush
<span class="nc bnc" id="L1995" title="All 2 branches missed.">            if ((_flags &amp; FLAG_ACTIVE) == 0)</span>
<span class="nc" id="L1996">                return;</span>
<span class="nc bnc" id="L1997" title="All 2 branches missed.">            if ((_flags &amp; FLAG_STORE_ACTIVE) != 0) {</span>
<span class="nc" id="L1998">                flush();</span>
<span class="nc" id="L1999">                return;</span>
            }

            // make sure the runtime supports inc flush
<span class="nc bnc" id="L2003" title="All 2 branches missed.">            if (!_conf.supportedOptions().contains(OpenJPAConfiguration.OPTION_INC_FLUSH))</span>
<span class="nc" id="L2004">                throw new UnsupportedException(_loc.get</span>
<span class="nc" id="L2005">                    (&quot;incremental-flush-not-supported&quot;));</span>

            try {
<span class="nc" id="L2008">                flushSafe(FLUSH_ROLLBACK);</span>
<span class="nc" id="L2009">            } catch (OpenJPAException ke) {</span>
<span class="nc" id="L2010">                throw ke;</span>
<span class="nc" id="L2011">            } catch (RuntimeException re) {</span>
<span class="nc" id="L2012">                throw new StoreException(re);</span>
<span class="nc" id="L2013">            }</span>
        }
        finally {
<span class="nc" id="L2016">            endOperation();</span>
        }
<span class="nc" id="L2018">    }</span>

    @Override
    public boolean isActive() {
<span class="nc" id="L2022">        beginOperation(true);</span>
        try {
<span class="nc bnc" id="L2024" title="All 2 branches missed.">            return (_flags &amp; FLAG_ACTIVE) != 0;</span>
        } finally {
<span class="nc" id="L2026">            endOperation();</span>
        }
    }

    @Override
    public boolean isStoreActive() {
        // we need to lock here, because we might be in the middle of an
        // atomic transaction process (e.g., commitAndResume)
<span class="nc" id="L2034">        beginOperation(true);</span>
        try {
<span class="nc bnc" id="L2036" title="All 2 branches missed.">            return (_flags &amp; FLAG_STORE_ACTIVE) != 0;</span>
        } finally {
<span class="nc" id="L2038">            endOperation();</span>
        }
    }

    /**
     * Return whether the current transaction is ending, i.e. in the 2nd phase
     * of a commit or rollback
     */
    boolean isTransactionEnding() {
<span class="nc bnc" id="L2047" title="All 2 branches missed.">        return (_flags &amp; FLAG_TRANS_ENDING) != 0;</span>
    }

    @Override
    public boolean beginOperation(boolean syncTrans) {
<span class="nc" id="L2052">        lock();</span>
        try {
<span class="nc" id="L2054">            assertOpen();</span>

<span class="nc bnc" id="L2056" title="All 8 branches missed.">            if (syncTrans &amp;&amp; _operationCount == 0 &amp;&amp; _syncManaged</span>
                &amp;&amp; (_flags &amp; FLAG_ACTIVE) == 0)
<span class="nc" id="L2058">                syncWithManagedTransaction();</span>
<span class="nc bnc" id="L2059" title="All 2 branches missed.">            return _operationCount++ == 1;</span>
<span class="nc" id="L2060">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L2061">            unlock();</span>
<span class="nc" id="L2062">            throw ke;</span>
<span class="nc" id="L2063">        } catch (RuntimeException re) {</span>
<span class="nc" id="L2064">            unlock();</span>
<span class="nc" id="L2065">            throw new GeneralException(re);</span>
        }
    }

    /**
     * Mark the operation over. If outermost caller of stack, returns true
     * and will detach managed instances if necessary.
     */
    @Override
    public boolean endOperation() {
        try {
<span class="nc bnc" id="L2076" title="All 6 branches missed.">            if (_operationCount == 1 &amp;&amp; (_autoDetach &amp; DETACH_NONTXREAD) != 0</span>
                &amp;&amp; (_flags &amp; FLAG_ACTIVE) == 0) {
<span class="nc" id="L2078">                detachAllInternal(null);</span>
            }
<span class="nc bnc" id="L2080" title="All 2 branches missed.">            if (_operationCount &lt; 1)</span>
<span class="nc" id="L2081">                throw new InternalException(_loc.get(&quot;multi-threaded-access&quot;));</span>
<span class="nc bnc" id="L2082" title="All 2 branches missed.">            return _operationCount == 1;</span>
<span class="nc" id="L2083">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L2084">            throw ke;</span>
<span class="nc" id="L2085">        } catch (RuntimeException re) {</span>
<span class="nc" id="L2086">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L2088">            _operationCount--;</span>
<span class="nc bnc" id="L2089" title="All 2 branches missed.">            if (_operationCount == 0)</span>
<span class="nc" id="L2090">                initializeOperatingSet();</span>
<span class="nc" id="L2091">            unlock();</span>
        }
    }

    public Synchronization getSynchronization() {
<span class="nc" id="L2096">        return _sync;</span>
    }

    public void setSynchronization(Synchronization sync) {
<span class="nc" id="L2100">        assertOpen();</span>
<span class="nc" id="L2101">        _sync = sync;</span>
<span class="nc" id="L2102">    }</span>

    ///////////////////////////////////////////////
    // Implementation of Synchronization interface
    ///////////////////////////////////////////////

    @Override
    public void beforeCompletion() {
<span class="nc" id="L2110">        beginOperation(false);</span>
        try {
            // user-supplied synchronization
<span class="nc bnc" id="L2113" title="All 2 branches missed.">            if (_sync != null)</span>
<span class="nc" id="L2114">                _sync.beforeCompletion();</span>

<span class="nc" id="L2116">            flushSafe(FLUSH_COMMIT);</span>
<span class="nc" id="L2117">        } catch (OpenJPAException ke) {</span>
<span class="nc bnc" id="L2118" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L2119">                _log.trace(_loc.get(&quot;end-trans-error&quot;), ke);</span>
<span class="nc" id="L2120">            throw translateManagedCompletionException(ke);</span>
<span class="nc" id="L2121">        } catch (RuntimeException re) {</span>
<span class="nc bnc" id="L2122" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L2123">                _log.trace(_loc.get(&quot;end-trans-error&quot;), re);</span>
<span class="nc" id="L2124">            throw translateManagedCompletionException(new StoreException(re));</span>
        } finally {
<span class="nc" id="L2126">            endOperation();</span>
        }
<span class="nc" id="L2128">    }</span>

    @Override
    public void afterCompletion(int status) {
<span class="nc" id="L2132">        beginOperation(false);</span>
        try {
<span class="nc" id="L2134">            assertActiveTransaction();</span>

<span class="nc" id="L2136">            _flags |= FLAG_TRANS_ENDING;</span>
<span class="nc" id="L2137">            endTransaction(status);</span>
<span class="nc bnc" id="L2138" title="All 2 branches missed.">            if (_sync != null)</span>
<span class="nc" id="L2139">                _sync.afterCompletion(status);</span>

<span class="nc bnc" id="L2141" title="All 2 branches missed.">            if ((_autoDetach &amp; DETACH_COMMIT) != 0)</span>
<span class="nc" id="L2142">                detachAllInternal(null);</span>
<span class="nc bnc" id="L2143" title="All 4 branches missed.">            else if (status == Status.STATUS_ROLLEDBACK</span>
                &amp;&amp; (_autoDetach &amp; DETACH_ROLLBACK) != 0) {
<span class="nc" id="L2145">                detachAllInternal(null);</span>
            }

            // in an ee context, it's possible that the user tried to close
            // us but we didn't actually close because we were waiting on this
            // transaction; if that's true, then close now
<span class="nc bnc" id="L2151" title="All 2 branches missed.">            if ((_flags &amp; FLAG_CLOSE_INVOKED) != 0</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">                &amp;&amp; _compat.getCloseOnManagedCommit())</span>
<span class="nc" id="L2153">                free();</span>
<span class="nc" id="L2154">        } catch (OpenJPAException ke) {</span>
<span class="nc bnc" id="L2155" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L2156">                _log.trace(_loc.get(&quot;end-trans-error&quot;), ke);</span>
<span class="nc" id="L2157">            throw translateManagedCompletionException(ke);</span>
<span class="nc" id="L2158">        } catch (RuntimeException re) {</span>
<span class="nc bnc" id="L2159" title="All 2 branches missed.">            if (_log.isTraceEnabled())</span>
<span class="nc" id="L2160">                _log.trace(_loc.get(&quot;end-trans-error&quot;), re);</span>
<span class="nc" id="L2161">            throw translateManagedCompletionException(new StoreException(re));</span>
        } finally {
<span class="nc" id="L2163">            _flags &amp;= ~FLAG_ACTIVE;</span>
<span class="nc" id="L2164">            _flags &amp;= ~FLAG_FLUSHED;</span>
<span class="nc" id="L2165">            _flags &amp;= ~FLAG_TRANS_ENDING;</span>

            // event manager nulled if freed broker
<span class="nc bnc" id="L2168" title="All 2 branches missed.">            if (_transEventManager != null</span>
<span class="nc bnc" id="L2169" title="All 2 branches missed.">                &amp;&amp; _transEventManager.hasEndListeners()) {</span>
<span class="nc" id="L2170">                fireTransactionEvent(new TransactionEvent(this,</span>
<span class="nc bnc" id="L2171" title="All 2 branches missed.">                    status == Status.STATUS_COMMITTED</span>
<span class="nc" id="L2172">                        ? TransactionEvent.AFTER_COMMIT_COMPLETE</span>
<span class="nc" id="L2173">                        : TransactionEvent.AFTER_ROLLBACK_COMPLETE,</span>
                    null, null, null, null));
            }

<span class="nc" id="L2177">            endOperation();</span>
        }
<span class="nc" id="L2179">    }</span>

    /**
     * If we're in a managed transaction, use our implicit behavior exception
     * translator to translate before/afterCompletion callback errors.
     */
    private RuntimeException translateManagedCompletionException
        (RuntimeException re) {
<span class="nc bnc" id="L2187" title="All 4 branches missed.">        return (!_managed || _extrans == null) ? re : _extrans.translate(re);</span>
    }

    /**
     * Flush safely, catching reentrant calls.
     */
    private void flushSafe(int reason) {
<span class="nc bnc" id="L2194" title="All 2 branches missed.">        if ((_flags &amp; FLAG_FLUSHING) != 0)</span>
<span class="nc" id="L2195">            throw new InvalidStateException(_loc.get(&quot;reentrant-flush&quot;));</span>

<span class="nc" id="L2197">        _flags |= FLAG_FLUSHING;</span>
        try {
<span class="nc" id="L2199">            flush(reason);</span>
        } finally {
<span class="nc" id="L2201">            _flags &amp;= ~FLAG_FLUSHING;</span>
        }
<span class="nc" id="L2203">    }</span>

    /**
     * Flush the transactional state to the data store. Subclasses that
     * customize commit behavior should override this method. The method
     * assumes that the persistence manager is locked, is not closed,
     * and has an active transaction.
     *
     * @param reason one of {@link #FLUSH_INC}, {@link #FLUSH_COMMIT},
     * {@link #FLUSH_ROLLBACK}, or {@link #FLUSH_LOGICAL}
     * @since 0.2.5
     */
    protected void flush(int reason) {
        // this will enlist proxied states as necessary so we know whether we
        // have anything to flush
<span class="nc" id="L2218">        Collection transactional = getTransactionalStates();</span>

        // do we actually have to flush?  only if our flags say so, or if
        // we have transaction listeners that need to be invoked for commit
        // (no need to invoke them on inc flush if nothing is dirty).  we
        // special case the remote commit listener used by the datacache cause
        // we know it doesn't require the commit event when nothing changes
<span class="nc bnc" id="L2225" title="All 2 branches missed.">        boolean flush = (_flags &amp; FLAG_FLUSH_REQUIRED) != 0;</span>
<span class="nc bnc" id="L2226" title="All 2 branches missed.">        boolean listeners = (_transEventManager.hasFlushListeners()</span>
<span class="nc bnc" id="L2227" title="All 4 branches missed.">            || _transEventManager.hasEndListeners())</span>
            &amp;&amp; ((_flags &amp; FLAG_REMOTE_LISTENER) == 0
<span class="nc bnc" id="L2229" title="All 2 branches missed.">            || _transEventManager.getListeners().size() &gt; 1);</span>
<span class="nc bnc" id="L2230" title="All 6 branches missed.">        if (!flush &amp;&amp; (reason != FLUSH_COMMIT || !listeners))</span>
<span class="nc" id="L2231">            return;</span>

<span class="nc" id="L2233">        Collection mobjs = null;</span>
<span class="nc" id="L2234">        _flags |= FLAG_PRESTORING;</span>
        try {
<span class="nc bnc" id="L2236" title="All 2 branches missed.">            if (flush) {</span>
                // call pre store on all currently transactional objs
<span class="nc bnc" id="L2238" title="All 2 branches missed.">                for (Iterator itr = transactional.iterator(); itr.hasNext();)</span>
<span class="nc" id="L2239">                    ((StateManagerImpl) itr.next()).beforeFlush(reason, _call);</span>
<span class="nc" id="L2240">                flushAdditions(transactional, reason);</span>
            }

            // hopefully now all dependent instances that are going to end
            // up referenced have been marked as such; delete unrefed
            // dependents
<span class="nc" id="L2246">            _flags |= FLAG_DEREFDELETING;</span>
<span class="nc bnc" id="L2247" title="All 6 branches missed.">            if (flush &amp;&amp; _derefCache != null &amp;&amp; !_derefCache.isEmpty()) {</span>
<span class="nc" id="L2248">                Set&lt;StateManagerImpl&gt; statesMarkedForDelete = new HashSet&lt;&gt;();</span>
                // mark for delete all elements in deref, otherwise in some situations it
                // throws ConcurrentModificationException
<span class="nc" id="L2251">                statesMarkedForDelete.addAll(_derefCache);</span>
<span class="nc bnc" id="L2252" title="All 2 branches missed.">                for (StateManagerImpl state: statesMarkedForDelete) {</span>
<span class="nc" id="L2253">                    deleteDeref(state);</span>
<span class="nc" id="L2254">                }</span>

<span class="nc" id="L2256">                flushAdditions(transactional, reason);</span>
            }

<span class="nc bnc" id="L2259" title="All 2 branches missed.">            if (reason != FLUSH_LOGICAL) {</span>
                // if no datastore transaction, start one; even if we don't
                // think we'll need to flush at this point, our transaction
                // listeners might introduce some dirty objects or interact
                // directly with the database
<span class="nc bnc" id="L2264" title="All 2 branches missed.">                if ((_flags &amp; FLAG_STORE_ACTIVE) == 0)</span>
<span class="nc" id="L2265">                    beginStoreManagerTransaction(false);</span>

<span class="nc bnc" id="L2267" title="All 2 branches missed.">                if ((_transEventManager.hasFlushListeners()</span>
<span class="nc bnc" id="L2268" title="All 6 branches missed.">                    || _transEventManager.hasEndListeners())</span>
                    &amp;&amp; (flush || reason == FLUSH_COMMIT)) {
                    // fire events
<span class="nc" id="L2271">                    mobjs = new ManagedObjectCollection(transactional);</span>
<span class="nc bnc" id="L2272" title="All 2 branches missed.">                    if (reason == FLUSH_COMMIT</span>
<span class="nc bnc" id="L2273" title="All 2 branches missed.">                        &amp;&amp; _transEventManager.hasEndListeners()) {</span>
<span class="nc" id="L2274">                        fireTransactionEvent(new TransactionEvent(this,</span>
                            TransactionEvent.BEFORE_COMMIT, mobjs,
                            _persistedClss, _updatedClss, _deletedClss));

<span class="nc" id="L2278">                        flushAdditions(transactional, reason);</span>
<span class="nc bnc" id="L2279" title="All 2 branches missed.">                        flush = (_flags &amp; FLAG_FLUSH_REQUIRED) != 0;</span>
                    }

<span class="nc bnc" id="L2282" title="All 4 branches missed.">                    if (flush &amp;&amp; _transEventManager.hasFlushListeners()) {</span>
<span class="nc" id="L2283">                        fireTransactionEvent(new TransactionEvent(this,</span>
                            TransactionEvent.BEFORE_FLUSH, mobjs,
                            _persistedClss, _updatedClss, _deletedClss));
<span class="nc" id="L2286">                        flushAdditions(transactional, reason);</span>
                    }
                }
            }
        }
        finally {
<span class="nc" id="L2292">            _flags &amp;= ~FLAG_PRESTORING;</span>
<span class="nc" id="L2293">            _flags &amp;= ~FLAG_DEREFDELETING;</span>
<span class="nc" id="L2294">            _transAdditions = null;</span>
<span class="nc" id="L2295">            _derefAdditions = null;</span>

            // also clear derefed set; the deletes have been recorded
<span class="nc bnc" id="L2298" title="All 2 branches missed.">            if (_derefCache != null)</span>
<span class="nc" id="L2299">                _derefCache = null;</span>
        }

        // flush to store manager
<span class="nc" id="L2303">        List&lt;Exception&gt; exceps = null;</span>
        try {
<span class="nc bnc" id="L2305" title="All 4 branches missed.">            if (flush &amp;&amp; reason != FLUSH_LOGICAL) {</span>
<span class="nc" id="L2306">                _flags |= FLAG_STORE_FLUSHING;</span>
<span class="nc" id="L2307">                exceps = add(exceps,</span>
<span class="nc" id="L2308">                    newFlushException(_store.flush(transactional)));</span>
            }
        } finally {
<span class="nc" id="L2311">            _flags &amp;= ~FLAG_STORE_FLUSHING;</span>

<span class="nc bnc" id="L2313" title="All 2 branches missed.">            if (reason == FLUSH_ROLLBACK)</span>
<span class="nc" id="L2314">                exceps = add(exceps, endStoreManagerTransaction(true));</span>
<span class="nc bnc" id="L2315" title="All 2 branches missed.">            else if (reason != FLUSH_LOGICAL)</span>
<span class="nc" id="L2316">                _flags &amp;= ~FLAG_FLUSH_REQUIRED;</span>

            // mark states as flushed
<span class="nc bnc" id="L2319" title="All 2 branches missed.">            if (flush) {</span>
                StateManagerImpl sm;
<span class="nc bnc" id="L2321" title="All 2 branches missed.">                for (Iterator itr = transactional.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L2322">                    sm = (StateManagerImpl) itr.next();</span>
                    try {
                        // the state may have become transient, such as if
                        // it is embedded and the owner has been deleted during
                        // this flush process; bug #1100
<span class="nc bnc" id="L2327" title="All 2 branches missed.">                        if (sm.getPCState() == PCState.TRANSIENT)</span>
<span class="nc" id="L2328">                            continue;</span>

<span class="nc" id="L2330">                        sm.afterFlush(reason);</span>
<span class="nc bnc" id="L2331" title="All 2 branches missed.">                        if (reason == FLUSH_INC) {</span>
                            // if not about to clear trans cache for commit
                            // anyway, re-cache dirty objects with default soft
                            // refs; we don't need hard refs now that the
                            // changes have been flushed
<span class="nc" id="L2336">                            sm.proxyFields(true, false);</span>
<span class="nc" id="L2337">                            _transCache.flushed(sm);</span>
                        }
<span class="nc" id="L2339">                    } catch (Exception e) {</span>
<span class="nc" id="L2340">                        exceps = add(exceps, e);</span>
<span class="nc" id="L2341">                    }</span>
                }
            }
        }

        // throw any exceptions to shortcut listeners on fail
<span class="nc" id="L2347">        throwNestedExceptions(exceps, true);</span>

<span class="nc bnc" id="L2349" title="All 6 branches missed.">        if (flush &amp;&amp; reason != FLUSH_ROLLBACK &amp;&amp; reason != FLUSH_LOGICAL</span>
<span class="nc bnc" id="L2350" title="All 2 branches missed.">            &amp;&amp; _transEventManager.hasFlushListeners()) {</span>
<span class="nc" id="L2351">            fireTransactionEvent(new TransactionEvent(this,</span>
                TransactionEvent.AFTER_FLUSH, mobjs, _persistedClss,
                _updatedClss, _deletedClss));
        }
<span class="nc" id="L2355">    }</span>

    /**
     * Flush newly-transactional objects.
     */
    private void flushAdditions(Collection transactional, int reason) {
        boolean loop;
        do {
            // flush new transactional instances; note logical or
<span class="nc" id="L2364">            loop = flushTransAdditions(transactional, reason)</span>
<span class="nc" id="L2365">                | deleteDerefAdditions(_derefCache);</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">        } while (loop);</span>
<span class="nc" id="L2367">    }</span>

    /**
     * Flush transactional additions.
     */
    private boolean flushTransAdditions(Collection transactional, int reason) {
<span class="nc bnc" id="L2373" title="All 4 branches missed.">        if (_transAdditions == null || _transAdditions.isEmpty())</span>
<span class="nc" id="L2374">            return false;</span>

        // keep local transactional list copy up to date
<span class="nc" id="L2377">        transactional.addAll(_transAdditions);</span>

        // copy the change set, then clear it for the next iteration
<span class="nc" id="L2380">        StateManagerImpl[] states = _transAdditions.</span>
<span class="nc" id="L2381">            toArray(new StateManagerImpl[_transAdditions.size()]);</span>
<span class="nc" id="L2382">        _transAdditions = null;</span>

<span class="nc bnc" id="L2384" title="All 2 branches missed.">        for (int i = 0; i &lt; states.length; i++)</span>
<span class="nc" id="L2385">            states[i].beforeFlush(reason, _call);</span>
<span class="nc" id="L2386">        return true;</span>
    }

    /**
     * Delete new dereferenced objects.
     */
    private boolean deleteDerefAdditions(Collection derefs) {
<span class="nc bnc" id="L2393" title="All 4 branches missed.">        if (_derefAdditions == null || _derefAdditions.isEmpty())</span>
<span class="nc" id="L2394">            return false;</span>

        // remember these additions in case one becomes derefed again later
<span class="nc" id="L2397">        derefs.addAll(_derefAdditions);</span>

<span class="nc" id="L2399">        StateManagerImpl[] states = _derefAdditions.</span>
<span class="nc" id="L2400">            toArray(new StateManagerImpl[_derefAdditions.size()]);</span>
<span class="nc" id="L2401">        _derefAdditions = null;</span>

<span class="nc bnc" id="L2403" title="All 2 branches missed.">        for (int i = 0; i &lt; states.length; i++)</span>
<span class="nc" id="L2404">            deleteDeref(states[i]);</span>
<span class="nc" id="L2405">        return true;</span>
    }

    /**
     * Delete a dereferenced dependent.
     */
    private void deleteDeref(StateManagerImpl sm) {
<span class="nc" id="L2412">        int action = processArgument(OpCallbacks.OP_DELETE,</span>
<span class="nc" id="L2413">            sm.getManagedInstance(), sm, null);</span>
<span class="nc bnc" id="L2414" title="All 2 branches missed.">        if ((action &amp; OpCallbacks.ACT_RUN) != 0)</span>
<span class="nc" id="L2415">            sm.delete();</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">        if ((action &amp; OpCallbacks.ACT_CASCADE) != 0)</span>
<span class="nc" id="L2417">            sm.cascadeDelete(_call);</span>
<span class="nc" id="L2418">    }</span>

    /**
     * Determine the action to take based on the user's given callbacks and
     * our implicit behavior.
     */
    private int processArgument(int op, Object obj, OpenJPAStateManager sm,
        OpCallbacks call) {
<span class="nc bnc" id="L2426" title="All 2 branches missed.">        if (call != null)</span>
<span class="nc" id="L2427">            return call.processArgument(op, obj, sm);</span>
<span class="nc bnc" id="L2428" title="All 2 branches missed.">        if (_call != null)</span>
<span class="nc" id="L2429">            return _call.processArgument(op, obj, sm);</span>
<span class="nc" id="L2430">        return OpCallbacks.ACT_RUN | OpCallbacks.ACT_CASCADE;</span>
    }

    /**
     * Throw the proper exception based on the given set of flush errors, or
     * do nothing if no errors occurred.
     */
    private OpenJPAException newFlushException(Collection&lt;Exception&gt; exceps) {
<span class="nc bnc" id="L2438" title="All 4 branches missed.">        if (exceps == null || exceps.isEmpty())</span>
<span class="nc" id="L2439">            return null;</span>

<span class="nc" id="L2441">        Throwable[] t = exceps.toArray(new Throwable[exceps.size()]);</span>
<span class="nc" id="L2442">        List&lt;Object&gt; failed = new ArrayList&lt;&gt;(t.length);</span>

        // create fatal exception with nested exceptions for all the failed
        // objects; if all OL exceptions, throw a top-level OL exception
<span class="nc" id="L2446">        boolean opt = true;</span>
<span class="nc bnc" id="L2447" title="All 4 branches missed.">        for (int i = 0; opt &amp;&amp; i &lt; t.length; i++) {</span>
<span class="nc" id="L2448">            opt = t[i] instanceof OptimisticException;</span>
<span class="nc bnc" id="L2449" title="All 2 branches missed.">            if (opt) {</span>
<span class="nc" id="L2450">                Object f = ((OptimisticException) t[i]).getFailedObject();</span>
<span class="nc bnc" id="L2451" title="All 2 branches missed.">                if (f != null)</span>
<span class="nc" id="L2452">                    failed.add(f);</span>
            }
        }
<span class="nc bnc" id="L2455" title="All 4 branches missed.">        if (opt &amp;&amp; !failed.isEmpty()) {</span>
<span class="nc bnc" id="L2456" title="All 2 branches missed.">            if(_suppressBatchOLELogging == true){</span>
<span class="nc" id="L2457">                return new OptimisticException(_loc.get(&quot;broker-suppressing-exceptions&quot;,t.length));</span>
            }else{
<span class="nc" id="L2459">                return new OptimisticException(failed, t);</span>
            }
        }
<span class="nc bnc" id="L2462" title="All 2 branches missed.">        if (opt)</span>
<span class="nc" id="L2463">            return new OptimisticException(t);</span>

<span class="nc" id="L2465">        Object failedObject = null;</span>
<span class="nc bnc" id="L2466" title="All 2 branches missed.">        if (t[0] instanceof OpenJPAException){</span>
<span class="nc" id="L2467">            failedObject = ((OpenJPAException)t[0]).getFailedObject();</span>
        }

<span class="nc" id="L2470">        return new StoreException(_loc.get(&quot;rolled-back&quot;)).</span>
<span class="nc" id="L2471">            setNestedThrowables(t).setFatal(true).setFailedObject(failedObject);</span>
    }

    /**
     * End the current transaction, making appropriate state transitions.
     */
    protected void endTransaction(int status) {
        // if a data store transaction was in progress, do the
        // appropriate transaction change
<span class="nc bnc" id="L2480" title="All 2 branches missed.">        boolean rollback = status != Status.STATUS_COMMITTED;</span>
<span class="nc" id="L2481">        List&lt;Exception&gt; exceps = null;</span>

        try {
<span class="nc" id="L2484">            exceps = add(exceps, endStoreManagerTransaction(rollback));</span>
<span class="nc" id="L2485">        } catch (RuntimeException re) {</span>
<span class="nc" id="L2486">            rollback = true;</span>
<span class="nc" id="L2487">            exceps = add(exceps, re);</span>
<span class="nc" id="L2488">        }</span>

        // go back to default none lock level
<span class="nc" id="L2491">        _fc.setReadLockLevel(LOCK_NONE);</span>
<span class="nc" id="L2492">        _fc.setWriteLockLevel(LOCK_NONE);</span>
<span class="nc" id="L2493">        _fc.setLockTimeout(-1);</span>

        Collection transStates;
<span class="nc bnc" id="L2496" title="All 2 branches missed.">        if (hasTransactionalObjects())</span>
<span class="nc" id="L2497">            transStates = _transCache;</span>
        else
<span class="nc" id="L2499">            transStates = Collections.EMPTY_SET;</span>

        // fire after rollback/commit event
<span class="nc" id="L2502">        Collection mobjs = null;</span>
<span class="nc bnc" id="L2503" title="All 2 branches missed.">        if (_transEventManager.hasEndListeners()) {</span>
<span class="nc" id="L2504">            mobjs = new ManagedObjectCollection(transStates);</span>
<span class="nc bnc" id="L2505" title="All 2 branches missed.">            int eventType = (rollback) ? TransactionEvent.AFTER_ROLLBACK</span>
<span class="nc" id="L2506">                : TransactionEvent.AFTER_COMMIT;</span>
<span class="nc" id="L2507">            fireTransactionEvent(new TransactionEvent(this, eventType, mobjs,</span>
                _persistedClss, _updatedClss, _deletedClss));
        }

        // null transactional caches now so that all the removeFromTransaction
        // calls as we transition each object don't have to do any work; don't
        // clear trans cache object because we still need the transStates
        // reference to it below
<span class="nc" id="L2515">        _transCache = null;</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">        if (_persistedClss != null)</span>
<span class="nc" id="L2517">            _persistedClss = null;</span>
<span class="nc bnc" id="L2518" title="All 2 branches missed.">        if (_updatedClss != null)</span>
<span class="nc" id="L2519">            _updatedClss = null;</span>
<span class="nc bnc" id="L2520" title="All 2 branches missed.">        if (_deletedClss != null)</span>
<span class="nc" id="L2521">            _deletedClss = null;</span>

        // new cache would get cleared anyway during transitions, but doing so
        // immediately saves us some lookups
<span class="nc" id="L2525">        _cache.clearNew();</span>

        // tell all derefed instances they're no longer derefed; we can't
        // rely on rollback and commit calls below cause some instances might
        // not be transactional
<span class="nc bnc" id="L2530" title="All 4 branches missed.">        if (_derefCache != null &amp;&amp; !_derefCache.isEmpty()) {</span>
<span class="nc bnc" id="L2531" title="All 2 branches missed.">            for (Iterator&lt;StateManagerImpl&gt; itr = _derefCache.iterator(); itr.hasNext();)</span>
<span class="nc" id="L2532">                itr.next().setDereferencedDependent(false, false);</span>
<span class="nc" id="L2533">            _derefCache = null;</span>
        }

        // perform commit or rollback state transitions on each instance
        StateManagerImpl sm;
<span class="nc bnc" id="L2538" title="All 2 branches missed.">        for (Iterator itr = transStates.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L2539">            sm = (StateManagerImpl) itr.next();</span>
            try {
<span class="nc bnc" id="L2541" title="All 2 branches missed.">                if (rollback) {</span>
                    // tell objects that may have been derefed then flushed
                    // (and therefore deleted) to un-deref
<span class="nc" id="L2544">                    sm.setDereferencedDependent(false, false);</span>
<span class="nc" id="L2545">                    sm.rollback();</span>
                } else {
<span class="nc bnc" id="L2547" title="All 4 branches missed.">                    if (sm.getPCState() == PCState.PNEWDELETED || sm.getPCState() == PCState.PDELETED) {</span>
<span class="nc" id="L2548">                        fireLifecycleEvent(sm.getPersistenceCapable(), null, sm.getMetaData(),</span>
                            LifecycleEvent.AFTER_DELETE_PERFORMED);
                    }
<span class="nc" id="L2551">                    sm.commit();</span>
                }
<span class="nc" id="L2553">            } catch (RuntimeException re) {</span>
<span class="nc" id="L2554">                exceps = add(exceps, re);</span>
<span class="nc" id="L2555">            }</span>
        }

        // notify the lock manager to clean up and release remaining locks
<span class="nc" id="L2559">        _lm.endTransaction();</span>

        // clear old savepoints in reverse
        OpenJPASavepoint save;
<span class="nc bnc" id="L2563" title="All 4 branches missed.">        while (_savepoints != null &amp;&amp; _savepoints.size() &gt; 0) {</span>
<span class="nc" id="L2564">            save =</span>
<span class="nc" id="L2565">                (OpenJPASavepoint) _savepoints.remove(_savepoints.size() - 1);</span>
<span class="nc" id="L2566">            save.release(false);</span>
        }
<span class="nc" id="L2568">        _savepoints = null;</span>
<span class="nc" id="L2569">        _savepointCache = null;</span>

        // fire after state change event
<span class="nc bnc" id="L2572" title="All 2 branches missed.">        if (_transEventManager.hasEndListeners())</span>
<span class="nc" id="L2573">            fireTransactionEvent(new TransactionEvent(this, TransactionEvent.</span>
                AFTER_STATE_TRANSITIONS, mobjs, null, null, null));

        // now clear trans cache; keep cleared version rather than
        // null to avoid having to re-create the set later; more efficient
<span class="nc bnc" id="L2578" title="All 2 branches missed.">        if (transStates != Collections.EMPTY_SET) {</span>
<span class="nc" id="L2579">            _transCache = (TransactionalCache) transStates;</span>
<span class="nc" id="L2580">            _transCache.clear();</span>
        }

<span class="nc" id="L2583">        throwNestedExceptions(exceps, true);</span>
<span class="nc" id="L2584">    }</span>

    ////////////////////
    // Object lifecycle
    ////////////////////

    @Override
    public void persist(Object obj, OpCallbacks call) {
<span class="nc" id="L2592">        persist(obj, null, true, call);</span>
<span class="nc" id="L2593">    }</span>

    @Override
    public OpenJPAStateManager persist(Object obj, Object id,
        OpCallbacks call) {
<span class="nc" id="L2598">        return persist(obj, id, true, call);</span>
    }

    @Override
    public void persistAll(Collection objs, OpCallbacks call) {
<span class="nc" id="L2603">        persistAll(objs, true, call);</span>
<span class="nc" id="L2604">    }</span>

    /**
     * Persist the given objects.  Indicate whether this was an explicit persist
     * (PNEW) or a provisonal persist (PNEWPROVISIONAL).
     */
    public void persistAll(Collection objs, boolean explicit,
        OpCallbacks call) {
<span class="nc bnc" id="L2612" title="All 2 branches missed.">        if (objs.isEmpty())</span>
<span class="nc" id="L2613">            return;</span>

<span class="nc" id="L2615">        beginOperation(true);</span>
<span class="nc" id="L2616">        List&lt;Exception&gt; exceps = null;</span>
        try {
<span class="nc" id="L2618">            assertWriteOperation();</span>

<span class="nc bnc" id="L2620" title="All 2 branches missed.">            for (Object obj : objs) {</span>
                try {
<span class="nc bnc" id="L2622" title="All 2 branches missed.">                	if(obj == null)</span>
<span class="nc" id="L2623">                		continue;</span>
<span class="nc" id="L2624">                    persistInternal(obj, null, explicit, call, true);</span>
<span class="nc" id="L2625">                } catch (UserException ue) {</span>
<span class="nc" id="L2626">                    exceps = add(exceps, ue);</span>
                }
<span class="nc" id="L2628">                catch (RuntimeException re) {</span>
<span class="nc" id="L2629">                    throw new GeneralException(re);</span>
<span class="nc" id="L2630">                }</span>
<span class="nc" id="L2631">            }</span>
        } finally {
<span class="nc" id="L2633">            endOperation();</span>
        }
<span class="nc" id="L2635">        throwNestedExceptions(exceps, false);</span>
<span class="nc" id="L2636">    }</span>

    /**
     * If the given element is not null, add it to the given list,
     * creating the list if necessary.
     */
    private List&lt;Exception&gt; add(List&lt;Exception&gt; l, Exception o) {
<span class="nc bnc" id="L2643" title="All 2 branches missed.">        if (o == null)</span>
<span class="nc" id="L2644">            return l;</span>
<span class="nc bnc" id="L2645" title="All 2 branches missed.">        if (l == null)</span>
<span class="nc" id="L2646">            l = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L2647">        l.add(o);</span>
<span class="nc" id="L2648">        return l;</span>
    }

    /**
     * Throw an exception wrapping the given nested exceptions.
     */
    private void throwNestedExceptions(List&lt;Exception&gt; exceps, boolean datastore) {
<span class="nc bnc" id="L2655" title="All 4 branches missed.">        if (exceps == null || exceps.isEmpty())</span>
<span class="nc" id="L2656">            return;</span>
<span class="nc bnc" id="L2657" title="All 4 branches missed.">        if (datastore &amp;&amp; exceps.size() == 1)</span>
<span class="nc" id="L2658">            throw (RuntimeException) exceps.get(0);</span>

<span class="nc" id="L2660">        boolean fatal = false;</span>
<span class="nc" id="L2661">        Throwable[] t = exceps.toArray(new Throwable[exceps.size()]);</span>
<span class="nc bnc" id="L2662" title="All 2 branches missed.">        for (int i = 0; i &lt; t.length; i++) {</span>
<span class="nc bnc" id="L2663" title="All 2 branches missed.">            if (t[i] instanceof OpenJPAException</span>
<span class="nc bnc" id="L2664" title="All 2 branches missed.">                &amp;&amp; ((OpenJPAException) t[i]).isFatal())</span>
<span class="nc" id="L2665">                fatal = true;</span>
        }
        OpenJPAException err;
<span class="nc bnc" id="L2668" title="All 2 branches missed.">        if (datastore)</span>
<span class="nc" id="L2669">            err = new StoreException(_loc.get(&quot;nested-exceps&quot;));</span>
        else
<span class="nc" id="L2671">            err = new UserException(_loc.get(&quot;nested-exceps&quot;));</span>
<span class="nc" id="L2672">        throw err.setNestedThrowables(t).setFatal(fatal);</span>
    }

    /**
     * Persist the given object.  Indicate whether this was an explicit persist
     * (PNEW) or a provisonal persist (PNEWPROVISIONAL)
     */
    public void persist(Object obj, boolean explicit, OpCallbacks call) {
<span class="nc" id="L2680">        persist(obj, null, explicit, call);</span>
<span class="nc" id="L2681">    }</span>

    /**
     * Persist the given object.  Indicate whether this was an explicit persist
     * (PNEW) or a provisonal persist (PNEWPROVISIONAL).
     * See {@link Broker} for details on this method.
     */
    public OpenJPAStateManager persist(Object obj, Object id, boolean explicit,
        OpCallbacks call) {
<span class="nc" id="L2690">        return persist(obj, id, explicit, call, true);</span>
    }

    /**
     * Persist the given object.  Indicate whether this was an explicit persist
     * (PNEW) or a provisonal persist (PNEWPROVISIONAL).
     * See {@link Broker} for details on this method.
     */
    public OpenJPAStateManager persist(Object obj, Object id, boolean explicit,
        OpCallbacks call, boolean fireEvent) {
<span class="nc bnc" id="L2700" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L2701">            return null;</span>

<span class="nc" id="L2703">        beginOperation(true);</span>
        try {
<span class="nc" id="L2705">            assertWriteOperation();</span>

<span class="nc" id="L2707">            return persistInternal(obj, id, explicit, call, fireEvent);</span>
<span class="nc" id="L2708">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L2709">            throw ke;</span>
<span class="nc" id="L2710">        } catch (RuntimeException re) {</span>
<span class="nc" id="L2711">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L2713">            endOperation();</span>
        }
    }

    private OpenJPAStateManager persistInternal(Object obj, Object id, boolean explicit, OpCallbacks call,
        boolean fireEvent) {
<span class="nc" id="L2719">        StateManagerImpl sm = getStateManagerImpl(obj, true);</span>
<span class="nc bnc" id="L2720" title="All 2 branches missed.">        if (!operatingAdd(obj)) {</span>
<span class="nc" id="L2721">            return sm;</span>
        }

<span class="nc" id="L2724">        int action = processArgument(OpCallbacks.OP_PERSIST, obj, sm, call);</span>
<span class="nc bnc" id="L2725" title="All 2 branches missed.">        if (action == OpCallbacks.ACT_NONE) {</span>
<span class="nc" id="L2726">            return sm;</span>
        }

        // ACT_CASCADE
<span class="nc bnc" id="L2730" title="All 2 branches missed.">        if ((action &amp; OpCallbacks.ACT_RUN) == 0) {</span>
<span class="nc bnc" id="L2731" title="All 2 branches missed.">            if (sm != null) {</span>
<span class="nc" id="L2732">                sm.cascadePersist(call);</span>
            } else {
<span class="nc" id="L2734">                cascadeTransient(OpCallbacks.OP_PERSIST, obj, call, &quot;persist&quot;);</span>
            }
<span class="nc" id="L2736">            return sm;</span>
        }

        // ACT_RUN
        PersistenceCapable pc;
<span class="nc bnc" id="L2741" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc bnc" id="L2742" title="All 2 branches missed.">            if (sm.isDetached()) {</span>
<span class="nc" id="L2743">                throw new ObjectExistsException(_loc.get(&quot;persist-detached&quot;, Exceptions.toString(obj)))</span>
<span class="nc" id="L2744">                    .setFailedObject(obj);</span>
            }

<span class="nc bnc" id="L2747" title="All 2 branches missed.">            if (!sm.isEmbedded()) {</span>
<span class="nc" id="L2748">                sm.persist();</span>
<span class="nc" id="L2749">                _cache.persist(sm);</span>
<span class="nc bnc" id="L2750" title="All 2 branches missed.">                if ((action &amp; OpCallbacks.ACT_CASCADE) != 0) {</span>
<span class="nc" id="L2751">                    sm.cascadePersist(call);</span>
                }
<span class="nc" id="L2753">                return sm;</span>
            }

            // an embedded field; notify the owner that the value has
            // changed by becoming independently persistent
<span class="nc" id="L2758">            sm.getOwner().dirty(sm.getOwnerIndex());</span>
<span class="nc" id="L2759">            _cache.persist(sm);</span>
<span class="nc" id="L2760">            pc = sm.getPersistenceCapable();</span>
        } else {
<span class="nc" id="L2762">            pc = assertPersistenceCapable(obj);</span>
<span class="nc bnc" id="L2763" title="All 2 branches missed.">            if (pc.pcIsDetached() == Boolean.TRUE) {</span>
<span class="nc" id="L2764">                throw new ObjectExistsException(_loc.get(&quot;persist-detached&quot;, Exceptions.toString(obj)))</span>
<span class="nc" id="L2765">                    .setFailedObject(obj);</span>
            }
        }

<span class="nc" id="L2769">        ClassMetaData meta = _repo.getMetaData(obj.getClass(), _loader, true);</span>
<span class="nc bnc" id="L2770" title="All 2 branches missed.">        if (fireEvent) {</span>
<span class="nc" id="L2771">            fireLifecycleEvent(obj, null, meta, LifecycleEvent.BEFORE_PERSIST);</span>
        }

        // create id for instance
<span class="nc bnc" id="L2775" title="All 2 branches missed.">        if (id == null) {</span>
<span class="nc" id="L2776">            int idType = meta.getIdentityType();</span>
<span class="nc bnc" id="L2777" title="All 2 branches missed.">            if (idType == ClassMetaData.ID_APPLICATION) {</span>
<span class="nc" id="L2778">                id = ApplicationIds.create(pc, meta);</span>
<span class="nc bnc" id="L2779" title="All 2 branches missed.">            } else if (idType == ClassMetaData.ID_UNKNOWN) {</span>
<span class="nc" id="L2780">                throw new UserException(_loc.get(&quot;meta-unknownid&quot;, meta));</span>
            } else {
<span class="nc" id="L2782">                id = StateManagerId.newInstance(this);</span>
            }
        }

        // make sure we don't already have the instance cached
<span class="nc" id="L2787">        checkForDuplicateId(id, obj, meta);</span>

        // if had embedded sm, null it
<span class="nc bnc" id="L2790" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L2791">            pc.pcReplaceStateManager(null);</span>
        }

        // create new sm
<span class="nc" id="L2795">        sm = newStateManagerImpl(id, meta);</span>
<span class="nc bnc" id="L2796" title="All 2 branches missed.">        if ((_flags &amp; FLAG_ACTIVE) != 0) {</span>
<span class="nc bnc" id="L2797" title="All 2 branches missed.">            if (explicit) {</span>
<span class="nc" id="L2798">                sm.initialize(pc, PCState.PNEW);</span>
            } else {
<span class="nc" id="L2800">                sm.initialize(pc, PCState.PNEWPROVISIONAL);</span>
            }
        } else {
<span class="nc" id="L2803">            sm.initialize(pc, PCState.PNONTRANSNEW);</span>
        }
<span class="nc bnc" id="L2805" title="All 2 branches missed.">        if ((action &amp; OpCallbacks.ACT_CASCADE) != 0) {</span>
<span class="nc" id="L2806">            sm.cascadePersist(call);</span>
        }
<span class="nc" id="L2808">        return sm;</span>
    }

    /**
     * Temporarily manage the given instance in order to cascade the given
     * operation through it.
     */
    private void cascadeTransient(int op, Object obj, OpCallbacks call,
        String errOp) {
<span class="nc" id="L2817">        PersistenceCapable pc = assertPersistenceCapable(obj);</span>

        // if using detached state manager, don't replace
<span class="nc bnc" id="L2820" title="All 2 branches missed.">        if (pc.pcGetStateManager() != null)</span>
<span class="nc" id="L2821">            throw newDetachedException(obj, errOp);</span>

<span class="nc" id="L2823">        ClassMetaData meta = _repo.getMetaData(obj.getClass(), _loader, true);</span>
<span class="nc" id="L2824">        StateManagerImpl sm = newStateManagerImpl(StateManagerId.</span>
<span class="nc" id="L2825">            newInstance(this), meta);</span>
<span class="nc" id="L2826">        sm.initialize(pc, PCState.TLOADED);</span>
        try {
<span class="nc bnc" id="L2828" title="All 4 branches missed.">            switch (op) {</span>
                case OpCallbacks.OP_PERSIST:
<span class="nc" id="L2830">                    sm.cascadePersist(call);</span>
<span class="nc" id="L2831">                    break;</span>
                case OpCallbacks.OP_DELETE:
<span class="nc" id="L2833">                    sm.cascadeDelete(call);</span>
<span class="nc" id="L2834">                    break;</span>
                case OpCallbacks.OP_REFRESH:
<span class="nc" id="L2836">                    sm.gatherCascadeRefresh(call);</span>
<span class="nc" id="L2837">                    break;</span>
                default:
<span class="nc" id="L2839">                    throw new InternalException(String.valueOf(op));</span>
            }
        }
        finally {
<span class="nc" id="L2843">            sm.release(true);</span>
        }
<span class="nc" id="L2845">    }</span>

    @Override
    public void deleteAll(Collection objs, OpCallbacks call) {
<span class="nc" id="L2849">        beginOperation(true);</span>
        try {
<span class="nc" id="L2851">            assertWriteOperation();</span>

<span class="nc" id="L2853">            List&lt;Exception&gt; exceps = null;</span>
            Object obj;
<span class="nc bnc" id="L2855" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = objs.iterator(); itr.hasNext();) {</span>
                try {
<span class="nc" id="L2857">                    obj = itr.next();</span>
<span class="nc bnc" id="L2858" title="All 2 branches missed.">                    if (obj != null)</span>
<span class="nc" id="L2859">                        delete(obj, getStateManagerImpl(obj, true), call);</span>
<span class="nc" id="L2860">                } catch (UserException ue) {</span>
<span class="nc" id="L2861">                    exceps = add(exceps, ue);</span>
<span class="nc" id="L2862">                }</span>
            }
<span class="nc" id="L2864">            throwNestedExceptions(exceps, false);</span>
        } finally {
<span class="nc" id="L2866">            endOperation();</span>
        }
<span class="nc" id="L2868">    }</span>

    @Override
    public void delete(Object obj, OpCallbacks call) {
<span class="nc bnc" id="L2872" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L2873">            return;</span>

<span class="nc" id="L2875">        beginOperation(true);</span>
        try {
<span class="nc" id="L2877">            assertWriteOperation();</span>
<span class="nc" id="L2878">            delete(obj, getStateManagerImpl(obj, true), call);</span>
<span class="nc" id="L2879">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L2880">            throw ke;</span>
<span class="nc" id="L2881">        } catch (RuntimeException re) {</span>
<span class="nc" id="L2882">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L2884">            endOperation();</span>
        }
<span class="nc" id="L2886">    }</span>

    /**
     * Internal delete.
     */
    void delete(Object obj, StateManagerImpl sm, OpCallbacks call) {
<span class="nc bnc" id="L2892" title="All 2 branches missed.">        if (!operatingAdd(obj))</span>
<span class="nc" id="L2893">            return;</span>

<span class="nc" id="L2895">        int action = processArgument(OpCallbacks.OP_DELETE, obj, sm, call);</span>
<span class="nc bnc" id="L2896" title="All 2 branches missed.">        if (action == OpCallbacks.ACT_NONE)</span>
<span class="nc" id="L2897">            return;</span>

        // ACT_CASCADE
<span class="nc bnc" id="L2900" title="All 2 branches missed.">        if ((action &amp; OpCallbacks.ACT_RUN) == 0) {</span>
<span class="nc bnc" id="L2901" title="All 2 branches missed.">            if (sm != null) {</span>
<span class="nc bnc" id="L2902" title="All 4 branches missed.">                if (!sm.isEmbedded() || !sm.getDereferencedEmbedDependent()) {</span>
<span class="nc" id="L2903">                    sm.cascadeDelete(call);</span>
                }
            }
            else
<span class="nc" id="L2907">                cascadeTransient(OpCallbacks.OP_DELETE, obj, call, &quot;delete&quot;);</span>
<span class="nc" id="L2908">            return;</span>
        }

        // ACT_RUN
<span class="nc bnc" id="L2912" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc bnc" id="L2913" title="All 2 branches missed.">            if (sm.isDetached())</span>
<span class="nc" id="L2914">                throw newDetachedException(obj, &quot;delete&quot;);</span>
<span class="nc bnc" id="L2915" title="All 2 branches missed.">            if ((action &amp; OpCallbacks.ACT_CASCADE) != 0) {</span>
<span class="nc bnc" id="L2916" title="All 4 branches missed.">                if (!sm.isEmbedded() || !sm.getDereferencedEmbedDependent()) {</span>
<span class="nc bnc" id="L2917" title="All 2 branches missed.">                    if (ValidatingLifecycleEventManager.class.isAssignableFrom(_lifeEventManager.getClass())) {</span>
<span class="nc" id="L2918">                        ValidatingLifecycleEventManager _validatingLCEventManager =</span>
                            (ValidatingLifecycleEventManager) _lifeEventManager;
<span class="nc" id="L2920">                        boolean saved = _validatingLCEventManager.setValidationEnabled(false);</span>
                        try {
<span class="nc" id="L2922">                            sm.cascadeDelete(call);</span>
                        } finally {
<span class="nc" id="L2924">                            _validatingLCEventManager.setValidationEnabled(saved);</span>
                        }
<span class="nc" id="L2926">                    } else {</span>
<span class="nc" id="L2927">                        sm.cascadeDelete(call);</span>
                    }
                }
            }
<span class="nc" id="L2931">            sm.delete();</span>
<span class="nc bnc" id="L2932" title="All 2 branches missed.">        } else if (assertPersistenceCapable(obj).pcIsDetached() == Boolean.TRUE)</span>
<span class="nc" id="L2933">            throw newDetachedException(obj, &quot;delete&quot;);</span>
<span class="nc" id="L2934">    }</span>

    /**
     * Throw an exception indicating that the current action can't be
     * performed on a detached object.
     */
    private OpenJPAException newDetachedException(Object obj,
        String operation) {
<span class="nc" id="L2942">        throw new UserException(_loc.get(&quot;bad-detached-op&quot;, operation,</span>
<span class="nc" id="L2943">            Exceptions.toString(obj))).setFailedObject(obj);</span>
    }

    @Override
    public void releaseAll(Collection objs, OpCallbacks call) {
<span class="nc" id="L2948">        beginOperation(false);</span>
        try {
<span class="nc" id="L2950">            List&lt;Exception&gt; exceps = null;</span>
<span class="nc bnc" id="L2951" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = objs.iterator(); itr.hasNext();) {</span>
                try {
<span class="nc" id="L2953">                    release(itr.next(), call);</span>
<span class="nc" id="L2954">                } catch (UserException ue) {</span>
<span class="nc" id="L2955">                    exceps = add(exceps, ue);</span>
<span class="nc" id="L2956">                }</span>
            }
<span class="nc" id="L2958">            throwNestedExceptions(exceps, false);</span>
        } finally {
<span class="nc" id="L2960">            endOperation();</span>
        }
<span class="nc" id="L2962">    }</span>

    @Override
    public void release(Object obj, OpCallbacks call) {
<span class="nc bnc" id="L2966" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L2967">            return;</span>

<span class="nc" id="L2969">        beginOperation(false);</span>
        try {
<span class="nc" id="L2971">            StateManagerImpl sm = getStateManagerImpl(obj, true);</span>
<span class="nc" id="L2972">            int action = processArgument(OpCallbacks.OP_RELEASE, obj, sm, call);</span>

<span class="nc bnc" id="L2974" title="All 2 branches missed.">            if (sm == null)</span>
<span class="nc" id="L2975">                return;</span>
<span class="nc bnc" id="L2976" title="All 4 branches missed.">            if ((action &amp; OpCallbacks.ACT_RUN) != 0 &amp;&amp; sm.isPersistent()) {</span>
<span class="nc" id="L2977">                boolean pending = sm.isPendingTransactional();</span>
<span class="nc" id="L2978">                sm.release(true);</span>
<span class="nc bnc" id="L2979" title="All 2 branches missed.">                if (pending)</span>
<span class="nc" id="L2980">                    removeFromPendingTransaction(sm);</span>
            }
        }
<span class="nc" id="L2983">        catch (OpenJPAException ke) {</span>
<span class="nc" id="L2984">            throw ke;</span>
<span class="nc" id="L2985">        } catch (RuntimeException re) {</span>
<span class="nc" id="L2986">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L2988">            endOperation();</span>
        }
<span class="nc" id="L2990">    }</span>

    @Override
    public OpenJPAStateManager embed(Object obj, Object id,
        OpenJPAStateManager owner, ValueMetaData ownerMeta) {
<span class="nc" id="L2995">        beginOperation(true);</span>
        try {
<span class="nc" id="L2997">            StateManagerImpl orig = getStateManagerImpl(obj, true);</span>
<span class="nc bnc" id="L2998" title="All 2 branches missed.">            if (orig != null) {</span>
                // if already embedded, nothing to do
<span class="nc bnc" id="L3000" title="All 2 branches missed.">                if (orig.getOwner() == owner &amp;&amp; orig.getMetaData().</span>
<span class="nc bnc" id="L3001" title="All 2 branches missed.">                    getEmbeddingMetaData() == ownerMeta)</span>
<span class="nc" id="L3002">                    return orig;</span>

                // otherwise make sure pc is fully loaded for when we copy its
                // data below
<span class="nc" id="L3006">                orig.load(_fc, StateManagerImpl.LOAD_ALL, null, null, false);</span>
            }

            // create new state manager with embedded metadata
<span class="nc" id="L3010">            ClassMetaData meta = ownerMeta.getEmbeddedMetaData();</span>
<span class="nc bnc" id="L3011" title="All 2 branches missed.">            if (meta == null)</span>
<span class="nc" id="L3012">                throw new InternalException(_loc.get(&quot;bad-embed&quot;, ownerMeta));</span>

<span class="nc bnc" id="L3014" title="All 2 branches missed.">            if (id == null)</span>
<span class="nc" id="L3015">                id = StateManagerId.newInstance(this);</span>

<span class="nc" id="L3017">            StateManagerImpl sm = newStateManagerImpl(id, meta);</span>
<span class="nc" id="L3018">            sm.setOwner((StateManagerImpl) owner, ownerMeta);</span>

            PersistenceCapable copy;
            PCState state;
<span class="nc" id="L3022">            Class&lt;?&gt; type = meta.getDescribedType();</span>
<span class="nc bnc" id="L3023" title="All 2 branches missed.">            if (obj != null) {</span>
                // give copy and the original instance the same state manager
                // so that we can copy fields from one to the other
                StateManagerImpl copySM;
                PersistenceCapable pc;
<span class="nc bnc" id="L3028" title="All 2 branches missed.">                if (orig == null) {</span>
<span class="nc" id="L3029">                    copySM = sm;</span>
<span class="nc" id="L3030">                    pc = assertPersistenceCapable(obj);</span>
<span class="nc" id="L3031">                    pc.pcReplaceStateManager(sm);</span>
                } else {
<span class="nc" id="L3033">                    copySM = orig;</span>
<span class="nc" id="L3034">                    pc = orig.getPersistenceCapable();</span>
                }

                try {
                    // copy the instance.  we do this even if it doesn't already
                    // have a state manager in case it is later assigned to a
                    // PC field; at that point it's too late to copy
<span class="nc" id="L3041">                    copy = PCRegistry.newInstance(type, copySM, false);</span>
<span class="nc" id="L3042">                    int[] fields = new int[meta.getFields().length];</span>
<span class="nc bnc" id="L3043" title="All 2 branches missed.">                    for (int i = 0; i &lt; fields.length; i++)</span>
<span class="nc" id="L3044">                        fields[i] = i;</span>
<span class="nc" id="L3045">                    copy.pcCopyFields(pc, fields);</span>
<span class="nc" id="L3046">                    state = PCState.ECOPY;</span>
<span class="nc" id="L3047">                    copy.pcReplaceStateManager(null);</span>
                } finally {
                    // if the instance didn't have a state manager to start,
                    // revert it to being transient
<span class="nc bnc" id="L3051" title="All 2 branches missed.">                    if (orig == null)</span>
<span class="nc" id="L3052">                        pc.pcReplaceStateManager(null);</span>
                }
<span class="nc" id="L3054">            } else {</span>
<span class="nc" id="L3055">                copy = PCRegistry.newInstance(type, sm, false);</span>
<span class="nc bnc" id="L3056" title="All 4 branches missed.">                if ((_flags &amp; FLAG_ACTIVE) != 0 &amp;&amp; !_optimistic)</span>
<span class="nc" id="L3057">                    state = PCState.ECLEAN;</span>
                else
<span class="nc" id="L3059">                    state = PCState.ENONTRANS;</span>
            }

<span class="nc" id="L3062">            sm.initialize(copy, state);</span>
<span class="nc" id="L3063">            return sm;</span>
<span class="nc" id="L3064">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3065">            throw ke;</span>
<span class="nc" id="L3066">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3067">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L3069">            endOperation();</span>
        }
    }

    /**
     * If not already cached, create an empty copy of the given state
     * manager in the given state.
     */
    OpenJPAStateManager copy(OpenJPAStateManager copy, PCState state) {
<span class="nc" id="L3078">        beginOperation(true);</span>
        try {
<span class="nc" id="L3080">            assertOpen();</span>
<span class="nc" id="L3081">            Object oid = copy.fetchObjectId();</span>
<span class="nc" id="L3082">            Class&lt;?&gt; type = copy.getManagedInstance().getClass();</span>
<span class="nc bnc" id="L3083" title="All 2 branches missed.">            if (oid == null)</span>
<span class="nc" id="L3084">                throw new InternalException();</span>
            // cached instance?
<span class="nc" id="L3086">            StateManagerImpl sm = null;</span>
<span class="nc bnc" id="L3087" title="All 2 branches missed.">            if (!copy.isEmbedded())</span>
<span class="nc" id="L3088">                sm = getStateManagerImplById(oid, true);</span>
<span class="nc bnc" id="L3089" title="All 2 branches missed.">            if (sm == null) {</span>
<span class="nc" id="L3090">                MetaDataRepository repos = _conf.</span>
<span class="nc" id="L3091">                    getMetaDataRepositoryInstance();</span>
<span class="nc" id="L3092">                ClassMetaData meta = repos.getMetaData(type, _loader, true);</span>
                // construct a new state manager with all info known
<span class="nc" id="L3094">                sm = newStateManagerImpl(oid, meta);</span>
<span class="nc" id="L3095">                sm.setObjectId(oid);</span>
<span class="nc" id="L3096">                sm.initialize(sm.getMetaData().getDescribedType(), state);</span>
            }
<span class="nc" id="L3098">            return sm;</span>
        } finally {
<span class="nc" id="L3100">            endOperation();</span>
        }
    }

    @Override
    public void refreshAll(Collection objs, OpCallbacks call) {
<span class="nc bnc" id="L3106" title="All 4 branches missed.">        if (objs == null || objs.isEmpty())</span>
<span class="nc" id="L3107">            return;</span>

<span class="nc" id="L3109">        beginOperation(true);</span>
        try {
<span class="nc" id="L3111">            assertNontransactionalRead();</span>

<span class="nc bnc" id="L3113" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = objs.iterator(); itr.hasNext();)</span>
<span class="nc" id="L3114">                gatherCascadeRefresh(itr.next(), call);</span>
<span class="nc bnc" id="L3115" title="All 2 branches missed.">            if (_operating.isEmpty())</span>
<span class="nc" id="L3116">            	return;</span>
<span class="nc bnc" id="L3117" title="All 2 branches missed.">            if (_operating.size() == 1)</span>
<span class="nc" id="L3118">            	refreshInternal(_operating.iterator().next(), call);</span>
            else
<span class="nc" id="L3120">            	refreshInternal(_operating, call);</span>
        } finally {
<span class="nc" id="L3122">            endOperation();</span>
        }
<span class="nc" id="L3124">    }</span>

    @Override
    public void refresh(Object obj, OpCallbacks call) {
<span class="nc bnc" id="L3128" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L3129">            return;</span>

<span class="nc" id="L3131">        beginOperation(true);</span>
        try {
<span class="nc" id="L3133">            assertNontransactionalRead();</span>

<span class="nc" id="L3135">            gatherCascadeRefresh(obj, call);</span>
<span class="nc bnc" id="L3136" title="All 2 branches missed.">            if (_operating.isEmpty())</span>
<span class="nc" id="L3137">            	return;</span>
<span class="nc bnc" id="L3138" title="All 2 branches missed.">            if (_operating.size() == 1)</span>
<span class="nc" id="L3139">            	refreshInternal(_operating.iterator().next(), call);</span>
            else
<span class="nc" id="L3141">            	refreshInternal(_operating, call);</span>
        } finally {
<span class="nc" id="L3143">            endOperation();</span>
        }
<span class="nc" id="L3145">    }</span>

    /**
     * Gathers all objects reachable through cascade-refresh relations
     * into the operating set.
     */
    void gatherCascadeRefresh(Object obj, OpCallbacks call) {
<span class="nc bnc" id="L3152" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L3153">            return;</span>
<span class="nc bnc" id="L3154" title="All 2 branches missed.">        if (!operatingAdd(obj))</span>
<span class="nc" id="L3155">            return;</span>

<span class="nc" id="L3157">        StateManagerImpl sm = getStateManagerImpl(obj, false);</span>
<span class="nc" id="L3158">        int action = processArgument(OpCallbacks.OP_REFRESH, obj, sm, call);</span>
<span class="nc bnc" id="L3159" title="All 2 branches missed.">        if ((action &amp; OpCallbacks.ACT_CASCADE) == 0)</span>
<span class="nc" id="L3160">            return;</span>

<span class="nc bnc" id="L3162" title="All 2 branches missed.">        if (sm != null)</span>
<span class="nc" id="L3163">            sm.gatherCascadeRefresh(call);</span>
        else
<span class="nc" id="L3165">            cascadeTransient(OpCallbacks.OP_REFRESH, obj, call, &quot;refresh&quot;);</span>
<span class="nc" id="L3166">    }</span>

    /**
     * This method is called with the full set of objects reachable via
     * cascade-refresh relations from the user-given instances.
     */
    protected void refreshInternal(Collection objs, OpCallbacks call) {
<span class="nc bnc" id="L3173" title="All 4 branches missed.">    	if (objs == null || objs.isEmpty())</span>
<span class="nc" id="L3174">    		return;</span>
<span class="nc" id="L3175">        List&lt;Exception&gt; exceps = null;</span>
        try {
            // collect instances that need a refresh
<span class="nc" id="L3178">            Collection&lt;OpenJPAStateManager&gt; load = null;</span>
            StateManagerImpl sm;
            Object obj;
<span class="nc bnc" id="L3181" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = objs.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L3182">                obj = itr.next();</span>
<span class="nc bnc" id="L3183" title="All 2 branches missed.">                if (obj == null)</span>
<span class="nc" id="L3184">                    continue;</span>

                try {
<span class="nc" id="L3187">                    sm = getStateManagerImpl(obj, true);</span>
<span class="nc bnc" id="L3188" title="All 2 branches missed.">                    if ((processArgument(OpCallbacks.OP_REFRESH, obj, sm, call)</span>
                        &amp; OpCallbacks.ACT_RUN) == 0)
<span class="nc" id="L3190">                        continue;</span>

<span class="nc bnc" id="L3192" title="All 2 branches missed.">                    if (sm != null) {</span>
<span class="nc bnc" id="L3193" title="All 2 branches missed.">                        if (sm.isDetached())</span>
<span class="nc" id="L3194">                            throw newDetachedException(obj, &quot;refresh&quot;);</span>
<span class="nc bnc" id="L3195" title="All 2 branches missed.">                        else if (sm.beforeRefresh(true)) {</span>
<span class="nc bnc" id="L3196" title="All 2 branches missed.">                        	if (load == null)</span>
<span class="nc" id="L3197">                        		load = new ArrayList&lt;&gt;(objs.size());</span>
<span class="nc" id="L3198">                            load.add(sm);</span>
                        }
<span class="nc" id="L3200">                        int level = _fc.getReadLockLevel();</span>
<span class="nc" id="L3201">                        int timeout = _fc.getLockTimeout();</span>
<span class="nc" id="L3202">                        _lm.refreshLock(sm, level, timeout, null);</span>
<span class="nc" id="L3203">                        sm.readLocked(level, level);</span>
<span class="nc bnc" id="L3204" title="All 2 branches missed.">                    } else if (assertPersistenceCapable(obj).pcIsDetached()</span>
                        == Boolean.TRUE)
<span class="nc" id="L3206">                        throw newDetachedException(obj, &quot;refresh&quot;);</span>
<span class="nc" id="L3207">                } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3208">                    exceps = add(exceps, ke);</span>
<span class="nc" id="L3209">                }</span>
            }

            // refresh all
<span class="nc bnc" id="L3213" title="All 2 branches missed.">            if (load != null) {</span>
<span class="nc" id="L3214">                Collection&lt;Object&gt; failed = _store.loadAll(load, null,</span>
                    StoreManager.FORCE_LOAD_REFRESH, _fc, null);
<span class="nc bnc" id="L3216" title="All 4 branches missed.">                if (failed != null &amp;&amp; !failed.isEmpty())</span>
<span class="nc" id="L3217">                    exceps = add(exceps, newObjectNotFoundException(failed));</span>

                // perform post-refresh transitions and make sure all fetch
                // group fields are loaded
<span class="nc bnc" id="L3221" title="All 2 branches missed.">                for (Iterator&lt;OpenJPAStateManager&gt; itr = load.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L3222">                    sm = (StateManagerImpl) itr.next();</span>
<span class="nc bnc" id="L3223" title="All 4 branches missed.">                    if (failed != null &amp;&amp; failed.contains(sm.getId()))</span>
<span class="nc" id="L3224">                        continue;</span>

                    try {
<span class="nc" id="L3227">                        sm.afterRefresh();</span>
<span class="nc" id="L3228">                        sm.load(_fc, StateManagerImpl.LOAD_FGS, null, null,</span>
                            false);
<span class="nc" id="L3230">                    } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3231">                        exceps = add(exceps, ke);</span>
<span class="nc" id="L3232">                    }</span>
                }
            }

            // now invoke postRefresh on all the instances
<span class="nc bnc" id="L3237" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = objs.iterator(); itr.hasNext();) {</span>
                try {
<span class="nc" id="L3239">                    sm = getStateManagerImpl(itr.next(), true);</span>
<span class="nc bnc" id="L3240" title="All 4 branches missed.">                    if (sm != null &amp;&amp; !sm.isDetached())</span>
<span class="nc" id="L3241">                        fireLifecycleEvent(sm.getManagedInstance(), null,</span>
<span class="nc" id="L3242">                            sm.getMetaData(), LifecycleEvent.AFTER_REFRESH);</span>
<span class="nc" id="L3243">                } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3244">                    exceps = add(exceps, ke);</span>
<span class="nc" id="L3245">                }</span>
            }
<span class="nc" id="L3247">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3248">            throw ke;</span>
<span class="nc" id="L3249">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3250">            throw new GeneralException(re);</span>
<span class="nc" id="L3251">        }</span>
<span class="nc" id="L3252">        throwNestedExceptions(exceps, false);</span>
<span class="nc" id="L3253">    }</span>

    /**
     * Optimization for single-object refresh.
     */
    protected void refreshInternal(Object obj, OpCallbacks call) {
        try {
<span class="nc" id="L3260">            StateManagerImpl sm = getStateManagerImpl(obj, true);</span>
<span class="nc bnc" id="L3261" title="All 2 branches missed.">            if ((processArgument(OpCallbacks.OP_REFRESH, obj, sm, call)</span>
                &amp; OpCallbacks.ACT_RUN) == 0)
<span class="nc" id="L3263">                return;</span>

<span class="nc bnc" id="L3265" title="All 2 branches missed.">            if (sm != null) {</span>
<span class="nc bnc" id="L3266" title="All 2 branches missed.">                if (sm.isDetached())</span>
<span class="nc" id="L3267">                    throw newDetachedException(obj, &quot;refresh&quot;);</span>
<span class="nc bnc" id="L3268" title="All 2 branches missed.">                else if (sm.beforeRefresh(false)) {</span>
<span class="nc" id="L3269">                    sm.load(_fc, StateManagerImpl.LOAD_FGS, null, null, false);</span>
<span class="nc" id="L3270">                    sm.afterRefresh();</span>
                }
<span class="nc" id="L3272">                int level = _fc.getReadLockLevel();</span>
<span class="nc" id="L3273">                int timeout = _fc.getLockTimeout();</span>
<span class="nc" id="L3274">                _lm.refreshLock(sm, level, timeout, null);</span>
<span class="nc" id="L3275">                sm.readLocked(level, level);</span>
<span class="nc" id="L3276">                fireLifecycleEvent(sm.getManagedInstance(), null,</span>
<span class="nc" id="L3277">                    sm.getMetaData(), LifecycleEvent.AFTER_REFRESH);</span>
<span class="nc bnc" id="L3278" title="All 2 branches missed.">            } else if (assertPersistenceCapable(obj).pcIsDetached()</span>
                == Boolean.TRUE)
<span class="nc" id="L3280">                throw newDetachedException(obj, &quot;refresh&quot;);</span>
<span class="nc" id="L3281">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3282">            throw ke;</span>
<span class="nc" id="L3283">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3284">            throw new GeneralException(re);</span>
<span class="nc" id="L3285">        }</span>
<span class="nc" id="L3286">    }</span>


    @Override
    public void retrieveAll(Collection objs, boolean dfgOnly,
        OpCallbacks call) {
<span class="nc bnc" id="L3292" title="All 4 branches missed.">        if (objs == null || objs.isEmpty())</span>
<span class="nc" id="L3293">            return;</span>
<span class="nc bnc" id="L3294" title="All 2 branches missed.">        if (objs.size() == 1) {</span>
<span class="nc" id="L3295">            retrieve(objs.iterator().next(), dfgOnly, call);</span>
<span class="nc" id="L3296">            return;</span>
        }

<span class="nc" id="L3299">        List&lt;Exception&gt; exceps = null;</span>
<span class="nc" id="L3300">        beginOperation(true);</span>
        try {
<span class="nc" id="L3302">            assertOpen();</span>
<span class="nc" id="L3303">            assertNontransactionalRead();</span>

            // collect all hollow instances for load
            Object obj;
<span class="nc" id="L3307">            Collection&lt;OpenJPAStateManager&gt; load = null;</span>
            StateManagerImpl sm;
<span class="nc" id="L3309">            Collection&lt;StateManagerImpl&gt; sms = new ArrayList&lt;&gt;(objs.size());</span>
<span class="nc bnc" id="L3310" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = objs.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L3311">                obj = itr.next();</span>
<span class="nc bnc" id="L3312" title="All 2 branches missed.">                if (obj == null)</span>
<span class="nc" id="L3313">                    continue;</span>

                try {
<span class="nc" id="L3316">                    sm = getStateManagerImpl(obj, true);</span>
<span class="nc bnc" id="L3317" title="All 2 branches missed.">                    if ((processArgument(OpCallbacks.OP_RETRIEVE, obj, sm, call)</span>
                        &amp; OpCallbacks.ACT_RUN) == 0)
<span class="nc" id="L3319">                        continue;</span>

<span class="nc bnc" id="L3321" title="All 2 branches missed.">                    if (sm != null) {</span>
<span class="nc bnc" id="L3322" title="All 2 branches missed.">                        if (sm.isDetached())</span>
<span class="nc" id="L3323">                            throw newDetachedException(obj, &quot;retrieve&quot;);</span>
<span class="nc bnc" id="L3324" title="All 2 branches missed.">                        if (sm.isPersistent()) {</span>
<span class="nc" id="L3325">                            sms.add(sm);</span>
<span class="nc bnc" id="L3326" title="All 2 branches missed.">                            if (sm.getPCState() == PCState.HOLLOW) {</span>
<span class="nc bnc" id="L3327" title="All 2 branches missed.">                                if (load == null)</span>
<span class="nc" id="L3328">                                    load = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3329">                                load.add(sm);</span>
                            }
                        }
<span class="nc bnc" id="L3332" title="All 2 branches missed.">                    } else if (assertPersistenceCapable(obj).pcIsDetached()</span>
                        == Boolean.TRUE)
<span class="nc" id="L3334">                        throw newDetachedException(obj, &quot;retrieve&quot;);</span>
<span class="nc" id="L3335">                } catch (UserException ue) {</span>
<span class="nc" id="L3336">                    exceps = add(exceps, ue);</span>
<span class="nc" id="L3337">                }</span>
            }

            // load all hollow instances
<span class="nc" id="L3341">            Collection&lt;Object&gt; failed = null;</span>
<span class="nc bnc" id="L3342" title="All 2 branches missed.">            if (load != null) {</span>
<span class="nc bnc" id="L3343" title="All 2 branches missed.">                int mode = (dfgOnly) ? StoreManager.FORCE_LOAD_DFG</span>
<span class="nc" id="L3344">                    : StoreManager.FORCE_LOAD_ALL;</span>
<span class="nc" id="L3345">                failed = _store.loadAll(load, null, mode, _fc, null);</span>
<span class="nc bnc" id="L3346" title="All 4 branches missed.">                if (failed != null &amp;&amp; !failed.isEmpty())</span>
<span class="nc" id="L3347">                    exceps = add(exceps, newObjectNotFoundException(failed));</span>
            }

            // retrieve all non-failed instances
<span class="nc bnc" id="L3351" title="All 2 branches missed.">            for (Iterator&lt;StateManagerImpl&gt; itr = sms.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L3352">                sm = itr.next();</span>
<span class="nc bnc" id="L3353" title="All 4 branches missed.">                if (failed != null &amp;&amp; failed.contains(sm.getId()))</span>
<span class="nc" id="L3354">                    continue;</span>

<span class="nc bnc" id="L3356" title="All 2 branches missed.">                int mode = (dfgOnly) ? StateManagerImpl.LOAD_FGS</span>
<span class="nc" id="L3357">                    : StateManagerImpl.LOAD_ALL;</span>
                try {
<span class="nc" id="L3359">                    sm.beforeRead(-1);</span>
<span class="nc" id="L3360">                    sm.load(_fc, mode, null, null, false);</span>
<span class="nc" id="L3361">                } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3362">                    exceps = add(exceps, ke);</span>
<span class="nc" id="L3363">                }</span>
<span class="nc" id="L3364">            }</span>
<span class="nc" id="L3365">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3366">            throw ke;</span>
<span class="nc" id="L3367">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3368">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L3370">            endOperation();</span>
        }
<span class="nc" id="L3372">        throwNestedExceptions(exceps, false);</span>
<span class="nc" id="L3373">    }</span>

    @Override
    public void retrieve(Object obj, boolean dfgOnly, OpCallbacks call) {
<span class="nc bnc" id="L3377" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L3378">            return;</span>

<span class="nc" id="L3380">        beginOperation(true);</span>
        try {
<span class="nc" id="L3382">            assertOpen();</span>
<span class="nc" id="L3383">            assertNontransactionalRead();</span>

<span class="nc" id="L3385">            StateManagerImpl sm = getStateManagerImpl(obj, true);</span>
<span class="nc bnc" id="L3386" title="All 2 branches missed.">            if ((processArgument(OpCallbacks.OP_RETRIEVE, obj, sm, call)</span>
                &amp; OpCallbacks.ACT_RUN) == 0)
<span class="nc" id="L3388">                return;</span>

<span class="nc bnc" id="L3390" title="All 2 branches missed.">            if (sm != null) {</span>
<span class="nc bnc" id="L3391" title="All 2 branches missed.">                if (sm.isDetached())</span>
<span class="nc" id="L3392">                    throw newDetachedException(obj, &quot;retrieve&quot;);</span>
<span class="nc bnc" id="L3393" title="All 2 branches missed.">                if (sm.isPersistent()) {</span>
<span class="nc bnc" id="L3394" title="All 2 branches missed.">                    int mode = (dfgOnly) ? StateManagerImpl.LOAD_FGS</span>
<span class="nc" id="L3395">                        : StateManagerImpl.LOAD_ALL;</span>
<span class="nc" id="L3396">                    sm.beforeRead(-1);</span>
<span class="nc" id="L3397">                    sm.load(_fc, mode, null, null, false);</span>
<span class="nc" id="L3398">                }</span>
<span class="nc bnc" id="L3399" title="All 2 branches missed.">            } else if (assertPersistenceCapable(obj).pcIsDetached()</span>
                == Boolean.TRUE)
<span class="nc" id="L3401">                throw newDetachedException(obj, &quot;retrieve&quot;);</span>
<span class="nc" id="L3402">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3403">            throw ke;</span>
<span class="nc" id="L3404">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3405">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L3407">            endOperation();</span>
        }
<span class="nc" id="L3409">    }</span>

    @Override
    public void evictAll(OpCallbacks call) {
<span class="nc" id="L3413">        beginOperation(false);</span>
        try {
            // evict all PClean and PNonTrans objects
<span class="nc" id="L3416">            Collection&lt;StateManagerImpl&gt; c = getManagedStates();</span>
            StateManagerImpl sm;
<span class="nc bnc" id="L3418" title="All 2 branches missed.">            for (Iterator&lt;StateManagerImpl&gt; itr = c.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L3419">                sm = itr.next();</span>
<span class="nc bnc" id="L3420" title="All 4 branches missed.">                if (sm.isPersistent() &amp;&amp; !sm.isDirty())</span>
<span class="nc" id="L3421">                    evict(sm.getManagedInstance(), call);</span>
            }
        }
        finally {
<span class="nc" id="L3425">            endOperation();</span>
        }
<span class="nc" id="L3427">    }</span>

    @Override
    public void evictAll(Collection objs, OpCallbacks call) {
<span class="nc" id="L3431">        List&lt;Exception&gt; exceps = null;</span>
<span class="nc" id="L3432">        beginOperation(false);</span>
        try {
<span class="nc bnc" id="L3434" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = objs.iterator(); itr.hasNext();) {</span>
                try {
<span class="nc" id="L3436">                    evict(itr.next(), call);</span>
<span class="nc" id="L3437">                } catch (UserException ue) {</span>
<span class="nc" id="L3438">                    exceps = add(exceps, ue);</span>
<span class="nc" id="L3439">                }</span>
            }
        } finally {
<span class="nc" id="L3442">            endOperation();</span>
        }
<span class="nc" id="L3444">        throwNestedExceptions(exceps, false);</span>
<span class="nc" id="L3445">    }</span>

    @Override
    public void evictAll(Extent extent, OpCallbacks call) {
<span class="nc bnc" id="L3449" title="All 2 branches missed.">        if (extent == null)</span>
<span class="nc" id="L3450">            return;</span>

<span class="nc" id="L3452">        beginOperation(false);</span>
        try {
            // evict all PClean and PNonTrans objects in extent
<span class="nc" id="L3455">            Collection&lt;StateManagerImpl&gt; c = getManagedStates();</span>
            StateManagerImpl sm;
            Class&lt;?&gt; cls;
<span class="nc bnc" id="L3458" title="All 2 branches missed.">            for (Iterator&lt;StateManagerImpl&gt; itr = c.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L3459">                sm = itr.next();</span>
<span class="nc bnc" id="L3460" title="All 4 branches missed.">                if (sm.isPersistent() &amp;&amp; !sm.isDirty()) {</span>
<span class="nc" id="L3461">                    cls = sm.getMetaData().getDescribedType();</span>
<span class="nc bnc" id="L3462" title="All 2 branches missed.">                    if (cls == extent.getElementType()</span>
<span class="nc bnc" id="L3463" title="All 2 branches missed.">                        || (extent.hasSubclasses()</span>
<span class="nc bnc" id="L3464" title="All 2 branches missed.">                        &amp;&amp; extent.getElementType().isAssignableFrom(cls)))</span>
<span class="nc" id="L3465">                        evict(sm.getManagedInstance(), call);</span>
                }
            }
        } finally {
<span class="nc" id="L3469">            endOperation();</span>
        }
<span class="nc" id="L3471">    }</span>

    @Override
    public void evict(Object obj, OpCallbacks call) {
<span class="nc bnc" id="L3475" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L3476">            return;</span>

<span class="nc" id="L3478">        beginOperation(false);</span>
        try {
<span class="nc" id="L3480">            StateManagerImpl sm = getStateManagerImpl(obj, true);</span>
<span class="nc bnc" id="L3481" title="All 2 branches missed.">            if ((processArgument(OpCallbacks.OP_EVICT, obj, sm, call)</span>
                &amp; OpCallbacks.ACT_RUN) == 0)
<span class="nc" id="L3483">                return;</span>
<span class="nc bnc" id="L3484" title="All 2 branches missed.">            if (sm == null)</span>
<span class="nc" id="L3485">                return;</span>

<span class="nc" id="L3487">            sm.evict();</span>
<span class="nc bnc" id="L3488" title="All 4 branches missed.">            if (_evictDataCache &amp;&amp; sm.getObjectId() != null) {</span>
<span class="nc" id="L3489">                DataCache cache = _conf.getDataCacheManagerInstance().selectCache(sm);</span>
<span class="nc bnc" id="L3490" title="All 2 branches missed.">                if (cache != null)</span>
<span class="nc" id="L3491">                    cache.remove(sm.getObjectId());</span>
            }
        }
<span class="nc" id="L3494">        catch (OpenJPAException ke) {</span>
<span class="nc" id="L3495">            throw ke;</span>
<span class="nc" id="L3496">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3497">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L3499">            endOperation();</span>
        }
<span class="nc" id="L3501">    }</span>

    @Override
    public Object detach(Object obj, OpCallbacks call) {
<span class="nc bnc" id="L3505" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L3506">            return null;</span>
<span class="nc bnc" id="L3507" title="All 2 branches missed.">        if (call == null)</span>
<span class="nc" id="L3508">            call = _call;</span>

<span class="nc" id="L3510">        beginOperation(true);</span>
        try {
<span class="nc" id="L3512">            return new DetachManager(this, false, call).detach(obj);</span>
<span class="nc" id="L3513">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3514">            throw ke;</span>
<span class="nc" id="L3515">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3516">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L3518">            endOperation();</span>
        }
    }

    @Override
    public Object[] detachAll(Collection objs, OpCallbacks call) {
<span class="nc bnc" id="L3524" title="All 2 branches missed.">        if (objs == null)</span>
<span class="nc" id="L3525">            return null;</span>
<span class="nc bnc" id="L3526" title="All 2 branches missed.">        if (objs.isEmpty())</span>
<span class="nc" id="L3527">            return EMPTY_OBJECTS;</span>
<span class="nc bnc" id="L3528" title="All 2 branches missed.">        if (call == null)</span>
<span class="nc" id="L3529">            call = _call;</span>

<span class="nc" id="L3531">        beginOperation(true);</span>
        try {
<span class="nc" id="L3533">            return new DetachManager(this, false, call).detachAll(objs);</span>
<span class="nc" id="L3534">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3535">            throw ke;</span>
<span class="nc" id="L3536">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3537">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L3539">            endOperation();</span>
        }
    }

    @Override
    public void detachAll(OpCallbacks call) {
<span class="nc" id="L3545">        detachAll(call, true);</span>
<span class="nc" id="L3546">    }</span>

    @Override
    public void detachAll(OpCallbacks call, boolean flush) {
<span class="nc" id="L3550">        beginOperation(true);</span>
        try {
            // If a flush is desired (based on input parm), then check if the
            // &quot;dirty&quot; flag is set before calling flush().
<span class="nc bnc" id="L3554" title="All 4 branches missed.">            if (flush &amp;&amp; (_flags &amp; FLAG_FLUSH_REQUIRED) != 0)</span>
<span class="nc" id="L3555">                flush();</span>
<span class="nc" id="L3556">            detachAllInternal(call);</span>
<span class="nc" id="L3557">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3558">            throw ke;</span>
<span class="nc" id="L3559">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3560">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L3562">            endOperation();</span>
        }
<span class="nc" id="L3564">    }</span>

    private void detachAllInternal(OpCallbacks call) {
<span class="nc bnc" id="L3567" title="All 2 branches missed.">        if(_conf.getDetachStateInstance().getLiteAutoDetach() == true){</span>
<span class="nc" id="L3568">            detachAllInternalLite();</span>
<span class="nc" id="L3569">            return;</span>
        }
<span class="nc" id="L3571">        Collection&lt;StateManagerImpl&gt; states = getManagedStates();</span>
        StateManagerImpl sm;
<span class="nc bnc" id="L3573" title="All 2 branches missed.">        for (Iterator&lt;StateManagerImpl&gt; itr = states.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L3574">            sm = itr.next();</span>
<span class="nc bnc" id="L3575" title="All 2 branches missed.">            if (!sm.isPersistent())</span>
<span class="nc" id="L3576">                itr.remove();</span>
<span class="nc bnc" id="L3577" title="All 2 branches missed.">            else if (!sm.getMetaData().isDetachable()) {</span>
<span class="nc" id="L3578">                sm.release(true);</span>
<span class="nc" id="L3579">                itr.remove();</span>
            }
        }
<span class="nc bnc" id="L3582" title="All 2 branches missed.">        if (states.isEmpty())</span>
<span class="nc" id="L3583">            return;</span>

<span class="nc bnc" id="L3585" title="All 2 branches missed.">        if (call == null)</span>
<span class="nc" id="L3586">            call = _call;</span>
        // Make sure ALL entities are detached, even new ones that are loaded
        // during the detach processing
<span class="nc" id="L3589">        boolean origCascade = _compat.getCascadeWithDetach();</span>
<span class="nc" id="L3590">        _compat.setCascadeWithDetach(true);</span>
        try {
<span class="nc" id="L3592">            new DetachManager(this, true, call)</span>
<span class="nc" id="L3593">                .detachAll(new ManagedObjectCollection(states));</span>
        }
        finally {
<span class="nc" id="L3596">            _compat.setCascadeWithDetach(origCascade);</span>
        }
<span class="nc" id="L3598">    }</span>

    private void detachAllInternalLite() {
<span class="nc" id="L3601">        ManagedCache old = _cache;</span>
<span class="nc" id="L3602">        _cache = new ManagedCache(this);</span>
        // TODO : should I call clear on old cache first? perhaps a memory leak?
<span class="nc" id="L3604">        Collection&lt;StateManagerImpl&gt; states = old.copy();</span>

        // Clear out all persistence context caches.
<span class="nc bnc" id="L3607" title="All 2 branches missed.">        if (_transCache != null) {</span>
<span class="nc" id="L3608">            _transCache.clear();</span>
        }
<span class="nc bnc" id="L3610" title="All 2 branches missed.">        if (_transAdditions != null) {</span>
<span class="nc" id="L3611">            _transAdditions.clear();</span>
        }
<span class="nc bnc" id="L3613" title="All 2 branches missed.">        if (_pending != null) {</span>
<span class="nc" id="L3614">            _pending = null;</span>
        }
<span class="nc bnc" id="L3616" title="All 2 branches missed.">        if (_dmLite == null) {</span>
<span class="nc" id="L3617">            _dmLite = new DetachManagerLite(_conf);</span>
        }
<span class="nc" id="L3619">        _dmLite.detachAll(states);</span>
<span class="nc" id="L3620">    }</span>
    @Override
    public Object attach(Object obj, boolean copyNew, OpCallbacks call) {
<span class="nc bnc" id="L3623" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L3624">            return null;</span>

<span class="nc" id="L3626">        beginOperation(true);</span>
        try {
            // make sure not to try to set rollback only if this fails
<span class="nc" id="L3629">            assertWriteOperation();</span>
            try {
<span class="nc" id="L3631">                return new AttachManager(this, copyNew, call).attach(obj);</span>
<span class="nc" id="L3632">            } catch (OptimisticException oe) {</span>
<span class="nc" id="L3633">                setRollbackOnly(oe);</span>
<span class="nc" id="L3634">                throw oe.setFatal(true);</span>
<span class="nc" id="L3635">            } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3636">                throw ke;</span>
<span class="nc" id="L3637">            } catch (RuntimeException re) {</span>
<span class="nc" id="L3638">                throw new GeneralException(re);</span>
            }
        }
        finally {
<span class="nc" id="L3642">            endOperation();</span>
        }
    }

    @Override
    public Object[] attachAll(Collection objs, boolean copyNew,
        OpCallbacks call) {
<span class="nc bnc" id="L3649" title="All 2 branches missed.">        if (objs == null)</span>
<span class="nc" id="L3650">            return null;</span>
<span class="nc bnc" id="L3651" title="All 2 branches missed.">        if (objs.isEmpty())</span>
<span class="nc" id="L3652">            return EMPTY_OBJECTS;</span>

<span class="nc" id="L3654">        beginOperation(true);</span>
        try {
            // make sure not to try to set rollback only if this fails
<span class="nc" id="L3657">            assertWriteOperation();</span>
            try {
<span class="nc" id="L3659">                return new AttachManager(this, copyNew, call).attachAll(objs);</span>
<span class="nc" id="L3660">            } catch (OptimisticException oe) {</span>
<span class="nc" id="L3661">                setRollbackOnly(oe);</span>
<span class="nc" id="L3662">                throw oe.setFatal(true);</span>
<span class="nc" id="L3663">            } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3664">                throw ke;</span>
<span class="nc" id="L3665">            } catch (RuntimeException re) {</span>
<span class="nc" id="L3666">                throw new GeneralException(re);</span>
            }
        }
        finally {
<span class="nc" id="L3670">            endOperation();</span>
        }
    }

    @Override
    public void nontransactionalAll(Collection objs, OpCallbacks call) {
<span class="nc" id="L3676">        beginOperation(true);</span>
        try {
<span class="nc" id="L3678">            List&lt;Exception&gt; exceps = null;</span>
<span class="nc bnc" id="L3679" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = objs.iterator(); itr.hasNext();) {</span>
                try {
<span class="nc" id="L3681">                    nontransactional(itr.next(), call);</span>
<span class="nc" id="L3682">                } catch (UserException ue) {</span>
<span class="nc" id="L3683">                    exceps = add(exceps, ue);</span>
<span class="nc" id="L3684">                }</span>
            }
<span class="nc" id="L3686">            throwNestedExceptions(exceps, false);</span>
        } finally {
<span class="nc" id="L3688">            endOperation();</span>
        }
<span class="nc" id="L3690">    }</span>

    @Override
    public void nontransactional(Object obj, OpCallbacks call) {
<span class="nc bnc" id="L3694" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L3695">            return;</span>

<span class="nc" id="L3697">        beginOperation(true);</span>
        try {
<span class="nc" id="L3699">            StateManagerImpl sm = getStateManagerImpl(obj, true);</span>
<span class="nc bnc" id="L3700" title="All 2 branches missed.">            if ((processArgument(OpCallbacks.OP_NONTRANSACTIONAL, obj, sm, call)</span>
                &amp; OpCallbacks.ACT_RUN) == 0)
<span class="nc" id="L3702">                return;</span>
<span class="nc bnc" id="L3703" title="All 2 branches missed.">            if (sm != null)</span>
<span class="nc" id="L3704">                sm.nontransactional();</span>
<span class="nc" id="L3705">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3706">            throw ke;</span>
<span class="nc" id="L3707">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3708">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L3710">            endOperation();</span>
        }
<span class="nc" id="L3712">    }</span>

    /**
     * Make the given instances transactional.
     */
    @Override
    public void transactionalAll(Collection objs, boolean updateVersion,
        OpCallbacks call) {
<span class="nc bnc" id="L3720" title="All 2 branches missed.">        if (objs.isEmpty())</span>
<span class="nc" id="L3721">            return;</span>
<span class="nc bnc" id="L3722" title="All 2 branches missed.">        if (objs.size() == 1) {</span>
<span class="nc" id="L3723">            transactional(objs.iterator().next(), updateVersion, call);</span>
<span class="nc" id="L3724">            return;</span>
        }

<span class="nc" id="L3727">        beginOperation(true);</span>
        try {
            // collect all hollow instances for load, and make unmananged
            // instances transient-transactional
<span class="nc" id="L3731">            Collection&lt;OpenJPAStateManager&gt; load = null;</span>
            Object obj;
            StateManagerImpl sm;
            ClassMetaData meta;
<span class="nc" id="L3735">            Collection&lt;StateManagerImpl&gt; sms = new LinkedHashSet&lt;&gt;(objs.size());</span>
<span class="nc" id="L3736">            List&lt;Exception&gt; exceps = null;</span>
<span class="nc bnc" id="L3737" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = objs.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L3738">                obj = itr.next();</span>
<span class="nc bnc" id="L3739" title="All 2 branches missed.">                if (obj == null)</span>
<span class="nc" id="L3740">                    continue;</span>

                try {
<span class="nc" id="L3743">                    sm = getStateManagerImpl(obj, true);</span>
<span class="nc bnc" id="L3744" title="All 2 branches missed.">                    if ((processArgument(OpCallbacks.OP_TRANSACTIONAL, obj, sm,</span>
                        call) &amp; OpCallbacks.ACT_RUN) == 0)
<span class="nc" id="L3746">                        continue;</span>

<span class="nc bnc" id="L3748" title="All 2 branches missed.">                    if (sm == null) {</span>
                        // manage transient instance
<span class="nc" id="L3750">                        meta = _repo.getMetaData(obj.getClass(), _loader, true);</span>

<span class="nc" id="L3752">                        sm = newStateManagerImpl</span>
<span class="nc" id="L3753">                            (StateManagerId.newInstance(this), meta);</span>
<span class="nc" id="L3754">                        sm.initialize(assertPersistenceCapable(obj),</span>
                            PCState.TCLEAN);
<span class="nc bnc" id="L3756" title="All 2 branches missed.">                    } else if (sm.isPersistent()) {</span>
<span class="nc" id="L3757">                        assertActiveTransaction();</span>
<span class="nc" id="L3758">                        sms.add(sm);</span>
<span class="nc bnc" id="L3759" title="All 2 branches missed.">                        if (sm.getPCState() == PCState.HOLLOW) {</span>
<span class="nc bnc" id="L3760" title="All 2 branches missed.">                            if (load == null)</span>
<span class="nc" id="L3761">                                load = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3762">                            load.add(sm);</span>
                        }

<span class="nc" id="L3765">                        sm.setCheckVersion(true);</span>
<span class="nc bnc" id="L3766" title="All 2 branches missed.">                        if (updateVersion)</span>
<span class="nc" id="L3767">                            sm.setUpdateVersion(true);</span>
<span class="nc" id="L3768">                        _flags |= FLAG_FLUSH_REQUIRED; // version check/up</span>
                    }
                }
<span class="nc" id="L3771">                catch (UserException ue) {</span>
<span class="nc" id="L3772">                    exceps = add(exceps, ue);</span>
<span class="nc" id="L3773">                }</span>
            }

            // load all hollow instances
<span class="nc" id="L3777">            Collection&lt;Object&gt; failed = null;</span>
<span class="nc bnc" id="L3778" title="All 2 branches missed.">            if (load != null) {</span>
<span class="nc" id="L3779">                failed = _store.loadAll(load, null, StoreManager.FORCE_LOAD_NONE,</span>
                    _fc, null);
<span class="nc bnc" id="L3781" title="All 4 branches missed.">                if (failed != null &amp;&amp; !failed.isEmpty())</span>
<span class="nc" id="L3782">                    exceps = add(exceps,</span>
<span class="nc" id="L3783">                        newObjectNotFoundException(failed));</span>
            }

<span class="nc" id="L3786">            transactionalStatesAll(sms, failed, exceps);</span>
<span class="nc" id="L3787">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3788">            throw ke;</span>
<span class="nc" id="L3789">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3790">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L3792">            endOperation();</span>
        }
<span class="nc" id="L3794">    }</span>

    /**
     * Make the given instances transactional.
     */
    @Override
    public void transactional(Object obj, boolean updateVersion,
        OpCallbacks call) {
<span class="nc bnc" id="L3802" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L3803">            return;</span>

<span class="nc" id="L3805">        beginOperation(true);</span>
        try {
<span class="nc" id="L3807">            StateManagerImpl sm = getStateManagerImpl(obj, true);</span>
<span class="nc bnc" id="L3808" title="All 2 branches missed.">            if ((processArgument(OpCallbacks.OP_TRANSACTIONAL, obj, sm, call)</span>
                &amp; OpCallbacks.ACT_RUN) == 0)
<span class="nc" id="L3810">                return;</span>

<span class="nc bnc" id="L3812" title="All 4 branches missed.">            if (sm != null &amp;&amp; sm.isPersistent()) {</span>
<span class="nc" id="L3813">                assertActiveTransaction();</span>
<span class="nc" id="L3814">                sm.transactional();</span>
<span class="nc" id="L3815">                sm.load(_fc, StateManagerImpl.LOAD_FGS, null, null, false);</span>
<span class="nc" id="L3816">                sm.setCheckVersion(true);</span>
<span class="nc bnc" id="L3817" title="All 2 branches missed.">                if (updateVersion)</span>
<span class="nc" id="L3818">                    sm.setUpdateVersion(true);</span>
<span class="nc" id="L3819">                _flags |= FLAG_FLUSH_REQUIRED; // version check/up</span>
<span class="nc bnc" id="L3820" title="All 2 branches missed.">            } else if (sm == null) {</span>
                // manage transient instance
<span class="nc" id="L3822">                ClassMetaData meta = _repo.getMetaData(obj.getClass(), _loader, true);</span>
<span class="nc" id="L3823">                Object id = StateManagerId.newInstance(this);</span>
<span class="nc" id="L3824">                sm = newStateManagerImpl(id, meta);</span>
<span class="nc" id="L3825">                sm.initialize(assertPersistenceCapable(obj),</span>
                    PCState.TCLEAN);
            }
        }
<span class="nc" id="L3829">        catch (OpenJPAException ke) {</span>
<span class="nc" id="L3830">            throw ke;</span>
<span class="nc" id="L3831">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3832">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L3834">            endOperation();</span>
        }
<span class="nc" id="L3836">    }</span>

    /**
     * Transition the given state managers to transactional.
     */
    private void transactionalStatesAll(Collection sms, Collection failed,
        List&lt;Exception&gt; exceps) {
        // make instances transactional and make sure they are loaded
        StateManagerImpl sm;
<span class="nc bnc" id="L3845" title="All 2 branches missed.">        for (Iterator&lt;?&gt; itr = sms.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L3846">            sm = (StateManagerImpl) itr.next();</span>
<span class="nc bnc" id="L3847" title="All 4 branches missed.">            if (failed != null &amp;&amp; failed.contains(sm.getId()))</span>
<span class="nc" id="L3848">                continue;</span>

            try {
<span class="nc" id="L3851">                sm.transactional();</span>
<span class="nc" id="L3852">                sm.load(_fc, StateManagerImpl.LOAD_FGS, null, null, false);</span>
<span class="nc" id="L3853">            } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3854">                exceps = add(exceps, ke);</span>
<span class="nc" id="L3855">            }</span>
        }
<span class="nc" id="L3857">        throwNestedExceptions(exceps, false);</span>
<span class="nc" id="L3858">    }</span>

    /////////////////
    // Extent, Query
    /////////////////

    @Override
    public Extent newExtent(Class type, boolean subclasses) {
<span class="nc" id="L3866">        return newExtent(type, subclasses, null);</span>
    }

    private Extent newExtent(Class type, boolean subclasses,
        FetchConfiguration fetch) {
<span class="nc" id="L3871">        beginOperation(true);</span>
        try {
<span class="nc" id="L3873">            ExtentImpl extent = new ExtentImpl(this, type, subclasses, fetch);</span>
<span class="nc bnc" id="L3874" title="All 2 branches missed.">            if (_extents == null)</span>
<span class="nc" id="L3875">                _extents = new ReferenceHashSet(ReferenceStrength.WEAK);</span>
<span class="nc" id="L3876">            _extents.add(extent);</span>

<span class="nc" id="L3878">            return extent;</span>
<span class="nc" id="L3879">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3880">            throw ke;</span>
<span class="nc" id="L3881">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3882">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L3884">            endOperation();</span>
        }
    }

    @Override
    public Iterator extentIterator(Class type, boolean subclasses,
        FetchConfiguration fetch, boolean ignoreChanges) {
<span class="nc" id="L3891">        Extent extent = newExtent(type, subclasses, fetch);</span>
<span class="nc" id="L3892">        extent.setIgnoreChanges(ignoreChanges);</span>
<span class="nc" id="L3893">        return extent.iterator();</span>
    }

    @Override
    public Query newQuery(String lang, Class cls, Object query) {
<span class="nc" id="L3898">        Query q = newQuery(lang, query);</span>
<span class="nc" id="L3899">        q.setCandidateType(cls, true);</span>
<span class="nc" id="L3900">        return q;</span>
    }

    @Override
    public Query newQuery(String lang, Object query) {
        // common mistakes
<span class="nc bnc" id="L3906" title="All 4 branches missed.">        if (query instanceof Extent || query instanceof Class)</span>
<span class="nc" id="L3907">            throw new UserException(_loc.get(&quot;bad-new-query&quot;));</span>

<span class="nc" id="L3909">        beginOperation(false);</span>
        try {
<span class="nc" id="L3911">            StoreQuery sq = _store.newQuery(lang);</span>
<span class="nc bnc" id="L3912" title="All 2 branches missed.">            if (sq == null) {</span>
<span class="nc" id="L3913">                ExpressionParser ep = QueryLanguages.parserForLanguage(lang);</span>
<span class="nc bnc" id="L3914" title="All 2 branches missed.">                if (ep != null)</span>
<span class="nc" id="L3915">                    sq = new ExpressionStoreQuery(ep);</span>
<span class="nc bnc" id="L3916" title="All 2 branches missed.">                else if (QueryLanguages.LANG_METHODQL.equals(lang))</span>
<span class="nc" id="L3917">                    sq = new MethodStoreQuery();</span>
                else
<span class="nc" id="L3919">                    throw new UnsupportedException(lang);</span>
            }

<span class="nc" id="L3922">            Query q = newQueryImpl(lang, sq);</span>
<span class="nc" id="L3923">            q.setIgnoreChanges(_ignoreChanges);</span>
<span class="nc bnc" id="L3924" title="All 2 branches missed.">            if (query != null)</span>
<span class="nc" id="L3925">                q.setQuery(query);</span>

            // track queries
<span class="nc bnc" id="L3928" title="All 2 branches missed.">            if (_queries == null)</span>
<span class="nc" id="L3929">                _queries = new ReferenceHashSet(ReferenceStrength.WEAK);</span>
<span class="nc" id="L3930">            _queries.add(q);</span>
<span class="nc" id="L3931">            return q;</span>
<span class="nc" id="L3932">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L3933">            throw ke;</span>
<span class="nc" id="L3934">        } catch (RuntimeException re) {</span>
<span class="nc" id="L3935">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L3937">            endOperation();</span>
        }
    }

    /**
     * Create a new query.
     */
    protected QueryImpl newQueryImpl(String lang, StoreQuery sq) {
<span class="nc" id="L3945">        return new QueryImpl(this, lang, sq);</span>
    }

    @Override
    public Seq getIdentitySequence(ClassMetaData meta) {
<span class="nc bnc" id="L3950" title="All 2 branches missed.">        if (meta == null)</span>
<span class="nc" id="L3951">            return null;</span>
<span class="nc" id="L3952">        return getSequence(meta, null);</span>
    }

    @Override
    public Seq getValueSequence(FieldMetaData fmd) {
<span class="nc bnc" id="L3957" title="All 2 branches missed.">        if (fmd == null)</span>
<span class="nc" id="L3958">            return null;</span>
<span class="nc" id="L3959">        return getSequence(fmd.getDefiningMetaData(), fmd);</span>
    }

    /**
     * Return a sequence for the given class and optional field.
     */
    private Seq getSequence(ClassMetaData meta, FieldMetaData fmd) {
        // get sequence strategy from metadata
        int strategy;
<span class="nc bnc" id="L3968" title="All 2 branches missed.">        if (fmd == null)</span>
<span class="nc" id="L3969">            strategy = meta.getIdentityStrategy();</span>
        else
<span class="nc" id="L3971">            strategy = fmd.getValueStrategy();</span>

        // we can handle non-native strategies without the store manager
<span class="nc bnc" id="L3974" title="All 6 branches missed.">        switch (strategy) {</span>
            case ValueStrategies.UUID_HEX:
<span class="nc" id="L3976">                return UUIDHexSeq.getInstance();</span>
            case ValueStrategies.UUID_STRING:
<span class="nc" id="L3978">                return UUIDStringSeq.getInstance();</span>
            case ValueStrategies.UUID_TYPE4_HEX:
<span class="nc" id="L3980">                return UUIDType4HexSeq.getInstance();</span>
            case ValueStrategies.UUID_TYPE4_STRING:
<span class="nc" id="L3982">                return UUIDType4StringSeq.getInstance();</span>
            case ValueStrategies.SEQUENCE:
<span class="nc bnc" id="L3984" title="All 2 branches missed.">                SequenceMetaData smd = (fmd == null)</span>
<span class="nc" id="L3985">                    ? meta.getIdentitySequenceMetaData()</span>
<span class="nc" id="L3986">                    : fmd.getValueSequenceMetaData();</span>
<span class="nc" id="L3987">                return smd.getInstance(_loader);</span>
            default:
                // use store manager for native sequence
<span class="nc bnc" id="L3990" title="All 2 branches missed.">                if (fmd == null) {</span>
                    // This will return a sequence even for app id classes,
                    // which is what we want for backwards-compatibility.
                    // Even if user uses Application Identity,
                    // user might use custom sequence information.
                    // So, first, the sequence should be checked.
                    // Trying to get primary key field if it has
                    // sequence meta data.
<span class="nc" id="L3998">                    FieldMetaData[] pks = meta.getPrimaryKeyFields();</span>
<span class="nc bnc" id="L3999" title="All 4 branches missed.">                    if (pks != null &amp;&amp; pks.length == 1) {</span>
<span class="nc" id="L4000">                        smd = pks[0].getValueSequenceMetaData();</span>
                    } else {
<span class="nc" id="L4002">                        smd = meta.getIdentitySequenceMetaData();</span>
                    }

<span class="nc bnc" id="L4005" title="All 2 branches missed.">                    if (smd != null) {</span>
<span class="nc" id="L4006">                        return smd.getInstance(_loader);</span>
                    } else {
<span class="nc" id="L4008">                        return _store.getDataStoreIdSequence(meta);</span>
                    }
                }
<span class="nc" id="L4011">                return _store.getValueSequence(fmd);</span>
        }
    }

    ///////////
    // Locking
    ///////////

    @Override
    public void lock(Object obj, OpCallbacks call) {
<span class="nc bnc" id="L4021" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L4022">            return;</span>

<span class="nc" id="L4024">        beginOperation(true); // have to sync or lock level always NONE</span>
        try {
<span class="nc" id="L4026">            lock(obj, _fc.getWriteLockLevel(), _fc.getLockTimeout(), call);</span>
        } finally {
<span class="nc" id="L4028">            endOperation();</span>
        }
<span class="nc" id="L4030">    }</span>

    @Override
    public void lock(Object obj, int level, int timeout, OpCallbacks call) {
<span class="nc bnc" id="L4034" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L4035">            return;</span>

<span class="nc" id="L4037">        beginOperation(true);</span>
        try {
<span class="nc" id="L4039">            assertActiveTransaction();</span>

<span class="nc" id="L4041">            StateManagerImpl sm = getStateManagerImpl(obj, true);</span>
<span class="nc bnc" id="L4042" title="All 2 branches missed.">            if ((processArgument(OpCallbacks.OP_LOCK, obj, sm, call)</span>
                &amp; OpCallbacks.ACT_RUN) == 0)
<span class="nc" id="L4044">                return;</span>
<span class="nc bnc" id="L4045" title="All 4 branches missed.">            if (sm == null || !sm.isPersistent())</span>
<span class="nc" id="L4046">                return;</span>

<span class="nc" id="L4048">            _lm.lock(sm, level, timeout, null);</span>
<span class="nc" id="L4049">            sm.readLocked(level, level); // use same level for future write</span>
<span class="nc" id="L4050">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L4051">            throw ke;</span>
<span class="nc" id="L4052">        } catch (RuntimeException re) {</span>
<span class="nc" id="L4053">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L4055">            endOperation();</span>
        }
<span class="nc" id="L4057">    }</span>

    @Override
    public void lockAll(Collection objs, OpCallbacks call) {
<span class="nc bnc" id="L4061" title="All 2 branches missed.">        if (objs.isEmpty())</span>
<span class="nc" id="L4062">            return;</span>

<span class="nc" id="L4064">        beginOperation(true); // have to sync or lock level always NONE</span>
        try {
<span class="nc" id="L4066">            lockAll(objs, _fc.getWriteLockLevel(), _fc.getLockTimeout(),</span>
                call);
        } finally {
<span class="nc" id="L4069">            endOperation();</span>
        }
<span class="nc" id="L4071">    }</span>

    @Override
    public void lockAll(Collection objs, int level, int timeout,
        OpCallbacks call) {
<span class="nc bnc" id="L4076" title="All 2 branches missed.">        if (objs.isEmpty())</span>
<span class="nc" id="L4077">            return;</span>
<span class="nc bnc" id="L4078" title="All 2 branches missed.">        if (objs.size() == 1) {</span>
<span class="nc" id="L4079">            lock(objs.iterator().next(), level, timeout, call);</span>
<span class="nc" id="L4080">            return;</span>
        }

<span class="nc" id="L4083">        beginOperation(true);</span>
        try {
<span class="nc" id="L4085">            assertActiveTransaction();</span>

<span class="nc" id="L4087">            Collection&lt;StateManagerImpl&gt; sms = new LinkedHashSet&lt;&gt;(objs.size());</span>
            Object obj;
            StateManagerImpl sm;
<span class="nc bnc" id="L4090" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = objs.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L4091">                obj = itr.next();</span>
<span class="nc bnc" id="L4092" title="All 2 branches missed.">                if (obj == null)</span>
<span class="nc" id="L4093">                    continue;</span>

<span class="nc" id="L4095">                sm = getStateManagerImpl(obj, true);</span>
<span class="nc bnc" id="L4096" title="All 2 branches missed.">                if ((processArgument(OpCallbacks.OP_LOCK, obj, sm, call)</span>
                    &amp; OpCallbacks.ACT_RUN) == 0)
<span class="nc" id="L4098">                    continue;</span>
<span class="nc bnc" id="L4099" title="All 4 branches missed.">                if (sm != null &amp;&amp; sm.isPersistent())</span>
<span class="nc" id="L4100">                    sms.add(sm);</span>
            }

<span class="nc" id="L4103">            _lm.lockAll(sms, level, timeout, null);</span>
<span class="nc bnc" id="L4104" title="All 2 branches missed.">            for (Iterator&lt;StateManagerImpl&gt; itr = sms.iterator(); itr.hasNext();)</span>
<span class="nc" id="L4105">                itr.next().readLocked(level, level);</span>
<span class="nc" id="L4106">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L4107">            throw ke;</span>
<span class="nc" id="L4108">        } catch (RuntimeException re) {</span>
<span class="nc" id="L4109">            throw new GeneralException(re);</span>
        } finally {
<span class="nc" id="L4111">            endOperation();</span>
        }
<span class="nc" id="L4113">    }</span>

    //////////////
    // Connection
    //////////////

    @Override
    public boolean cancelAll() {
        // this method does not lock, since we want to allow a different
        // thread to be able to cancel on a locked-up persistence manager

<span class="nc" id="L4124">        assertOpen();</span>
        try {
            // if we're flushing, have to set rollback only -- do this before we
            // attempt to cancel, because otherwise the cancel might case the
            // transaction to complete before we have a chance to set the
            // rollback only flag
<span class="nc bnc" id="L4130" title="All 2 branches missed.">            if ((_flags &amp; FLAG_STORE_FLUSHING) != 0)</span>
<span class="nc" id="L4131">                setRollbackOnlyInternal(new UserException());</span>
<span class="nc" id="L4132">            return _store.cancelAll();</span>
<span class="nc" id="L4133">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L4134">            throw ke;</span>
<span class="nc" id="L4135">        } catch (RuntimeException re) {</span>
<span class="nc" id="L4136">            throw new StoreException(re);</span>
        }
    }

    @Override
    public Object getConnection() {
<span class="nc" id="L4142">        assertOpen();</span>
<span class="nc" id="L4143">        if (!_conf.supportedOptions().contains</span>
<span class="nc bnc" id="L4144" title="All 2 branches missed.">            (OpenJPAConfiguration.OPTION_DATASTORE_CONNECTION))</span>
<span class="nc" id="L4145">            throw new UnsupportedException(_loc.get(&quot;conn-not-supported&quot;));</span>

<span class="nc" id="L4147">        return _store.getClientConnection();</span>
    }

    @Override
    public boolean hasConnection() {
<span class="nc" id="L4152">        assertOpen();</span>
<span class="nc bnc" id="L4153" title="All 2 branches missed.">        return (_flags &amp; FLAG_RETAINED_CONN) != 0;</span>
    }

    /**
     * Tell store to retain connection if we haven't already.
     */
    private void retainConnection() {
<span class="nc bnc" id="L4160" title="All 2 branches missed.">        if ((_flags &amp; FLAG_RETAINED_CONN) == 0) {</span>
<span class="nc" id="L4161">            _store.retainConnection();</span>
<span class="nc" id="L4162">            _flags |= FLAG_RETAINED_CONN;</span>
        }
<span class="nc" id="L4164">    }</span>

    /**
     * Tell store to release connection if we have retained one.
     */
    private void releaseConnection() {
<span class="nc bnc" id="L4170" title="All 2 branches missed.">        if ((_flags &amp; FLAG_RETAINED_CONN) != 0) {</span>
<span class="nc" id="L4171">            _store.releaseConnection();</span>
<span class="nc" id="L4172">            _flags &amp;= ~FLAG_RETAINED_CONN;</span>
        }
<span class="nc" id="L4174">    }</span>

    /////////
    // Cache
    /////////

    @Override
    public Collection getManagedObjects() {
<span class="nc" id="L4182">        beginOperation(false);</span>
        try {
<span class="nc" id="L4184">            return new ManagedObjectCollection(getManagedStates());</span>
        } finally {
<span class="nc" id="L4186">            endOperation();</span>
        }
    }

    @Override
    public Collection getTransactionalObjects() {
<span class="nc" id="L4192">        beginOperation(false);</span>
        try {
<span class="nc" id="L4194">            return new ManagedObjectCollection(getTransactionalStates());</span>
        } finally {
<span class="nc" id="L4196">            endOperation();</span>
        }
    }

    @Override
    public Collection getPendingTransactionalObjects() {
<span class="nc" id="L4202">        beginOperation(false);</span>
        try {
<span class="nc" id="L4204">            return new ManagedObjectCollection</span>
<span class="nc" id="L4205">                (getPendingTransactionalStates());</span>
        } finally {
<span class="nc" id="L4207">            endOperation();</span>
        }
    }

    @Override
    public Collection getDirtyObjects() {
<span class="nc" id="L4213">        beginOperation(false);</span>
        try {
<span class="nc" id="L4215">            return new ManagedObjectCollection(getDirtyStates());</span>
        } finally {
<span class="nc" id="L4217">            endOperation();</span>
        }
    }

    @Override
    public boolean getOrderDirtyObjects() {
<span class="nc" id="L4223">        return _orderDirty;</span>
    }

    @Override
    public void setOrderDirtyObjects(boolean order) {
<span class="nc" id="L4228">        _orderDirty = order;</span>
<span class="nc" id="L4229">    }</span>

    /**
     * Return a copy of all managed state managers.
     */
    protected Collection getManagedStates() {
<span class="nc" id="L4235">        return _cache.copy();</span>
    }

    /**
     * Return a copy of all transactional state managers.
     */
    protected Collection&lt;StateManagerImpl&gt; getTransactionalStates() {
<span class="nc bnc" id="L4242" title="All 2 branches missed.">        if (!hasTransactionalObjects()) {</span>
            // return a new empty set. Entities may be added by TransactionListeners
<span class="nc" id="L4244">            return new LinkedHashSet&lt;&gt;();</span>
        }
<span class="nc" id="L4246">        return _transCache.copy();</span>
    }

    /**
     * Whether or not there are any transactional objects in the current
     * persistence context. If there are any instances with untracked state,
     * this method will cause those instances to be scanned.
     */
    private boolean hasTransactionalObjects() {
<span class="nc" id="L4255">        _cache.dirtyCheck();</span>
<span class="nc bnc" id="L4256" title="All 2 branches missed.">        return _transCache != null;</span>
    }

    /**
     * Return a copy of all dirty state managers.
     */
    protected Collection getDirtyStates() {
<span class="nc bnc" id="L4263" title="All 2 branches missed.">        if (!hasTransactionalObjects())</span>
<span class="nc" id="L4264">            return Collections.EMPTY_SET;</span>

<span class="nc" id="L4266">        return _transCache.copyDirty();</span>
    }

    /**
     * Return a copy of all state managers which will become
     * transactional upon the next transaction.
     */
    protected Collection getPendingTransactionalStates() {
<span class="nc bnc" id="L4274" title="All 2 branches missed.">        if (_pending == null)</span>
<span class="nc" id="L4275">            return Collections.EMPTY_SET;</span>
<span class="nc" id="L4276">        return new LinkedHashSet&lt;&gt;(_pending);</span>
    }

    /**
     * Set the cached StateManager for the instance that had the given oid.
     * This method must not be called multiple times for new instances.
     *
     * @param id the id previously used by the instance
     * @param sm the state manager for the instance; if the state
     * manager is transient, we'll stop managing the instance;
     * if it has updated its oid, we'll re-cache under the new oid
     * @param status one of our STATUS constants describing why we're
     * setting the state manager
     */
    protected void setStateManager(Object id, StateManagerImpl sm, int status) {
<span class="nc" id="L4291">        lock();</span>
        try {
<span class="nc bnc" id="L4293" title="All 5 branches missed.">            switch (status) {</span>
                case STATUS_INIT:
                    // Only reset the flushed flag is this is a new instance.
<span class="nc bnc" id="L4296" title="All 4 branches missed.">                    if (sm.isNew() &amp;&amp; _compat.getResetFlushFlagForCascadePersist()) {// OPENJPA-2051</span>
<span class="nc" id="L4297">                        _flags &amp;= ~FLAG_FLUSHED;</span>
                    }
<span class="nc" id="L4299">                    _cache.add(sm);</span>
<span class="nc" id="L4300">                    break;</span>
                case STATUS_TRANSIENT:
<span class="nc" id="L4302">                    _cache.remove(id, sm);</span>
<span class="nc" id="L4303">                    break;</span>
                case STATUS_OID_ASSIGN:
<span class="nc" id="L4305">                    assignObjectId(_cache, id, sm);</span>
<span class="nc" id="L4306">                    break;</span>
                case STATUS_COMMIT_NEW:
<span class="nc" id="L4308">                    _cache.commitNew(id, sm);</span>
<span class="nc" id="L4309">                    break;</span>
                default:
<span class="nc" id="L4311">                    throw new InternalException();</span>
            }
        }
        finally {
<span class="nc" id="L4315">            unlock();</span>
        }
<span class="nc" id="L4317">    }</span>

    /**
     * Notify the broker that the given state manager should
     * be added to the set of instances involved in the current transaction.
     */
    void addToTransaction(StateManagerImpl sm) {
        // we only add clean instances now; dirty instances are added in
        // the setDirty callback
<span class="nc bnc" id="L4326" title="All 2 branches missed.">        if (sm.isDirty())</span>
<span class="nc" id="L4327">            return;</span>

<span class="nc" id="L4329">        lock();</span>
        try {
<span class="nc bnc" id="L4331" title="All 2 branches missed.">            if (!hasTransactionalObjects())</span>
<span class="nc" id="L4332">                _transCache = new TransactionalCache(_orderDirty);</span>
<span class="nc" id="L4333">            _transCache.addClean(sm);</span>
        } finally {
<span class="nc" id="L4335">            unlock();</span>
        }
<span class="nc" id="L4337">    }</span>

    /**
     * Notify the persistence manager that the given state manager should
     * be removed from the set of instances involved in the current transaction.
     */
    void removeFromTransaction(StateManagerImpl sm) {
<span class="nc" id="L4344">        lock();</span>
        try {
<span class="nc bnc" id="L4346" title="All 2 branches missed.">            if (_transCache != null)</span>
                // intentional direct access; we don't want to recompute
                // dirtiness while removing instances from the transaction
<span class="nc" id="L4349">                _transCache.remove(sm);</span>
<span class="nc bnc" id="L4350" title="All 4 branches missed.">            if (_derefCache != null &amp;&amp; !sm.isPersistent())</span>
<span class="nc" id="L4351">                _derefCache.remove(sm);</span>
        } finally {
<span class="nc" id="L4353">            unlock();</span>
        }
<span class="nc" id="L4355">    }</span>

    /**
     * Notification that the given instance has been dirtied. This
     * notification is given when an object first transitions to a dirty state,
     * and every time the object is modified by the user thereafter.
     */
    void setDirty(StateManagerImpl sm, boolean firstDirty) {
<span class="nc bnc" id="L4363" title="All 2 branches missed.">        if (sm.isPersistent())</span>
<span class="nc" id="L4364">            _flags |= FLAG_FLUSH_REQUIRED;</span>

<span class="nc bnc" id="L4366" title="All 4 branches missed.">        if (_savepoints != null &amp;&amp; !_savepoints.isEmpty()) {</span>
<span class="nc bnc" id="L4367" title="All 2 branches missed.">            if (_savepointCache == null)</span>
<span class="nc" id="L4368">                _savepointCache = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4369">            _savepointCache.add(sm);</span>
        }

<span class="nc bnc" id="L4372" title="All 4 branches missed.">        if (firstDirty &amp;&amp; sm.isTransactional()) {</span>
<span class="nc" id="L4373">            lock();</span>
            try {
                // cache dirty instance
<span class="nc bnc" id="L4376" title="All 2 branches missed.">                if (!hasTransactionalObjects())</span>
<span class="nc" id="L4377">                    _transCache = new TransactionalCache(_orderDirty);</span>
<span class="nc" id="L4378">                _transCache.addDirty(sm);</span>

                // also record that the class is dirty
<span class="nc bnc" id="L4381" title="All 2 branches missed.">                if (sm.isNew()) {</span>
<span class="nc bnc" id="L4382" title="All 2 branches missed.">                    if (_persistedClss == null)</span>
<span class="nc" id="L4383">                        _persistedClss = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4384">                    _persistedClss.add(sm.getMetaData().getDescribedType());</span>
<span class="nc bnc" id="L4385" title="All 2 branches missed.">                } else if (sm.isDeleted()) {</span>
<span class="nc bnc" id="L4386" title="All 2 branches missed.">                    if (_deletedClss == null)</span>
<span class="nc" id="L4387">                        _deletedClss = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4388">                    _deletedClss.add(sm.getMetaData().getDescribedType());</span>
                } else {
<span class="nc bnc" id="L4390" title="All 2 branches missed.">                    if (_updatedClss == null)</span>
<span class="nc" id="L4391">                        _updatedClss = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4392">                    _updatedClss.add(sm.getMetaData().getDescribedType());</span>
                }

                // if tracking changes and this instance wasn't already dirty,
                // add to changed set; we use this for detecting instances that
                // enter the transaction during pre store
<span class="nc bnc" id="L4398" title="All 2 branches missed.">                if ((_flags &amp; FLAG_PRESTORING) != 0) {</span>
<span class="nc bnc" id="L4399" title="All 2 branches missed.">                    if (_transAdditions == null)</span>
<span class="nc" id="L4400">                        _transAdditions = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4401">                    _transAdditions.add(sm);</span>
                }
            } finally {
<span class="nc" id="L4404">                unlock();</span>
            }
        }
<span class="nc" id="L4407">    }</span>

    /**
     * Notify the broker that the given state manager should
     * be added to the set of instances that will become transactional
     * on the next transaction
     */
    void addToPendingTransaction(StateManagerImpl sm) {
<span class="nc" id="L4415">        lock();</span>
        try {
<span class="nc bnc" id="L4417" title="All 2 branches missed.">            if (_pending == null)</span>
<span class="nc" id="L4418">                _pending = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4419">            _pending.add(sm);</span>
        } finally {
<span class="nc" id="L4421">            unlock();</span>
        }
<span class="nc" id="L4423">    }</span>

    /**
     * Notify the persistence manager that the given state manager should
     * be removed from the set of instances involved in the next transaction.
     */
    void removeFromPendingTransaction(StateManagerImpl sm) {
<span class="nc" id="L4430">        lock();</span>
        try {
<span class="nc bnc" id="L4432" title="All 2 branches missed.">            if (_pending != null)</span>
<span class="nc" id="L4433">                _pending.remove(sm);</span>
<span class="nc bnc" id="L4434" title="All 4 branches missed.">            if (_derefCache != null &amp;&amp; !sm.isPersistent())</span>
<span class="nc" id="L4435">                _derefCache.remove(sm);</span>
        } finally {
<span class="nc" id="L4437">            unlock();</span>
        }
<span class="nc" id="L4439">    }</span>

    /**
     * Add a dereferenced dependent object to the persistence manager's cache.
     * On flush, these objects will be deleted.
     */
    void addDereferencedDependent(StateManagerImpl sm) {
<span class="nc" id="L4446">        lock();</span>
        try {
            // if we're in the middle of flush and introducing more derefs
            // via instance callbacks, add them to the special additions set
<span class="nc bnc" id="L4450" title="All 2 branches missed.">            if ((_flags &amp; FLAG_DEREFDELETING) != 0) {</span>
<span class="nc bnc" id="L4451" title="All 2 branches missed.">                if (_derefAdditions == null)</span>
<span class="nc" id="L4452">                    _derefAdditions = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4453">                _derefAdditions.add(sm);</span>
            } else {
<span class="nc bnc" id="L4455" title="All 2 branches missed.">                if (_derefCache == null)</span>
<span class="nc" id="L4456">                    _derefCache = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4457">                _derefCache.add(sm);</span>
            }
        }
        finally {
<span class="nc" id="L4461">            unlock();</span>
        }
<span class="nc" id="L4463">    }</span>

    /**
     * Remove the given previously dereferenced dependent object from the
     * cache. It is now referenced.
     */
    void removeDereferencedDependent(StateManagerImpl sm) {
<span class="nc" id="L4470">        lock();</span>
        try {
<span class="nc" id="L4472">            boolean removed = false;</span>
<span class="nc bnc" id="L4473" title="All 2 branches missed.">            if (_derefAdditions != null)</span>
<span class="nc" id="L4474">                removed = _derefAdditions.remove(sm);</span>
<span class="nc bnc" id="L4475" title="All 6 branches missed.">            if (!removed &amp;&amp; (_derefCache == null || !_derefCache.remove(sm)))</span>
<span class="nc" id="L4476">                throw new InvalidStateException(_loc.get(&quot;not-derefed&quot;,</span>
<span class="nc" id="L4477">                    Exceptions.toString(sm.getManagedInstance()))).</span>
<span class="nc" id="L4478">                    setFailedObject(sm.getManagedInstance()).</span>
<span class="nc" id="L4479">                    setFatal(true);</span>
        } finally {
<span class="nc" id="L4481">            unlock();</span>
        }
<span class="nc" id="L4483">    }</span>

    @Override
    public void dirtyType(Class cls) {
<span class="nc bnc" id="L4487" title="All 2 branches missed.">        if (cls == null)</span>
<span class="nc" id="L4488">            return;</span>

<span class="nc" id="L4490">        beginOperation(false);</span>
        try {
<span class="nc bnc" id="L4492" title="All 2 branches missed.">            if (_updatedClss == null)</span>
<span class="nc" id="L4493">                _updatedClss = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4494">            _updatedClss.add(cls);</span>
        } finally {
<span class="nc" id="L4496">            endOperation();</span>
        }
<span class="nc" id="L4498">    }</span>

    @Override
    public Collection getPersistedTypes() {
<span class="nc bnc" id="L4502" title="All 4 branches missed.">        if (_persistedClss == null || _persistedClss.isEmpty())</span>
<span class="nc" id="L4503">            return Collections.EMPTY_SET;</span>
<span class="nc" id="L4504">        return Collections.unmodifiableCollection(_persistedClss);</span>
    }

    @Override
    public Collection getUpdatedTypes() {
<span class="nc bnc" id="L4509" title="All 4 branches missed.">        if (_updatedClss == null || _updatedClss.isEmpty())</span>
<span class="nc" id="L4510">            return Collections.EMPTY_SET;</span>
<span class="nc" id="L4511">        return Collections.unmodifiableCollection(_updatedClss);</span>
    }

    @Override
    public Collection getDeletedTypes() {
<span class="nc bnc" id="L4516" title="All 4 branches missed.">        if (_deletedClss == null || _deletedClss.isEmpty())</span>
<span class="nc" id="L4517">            return Collections.EMPTY_SET;</span>
<span class="nc" id="L4518">        return Collections.unmodifiableCollection(_deletedClss);</span>
    }

    ///////////
    // Closing
    ///////////

    @Override
    public boolean isClosed() {
<span class="nc" id="L4527">        return _closed;</span>
    }

    @Override
    public boolean isCloseInvoked() {
<span class="nc bnc" id="L4532" title="All 4 branches missed.">        return _closed || (_flags &amp; FLAG_CLOSE_INVOKED) != 0;</span>
    }

    @Override
    public void close() {
<span class="nc" id="L4537">        beginOperation(false);</span>
        try {
            // throw an exception if closing in an active local trans
<span class="nc bnc" id="L4540" title="All 4 branches missed.">            if (!_managed &amp;&amp; (_flags &amp; FLAG_ACTIVE) != 0)</span>
<span class="nc" id="L4541">                throw new InvalidStateException(_loc.get(&quot;active&quot;));</span>

            // only close if not active; if active managed trans wait
            // for completion
<span class="nc" id="L4545">            _flags |= FLAG_CLOSE_INVOKED;</span>

<span class="nc bnc" id="L4547" title="All 2 branches missed.">            if ((_flags &amp; FLAG_ACTIVE) == 0)</span>
<span class="nc" id="L4548">                free();</span>
        } finally {
<span class="nc" id="L4550">            endOperation();</span>
        }
<span class="nc" id="L4552">    }</span>

    /**
     * Free the resources used by this persistence manager.
     */
    protected void free() {
<span class="nc" id="L4558">        RuntimeException err = null;</span>
<span class="nc bnc" id="L4559" title="All 2 branches missed.">        if ((_autoDetach &amp; DETACH_CLOSE) != 0) {</span>
            try {
<span class="nc" id="L4561">                detachAllInternal(_call);</span>
<span class="nc" id="L4562">            } catch (RuntimeException re) {</span>
<span class="nc" id="L4563">                err = re;</span>
<span class="nc" id="L4564">            }</span>
        }

<span class="nc" id="L4567">        _sync = null;</span>
<span class="nc" id="L4568">        _userObjects = null;</span>
<span class="nc" id="L4569">        _cache.clear();</span>
<span class="nc" id="L4570">        _transCache = null;</span>
<span class="nc" id="L4571">        _persistedClss = null;</span>
<span class="nc" id="L4572">        _updatedClss = null;</span>
<span class="nc" id="L4573">        _deletedClss = null;</span>
<span class="nc" id="L4574">        _derefCache = null;</span>
<span class="nc" id="L4575">        _pending = null;</span>
<span class="nc" id="L4576">        _loader = null;</span>
<span class="nc" id="L4577">        _transEventManager = null;</span>
<span class="nc" id="L4578">        _lifeEventManager = null;</span>

        OpenJPASavepoint save;
<span class="nc bnc" id="L4581" title="All 4 branches missed.">        while (_savepoints != null &amp;&amp; !_savepoints.isEmpty()) {</span>
<span class="nc" id="L4582">            save =</span>
<span class="nc" id="L4583">                (OpenJPASavepoint) _savepoints.remove(_savepoints.size() - 1);</span>
<span class="nc" id="L4584">            save.release(false);</span>
        }
<span class="nc" id="L4586">        _savepoints = null;</span>
<span class="nc" id="L4587">        _savepointCache = null;</span>

<span class="nc bnc" id="L4589" title="All 2 branches missed.">        if (_queries != null) {</span>
<span class="nc bnc" id="L4590" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = _queries.iterator(); itr.hasNext();) {</span>
                try {
<span class="nc" id="L4592">                    ((Query) itr.next()).closeResources();</span>
<span class="nc" id="L4593">                } catch (RuntimeException re) {</span>
<span class="nc" id="L4594">                }</span>
            }
<span class="nc" id="L4596">            _queries = null;</span>
        }

<span class="nc bnc" id="L4599" title="All 2 branches missed.">        if (_extents != null) {</span>
            Extent e;
<span class="nc bnc" id="L4601" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = _extents.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L4602">                e = (Extent) itr.next();</span>
                try {
<span class="nc" id="L4604">                    e.closeAll();</span>
<span class="nc" id="L4605">                } catch (RuntimeException re) {</span>
<span class="nc" id="L4606">                }</span>
            }
<span class="nc" id="L4608">            _extents = null;</span>
        }

<span class="nc" id="L4611">        try { releaseConnection(); } catch (RuntimeException re) {}</span>

<span class="nc" id="L4613">        _lm.close();</span>
<span class="nc" id="L4614">        _store.close();</span>
<span class="nc bnc" id="L4615" title="All 2 branches missed.">        if (_instm != null) {</span>
<span class="nc" id="L4616">            _instm.stop(InstrumentationLevel.BROKER, this);</span>
        }
<span class="nc" id="L4618">        _flags = 0;</span>
<span class="nc" id="L4619">        _closed = true;</span>
<span class="nc bnc" id="L4620" title="All 2 branches missed.">        if (_log.isTraceEnabled())</span>
<span class="nc" id="L4621">            _closedException = new IllegalStateException();</span>

<span class="nc" id="L4623">        _factory.releaseBroker(this);</span>

<span class="nc bnc" id="L4625" title="All 2 branches missed.">        if (err != null)</span>
<span class="nc" id="L4626">            throw err;</span>
<span class="nc" id="L4627">    }</span>

    ///////////////////
    // Synchronization
    ///////////////////

    @Override
    public void lock() {
<span class="nc bnc" id="L4635" title="All 2 branches missed.">        if (_lock != null)</span>
<span class="nc" id="L4636">            _lock.lock();</span>
<span class="nc" id="L4637">    }</span>

    @Override
    public void unlock() {
<span class="nc bnc" id="L4641" title="All 2 branches missed.">        if (_lock != null)</span>
<span class="nc" id="L4642">            _lock.unlock();</span>
<span class="nc" id="L4643">    }</span>

    ////////////////////
    // State management
    ////////////////////

    @Override
    public Object newInstance(Class cls) {
<span class="nc" id="L4651">        assertOpen();</span>

<span class="nc bnc" id="L4653" title="All 4 branches missed.">        if (!cls.isInterface() &amp;&amp; Modifier.isAbstract(cls.getModifiers()))</span>
<span class="nc" id="L4654">            throw new UnsupportedOperationException(_loc.get</span>
<span class="nc" id="L4655">                (&quot;new-abstract&quot;, cls).getMessage());</span>

        // 1.5 doesn't initialize classes without a true Class.forName
<span class="nc bnc" id="L4658" title="All 2 branches missed.">        if (!PCRegistry.isRegistered(cls)) {</span>
            try {
<span class="nc" id="L4660">                Class.forName(cls.getName(), true,</span>
<span class="nc" id="L4661">                    AccessController.doPrivileged(</span>
<span class="nc" id="L4662">                        J2DoPrivHelper.getClassLoaderAction(cls)));</span>
<span class="nc" id="L4663">            } catch (Throwable t) {</span>
<span class="nc" id="L4664">            }</span>
        }

<span class="nc bnc" id="L4667" title="All 2 branches missed.">        if (_repo.getMetaData(cls, getClassLoader(), false) == null)</span>
<span class="nc" id="L4668">            throw new IllegalArgumentException(</span>
<span class="nc" id="L4669">                _loc.get(&quot;no-interface-metadata&quot;, cls.getName()).getMessage());</span>

        try {
<span class="nc" id="L4672">            return PCRegistry.newInstance(cls, null, false);</span>
<span class="nc" id="L4673">        } catch (IllegalStateException ise) {</span>
<span class="nc" id="L4674">            IllegalArgumentException iae =</span>
<span class="nc" id="L4675">                new IllegalArgumentException(ise.getMessage());</span>
<span class="nc" id="L4676">            iae.setStackTrace(ise.getStackTrace());</span>
<span class="nc" id="L4677">            throw iae;</span>
        }
    }

    @Override
    public Object getObjectId(Object obj) {
<span class="nc" id="L4683">        assertOpen();</span>
<span class="nc bnc" id="L4684" title="All 2 branches missed.">        if (ImplHelper.isManageable(obj)) {</span>
<span class="nc" id="L4685">            PersistenceCapable pc = ImplHelper.toPersistenceCapable(obj, _conf);</span>
<span class="nc bnc" id="L4686" title="All 2 branches missed.">            if (pc != null) {</span>
<span class="nc bnc" id="L4687" title="All 2 branches missed.">                if (pc.pcGetStateManager() == null) {</span>
                    // If the statemanager is null the call to pcFetchObjectId always returns null. Create a new object
                    // id.
<span class="nc" id="L4690">                    return ApplicationIds.create(pc, _repo.getMetaData(pc.getClass(), null, true));</span>
                }
<span class="nc" id="L4692">                return pc.pcFetchObjectId();</span>
            }
        }
<span class="nc" id="L4695">        return null;</span>
    }

    @Override
    public int getLockLevel(Object o) {
<span class="nc" id="L4700">        assertOpen();</span>
<span class="nc bnc" id="L4701" title="All 2 branches missed.">        if (o == null)</span>
<span class="nc" id="L4702">            return LockLevels.LOCK_NONE;</span>

<span class="nc" id="L4704">        OpenJPAStateManager sm = getStateManager(o);</span>
<span class="nc bnc" id="L4705" title="All 2 branches missed.">        if (sm == null)</span>
<span class="nc" id="L4706">            return LockLevels.LOCK_NONE;</span>
<span class="nc" id="L4707">        return getLockManager().getLockLevel(sm);</span>
    }

    @Override
    public Object getVersion(Object obj) {
<span class="nc" id="L4712">        assertOpen();</span>
<span class="nc bnc" id="L4713" title="All 2 branches missed.">        if (ImplHelper.isManageable(obj))</span>
<span class="nc" id="L4714">            return (ImplHelper.toPersistenceCapable(obj, _conf)).pcGetVersion();</span>
<span class="nc" id="L4715">        return null;</span>
    }

    @Override
    public boolean isDirty(Object obj) {
<span class="nc" id="L4720">        assertOpen();</span>
<span class="nc bnc" id="L4721" title="All 2 branches missed.">        if (ImplHelper.isManageable(obj)) {</span>
<span class="nc" id="L4722">            PersistenceCapable pc = ImplHelper.toPersistenceCapable(obj, _conf);</span>
<span class="nc" id="L4723">            return pc.pcIsDirty();</span>
        }
<span class="nc" id="L4725">        return false;</span>
    }

    @Override
    public boolean isTransactional(Object obj) {
<span class="nc" id="L4730">        assertOpen();</span>
<span class="nc bnc" id="L4731" title="All 2 branches missed.">        if (ImplHelper.isManageable(obj))</span>
<span class="nc" id="L4732">            return (ImplHelper.toPersistenceCapable(obj, _conf))</span>
<span class="nc" id="L4733">                .pcIsTransactional();</span>
<span class="nc" id="L4734">        return false;</span>
    }

    @Override
    public boolean isPersistent(Object obj) {
<span class="nc" id="L4739">        assertOpen();</span>
<span class="nc bnc" id="L4740" title="All 2 branches missed.">        if (ImplHelper.isManageable(obj))</span>
<span class="nc" id="L4741">            return (ImplHelper.toPersistenceCapable(obj, _conf)).</span>
<span class="nc" id="L4742">                    pcIsPersistent();</span>
<span class="nc" id="L4743">        return false;</span>
    }

    @Override
    public boolean isNew(Object obj) {
<span class="nc" id="L4748">        assertOpen();</span>
<span class="nc bnc" id="L4749" title="All 2 branches missed.">        if (ImplHelper.isManageable(obj))</span>
<span class="nc" id="L4750">            return (ImplHelper.toPersistenceCapable(obj, _conf)).pcIsNew();</span>
<span class="nc" id="L4751">        return false;</span>
    }

    @Override
    public boolean isDeleted(Object obj) {
<span class="nc" id="L4756">        assertOpen();</span>
<span class="nc bnc" id="L4757" title="All 2 branches missed.">        if (ImplHelper.isManageable(obj))</span>
<span class="nc" id="L4758">            return (ImplHelper.toPersistenceCapable(obj, _conf)).pcIsDeleted();</span>
<span class="nc" id="L4759">        return false;</span>
    }
    @Override
    public boolean isDetached(Object obj) {
<span class="nc" id="L4763">        return isDetached(obj, true);</span>
    }

    /**
     * This method makes a best effort to determine if the provided object is detached.
     *
     * @param find
     *            - If true, as a last resort this method will check whether or not the provided object exists in the
     *            DB. If it is in the DB, the provided object is detached.
     * @return - True if the provided obj is detached, false otherwise.
     */
    public boolean isDetached(Object obj, boolean find) {
<span class="nc bnc" id="L4775" title="All 2 branches missed.">        if (!(ImplHelper.isManageable(obj)))</span>
<span class="nc" id="L4776">            return false;</span>

<span class="nc" id="L4778">        PersistenceCapable pc = ImplHelper.toPersistenceCapable(obj, _conf);</span>
<span class="nc bnc" id="L4779" title="All 2 branches missed.">        if (pc.pcGetStateManager() instanceof DetachedStateManager)</span>
<span class="nc" id="L4780">            return true;</span>
<span class="nc" id="L4781">        Boolean detached = pc.pcIsDetached();</span>
<span class="nc bnc" id="L4782" title="All 2 branches missed.">        if (detached != null)</span>
<span class="nc" id="L4783">            return detached.booleanValue();</span>

<span class="nc bnc" id="L4785" title="All 2 branches missed.">        if(!find){</span>
<span class="nc" id="L4786">            return false;</span>
        }
        // last resort: instance is detached if it has a store record
<span class="nc" id="L4789">        ClassMetaData meta = _repo.getMetaData(ImplHelper.getManagedInstance(pc).getClass(), _loader, true);</span>
<span class="nc" id="L4790">        Object oid = ApplicationIds.create(pc, meta);</span>
<span class="nc bnc" id="L4791" title="All 2 branches missed.">        if (oid == null)</span>
<span class="nc" id="L4792">            return false;</span>

<span class="nc bnc" id="L4794" title="All 2 branches missed.">        return find(oid, null, EXCLUDE_ALL, null, 0) != null;</span>
    }

    @Override
    public OpenJPAStateManager getStateManager(Object obj) {
<span class="nc" id="L4799">        assertOpen();</span>
<span class="nc" id="L4800">        return getStateManagerImpl(obj, false);</span>
    }

    /**
     * Return the state manager for the given instance, or null.
     *
     * @param assertThisContext if true, thow an exception if the given
     * object is managed by another broker
     */
    protected StateManagerImpl getStateManagerImpl(Object obj,
        boolean assertThisContext) {
<span class="nc bnc" id="L4811" title="All 2 branches missed.">        if (ImplHelper.isManageable(obj)) {</span>
<span class="nc" id="L4812">            PersistenceCapable pc = ImplHelper.toPersistenceCapable(obj, _conf);</span>
<span class="nc" id="L4813">            BrokerImpl pcBroker = (BrokerImpl)pc.pcGetGenericContext();</span>
<span class="nc bnc" id="L4814" title="All 4 branches missed.">            if (pcBroker == this || isFromWriteBehindCallback())</span>
<span class="nc" id="L4815">                return (StateManagerImpl) pc.pcGetStateManager();</span>
<span class="nc bnc" id="L4816" title="All 4 branches missed.">            if (assertThisContext &amp;&amp; pcBroker != null)</span>
<span class="nc" id="L4817">                throw new UserException(_loc.get(&quot;not-managed&quot;,</span>
<span class="nc" id="L4818">                    Exceptions.toString(obj))).setFailedObject(obj);</span>
        }
<span class="nc" id="L4820">        return null;</span>
    }

    /**
     * Return the state manager for the given oid.
     *
     * @param allowNew if true, objects made persistent in the current
     * transaction will be included in the search; if
     * multiple new objects match the given oid, it is
     * undefined which will be returned
     */
    protected StateManagerImpl getStateManagerImplById(Object oid,
        boolean allowNew) {
<span class="nc" id="L4833">        return _cache.getById(oid, allowNew);</span>
    }

    /**
     * Return the given instance as a {@link PersistenceCapable}.
     * If the instance is not manageable throw the proper exception.
     */
    protected PersistenceCapable assertPersistenceCapable(Object obj) {
<span class="nc bnc" id="L4841" title="All 2 branches missed.">        if (obj == null)</span>
<span class="nc" id="L4842">            return null;</span>
<span class="nc bnc" id="L4843" title="All 2 branches missed.">        if (ImplHelper.isManageable(obj))</span>
<span class="nc" id="L4844">            return ImplHelper.toPersistenceCapable(obj, _conf);</span>

        // check for different instances of the PersistenceCapable interface
        // and throw a better error that mentions the class loaders
<span class="nc" id="L4848">        Class&lt;?&gt;[] intfs = obj.getClass().getInterfaces();</span>
<span class="nc bnc" id="L4849" title="All 4 branches missed.">        for (int i = 0; intfs != null &amp;&amp; i &lt; intfs.length; i++) {</span>
<span class="nc bnc" id="L4850" title="All 2 branches missed.">            if (intfs[i].getName().equals(PersistenceCapable.class.getName())) {</span>
<span class="nc" id="L4851">                throw new UserException(_loc.get(&quot;pc-loader-different&quot;,</span>
<span class="nc" id="L4852">                    Exceptions.toString(obj),</span>
<span class="nc" id="L4853">                    AccessController.doPrivileged(</span>
<span class="nc" id="L4854">                        J2DoPrivHelper.getClassLoaderAction(</span>
                            PersistenceCapable.class)),
<span class="nc" id="L4856">                    AccessController.doPrivileged(</span>
<span class="nc" id="L4857">                        J2DoPrivHelper.getClassLoaderAction(intfs[i]))))</span>
<span class="nc" id="L4858">                    .setFailedObject(obj);</span>
            }
        }

        // not enhanced
<span class="nc" id="L4863">        throw new UserException(_loc.get(&quot;pc-cast&quot;,</span>
<span class="nc" id="L4864">            Exceptions.toString(obj))).setFailedObject(obj);</span>
    }

    /////////
    // Utils
    /////////
    /**
     * Throw an exception if the context is closed.  The exact message and
     * content of the exception varies whether TRACE is enabled or not.
     */
    @Override
    public void assertOpen() {
<span class="nc bnc" id="L4876" title="All 2 branches missed.">        if (_closed) {</span>
<span class="nc bnc" id="L4877" title="All 2 branches missed.">            if (_closedException == null)  // TRACE not enabled</span>
<span class="nc" id="L4878">                throw new InvalidStateException(_loc.get(&quot;closed-notrace&quot;))</span>
<span class="nc" id="L4879">                        .setFatal(true);</span>
            else {
<span class="nc" id="L4881">                OpenJPAException e = new InvalidStateException(</span>
<span class="nc" id="L4882">                    _loc.get(&quot;closed&quot;), _closedException).setFatal(true);</span>
<span class="nc" id="L4883">                e.setCause(_closedException);</span>
<span class="nc" id="L4884">                throw e;</span>
            }
        }
<span class="nc" id="L4887">    }</span>

    @Override
    public void assertActiveTransaction() {
<span class="nc bnc" id="L4891" title="All 2 branches missed.">        if ((_flags &amp; FLAG_ACTIVE) == 0)</span>
<span class="nc" id="L4892">            throw new NoTransactionException(_loc.get(&quot;not-active&quot;));</span>
<span class="nc" id="L4893">    }</span>

    /**
     * Throw exception if a transaction-related operation is attempted and
     * no transaction is active.
     */
    private void assertTransactionOperation() {
<span class="nc bnc" id="L4900" title="All 2 branches missed.">        if ((_flags &amp; FLAG_ACTIVE) == 0)</span>
<span class="nc" id="L4901">            throw new InvalidStateException(_loc.get(&quot;not-active&quot;));</span>
<span class="nc" id="L4902">    }</span>

    @Override
    public void assertNontransactionalRead() {
<span class="nc bnc" id="L4906" title="All 4 branches missed.">        if ((_flags &amp; FLAG_ACTIVE) == 0 &amp;&amp; !_nontransRead)</span>
<span class="nc" id="L4907">            throw new InvalidStateException(_loc.get(&quot;non-trans-read&quot;));</span>
<span class="nc" id="L4908">    }</span>

    @Override
    public void assertWriteOperation() {
<span class="nc bnc" id="L4912" title="All 6 branches missed.">        if ((_flags &amp; FLAG_ACTIVE) == 0 &amp;&amp; (!_nontransWrite</span>
            || (_autoDetach &amp; DETACH_NONTXREAD) != 0))
<span class="nc" id="L4914">            throw new NoTransactionException(_loc.get(&quot;write-operation&quot;));</span>
<span class="nc" id="L4915">    }</span>

    /**
     * Return an object not found exception containing nested exceptions
     * for all of the given failed objects.
     */
    private static ObjectNotFoundException newObjectNotFoundException
        (Collection failed) {
<span class="nc" id="L4923">        Throwable[] t = new Throwable[failed.size()];</span>
<span class="nc" id="L4924">        int idx = 0;</span>
<span class="nc bnc" id="L4925" title="All 2 branches missed.">        for (Iterator&lt;?&gt; itr = failed.iterator(); itr.hasNext(); idx++)</span>
<span class="nc" id="L4926">            t[idx] = new ObjectNotFoundException(itr.next());</span>
<span class="nc" id="L4927">        return new ObjectNotFoundException(failed, t);</span>
    }

    ////////////////////////////////
    // FindCallbacks implementation
    ////////////////////////////////

    @Override
    public Object processArgument(Object oid) {
<span class="nc" id="L4936">        return oid;</span>
    }

    @Override
    public Object processReturn(Object oid, OpenJPAStateManager sm) {
<span class="nc bnc" id="L4941" title="All 2 branches missed.">        return (sm == null) ? null : sm.getManagedInstance();</span>
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
<span class="nc" id="L4945">        assertOpen();</span>
<span class="nc" id="L4946">        lock();</span>
        try {
<span class="nc bnc" id="L4948" title="All 2 branches missed.">            if (isActive()) {</span>
<span class="nc bnc" id="L4949" title="All 2 branches missed.">                if (!getOptimistic())</span>
<span class="nc" id="L4950">                    throw new InvalidStateException(</span>
<span class="nc" id="L4951">                        _loc.get(&quot;cant-serialize-pessimistic-broker&quot;));</span>
<span class="nc bnc" id="L4952" title="All 2 branches missed.">                if (hasFlushed())</span>
<span class="nc" id="L4953">                    throw new InvalidStateException(</span>
<span class="nc" id="L4954">                        _loc.get(&quot;cant-serialize-flushed-broker&quot;));</span>
<span class="nc bnc" id="L4955" title="All 2 branches missed.">                if (hasConnection())</span>
<span class="nc" id="L4956">                    throw new InvalidStateException(</span>
<span class="nc" id="L4957">                        _loc.get(&quot;cant-serialize-connected-broker&quot;));</span>
            }

            try {
<span class="nc" id="L4961">                _isSerializing = true;</span>
<span class="nc" id="L4962">                out.writeObject(_factory.getPoolKey());</span>
<span class="nc" id="L4963">                out.defaultWriteObject();</span>
            } finally {
<span class="nc" id="L4965">                _isSerializing = false;</span>
            }
        } finally {
<span class="nc" id="L4968">            unlock();</span>
        }
<span class="nc" id="L4970">    }</span>

    private void readObject(ObjectInputStream in)
        throws ClassNotFoundException, IOException {
<span class="nc" id="L4974">        Object factoryKey = in.readObject();</span>
<span class="nc" id="L4975">        AbstractBrokerFactory factory =</span>
<span class="nc" id="L4976">            AbstractBrokerFactory.getPooledFactoryForKey(factoryKey);</span>

        // this needs to happen before defaultReadObject so that it's
        // available for calls to broker.getConfiguration() during
        // StateManager deserialization
<span class="nc" id="L4981">        _conf = factory.getConfiguration();</span>
<span class="nc" id="L4982">        _repo = _conf.getMetaDataRepositoryInstance();</span>

<span class="nc" id="L4984">        in.defaultReadObject();</span>
<span class="nc" id="L4985">        factory.initializeBroker(_managed, _connRetainMode, this, true);</span>

        // re-initialize the lock if needed.
<span class="nc" id="L4988">        setMultithreaded(_multithreaded);</span>

        // force recreation of set
<span class="nc" id="L4991">        _operatingDirty = true;</span>
<span class="nc" id="L4992">        initializeOperatingSet();</span>

<span class="nc bnc" id="L4994" title="All 4 branches missed.">        if (isActive() &amp;&amp; _runtime instanceof LocalManagedRuntime)</span>
<span class="nc" id="L4995">            ((LocalManagedRuntime) _runtime).begin();</span>
<span class="nc" id="L4996">    }</span>

    /**
     * Whether or not this broker is in the midst of being serialized.
     *
     * @since 1.1.0
     */
    boolean isSerializing() {
<span class="nc" id="L5004">        return _isSerializing;</span>
    }

    /**
     * @return The value of openjpa.ConnectionFactoryProperties.PrintParameters. Default is false.
     */
    public boolean getPrintParameters() {
<span class="nc" id="L5011">        return _printParameters;</span>
    }
    /**
     * Transactional cache that holds soft refs to clean instances.
     */
    static class TransactionalCache
        implements Set, Serializable {

        
        private static final long serialVersionUID = 1L;
        private final boolean _orderDirty;
<span class="nc" id="L5022">        private Set&lt;StateManagerImpl&gt; _dirty = null;</span>
<span class="nc" id="L5023">        private Set&lt;StateManagerImpl&gt; _clean = null;</span>

<span class="nc" id="L5025">        public TransactionalCache(boolean orderDirty) {</span>
<span class="nc" id="L5026">            _orderDirty = orderDirty;</span>
<span class="nc" id="L5027">        }</span>

        /**
         * Return a copy of all transactional state managers.
         */
        public Collection copy() {
<span class="nc bnc" id="L5033" title="All 2 branches missed.">            if (isEmpty()) {</span>
                // Transaction Listeners may add entities to the transaction.
<span class="nc" id="L5035">                return new LinkedHashSet();</span>
            }

            // size may not be entirely accurate due to refs expiring, so
            // manually copy each object; doesn't matter this way if size too
            // big by some
<span class="nc" id="L5041">            Set copy = new LinkedHashSet(size());</span>
<span class="nc bnc" id="L5042" title="All 2 branches missed.">            if (_dirty != null)</span>
<span class="nc bnc" id="L5043" title="All 2 branches missed.">                for (Iterator&lt;StateManagerImpl&gt; itr = _dirty.iterator(); itr.hasNext();)</span>
<span class="nc" id="L5044">                    copy.add(itr.next());</span>
<span class="nc bnc" id="L5045" title="All 2 branches missed.">            if (_clean != null)</span>
<span class="nc bnc" id="L5046" title="All 2 branches missed.">                for (Iterator&lt;StateManagerImpl&gt; itr = _clean.iterator(); itr.hasNext();)</span>
<span class="nc" id="L5047">                    copy.add(itr.next());</span>
<span class="nc" id="L5048">            return copy;</span>
        }

        /**
         * Return a copy of all dirty state managers.
         */
        public Collection copyDirty() {
<span class="nc bnc" id="L5055" title="All 4 branches missed.">            if (_dirty == null || _dirty.isEmpty())</span>
<span class="nc" id="L5056">                return Collections.EMPTY_SET;</span>
<span class="nc" id="L5057">            return new LinkedHashSet&lt;&gt;(_dirty);</span>
        }

        /**
         * Transfer the given instance from the dirty cache to the clean cache.
         */
        public void flushed(StateManagerImpl sm) {
<span class="nc bnc" id="L5064" title="All 6 branches missed.">            if (sm.isDirty() &amp;&amp; _dirty != null &amp;&amp; _dirty.remove(sm))</span>
<span class="nc" id="L5065">                addCleanInternal(sm);</span>
<span class="nc" id="L5066">        }</span>

        /**
         * Add the given instance to the clean cache.
         */
        public void addClean(StateManagerImpl sm) {
<span class="nc bnc" id="L5072" title="All 4 branches missed.">            if (addCleanInternal(sm) &amp;&amp; _dirty != null)</span>
<span class="nc" id="L5073">                _dirty.remove(sm);</span>
<span class="nc" id="L5074">        }</span>

        private boolean addCleanInternal(StateManagerImpl sm) {
<span class="nc bnc" id="L5077" title="All 2 branches missed.">            if (_clean == null)</span>
<span class="nc" id="L5078">                _clean = new ReferenceHashSet(ReferenceStrength.SOFT);</span>
<span class="nc" id="L5079">            return _clean.add(sm);</span>
        }

        /**
         * Add the given instance to the dirty cache.
         */
        public void addDirty(StateManagerImpl sm) {
<span class="nc bnc" id="L5086" title="All 2 branches missed.">            if (_dirty == null) {</span>
<span class="nc bnc" id="L5087" title="All 2 branches missed.">                if (_orderDirty)</span>
<span class="nc" id="L5088">                    _dirty = MapBackedSet.mapBackedSet(new LinkedMap());</span>
                else
<span class="nc" id="L5090">                    _dirty = new HashSet&lt;&gt;();</span>
            }
<span class="nc bnc" id="L5092" title="All 2 branches missed.">            if (_dirty.add(sm))</span>
<span class="nc" id="L5093">                removeCleanInternal(sm);</span>
<span class="nc" id="L5094">        }</span>

        /**
         * Remove the given instance from the cache.
         */
        public boolean remove(StateManagerImpl sm) {
<span class="nc bnc" id="L5100" title="All 4 branches missed.">            return removeCleanInternal(sm)</span>
<span class="nc bnc" id="L5101" title="All 2 branches missed.">                || (_dirty != null &amp;&amp; _dirty.remove(sm));</span>
        }

        private boolean removeCleanInternal(StateManagerImpl sm) {
<span class="nc bnc" id="L5105" title="All 4 branches missed.">            return _clean != null &amp;&amp; _clean.remove(sm);</span>
        }

        @Override
        public Iterator iterator() {
<span class="nc" id="L5110">            IteratorChain chain = new IteratorChain();</span>
<span class="nc bnc" id="L5111" title="All 4 branches missed.">            if (_dirty != null &amp;&amp; !_dirty.isEmpty())</span>
<span class="nc" id="L5112">                chain.addIterator(_dirty.iterator());</span>
<span class="nc bnc" id="L5113" title="All 4 branches missed.">            if (_clean != null &amp;&amp; !_clean.isEmpty())</span>
<span class="nc" id="L5114">                chain.addIterator(_clean.iterator());</span>
<span class="nc" id="L5115">            return chain;</span>
        }

        @Override
        public boolean contains(Object obj) {
<span class="nc bnc" id="L5120" title="All 6 branches missed.">            return (_dirty != null &amp;&amp; _dirty.contains(obj))</span>
<span class="nc bnc" id="L5121" title="All 2 branches missed.">                || (_clean != null &amp;&amp; _clean.contains(obj));</span>
        }

        @Override
        public boolean containsAll(Collection coll) {
<span class="nc bnc" id="L5126" title="All 2 branches missed.">            for (Iterator&lt;?&gt; itr = coll.iterator(); itr.hasNext();)</span>
<span class="nc bnc" id="L5127" title="All 2 branches missed.">                if (!contains(itr.next()))</span>
<span class="nc" id="L5128">                    return false;</span>
<span class="nc" id="L5129">            return true;</span>
        }

        @Override
        public void clear() {
<span class="nc bnc" id="L5134" title="All 2 branches missed.">            if (_dirty != null)</span>
<span class="nc" id="L5135">                _dirty = null;</span>
<span class="nc bnc" id="L5136" title="All 2 branches missed.">            if (_clean != null)</span>
<span class="nc" id="L5137">                _clean = null;</span>
<span class="nc" id="L5138">        }</span>

        @Override
        public boolean isEmpty() {
<span class="nc bnc" id="L5142" title="All 6 branches missed.">            return (_dirty == null || _dirty.isEmpty())</span>
<span class="nc bnc" id="L5143" title="All 2 branches missed.">                &amp;&amp; (_clean == null || _clean.isEmpty());</span>
        }

        @Override
        public int size() {
<span class="nc" id="L5148">            int size = 0;</span>
<span class="nc bnc" id="L5149" title="All 2 branches missed.">            if (_dirty != null)</span>
<span class="nc" id="L5150">                size += _dirty.size();</span>
<span class="nc bnc" id="L5151" title="All 2 branches missed.">            if (_clean != null)</span>
<span class="nc" id="L5152">                size += _clean.size();</span>
<span class="nc" id="L5153">            return size;</span>
        }

        @Override
        public boolean add(Object obj) {
<span class="nc" id="L5158">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean addAll(Collection coll) {
<span class="nc" id="L5163">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean remove(Object obj) {
<span class="nc" id="L5168">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean removeAll(Collection coll) {
<span class="nc" id="L5173">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public boolean retainAll(Collection c) {
<span class="nc" id="L5178">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public Object[] toArray() {
<span class="nc" id="L5183">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public Object[] toArray(Object[] arr) {
<span class="nc" id="L5188">            throw new UnsupportedOperationException();</span>
        }
    }

    /**
     * Unique id for state managers of new datastore instances without assigned
     * object ids.
     */
    public static class StateManagerId
        implements Serializable {

        
        private static final long serialVersionUID = 1L;

        public static final String STRING_PREFIX = &quot;openjpasm:&quot;;

<span class="nc" id="L5204">        private static long _generator = 0;</span>

        private final int _bhash;
        private final long _id;

        public static StateManagerId newInstance(Broker b) {
<span class="nc" id="L5210">            return new StateManagerId(System.identityHashCode(b), _generator++);</span>
        }

<span class="nc" id="L5213">        private StateManagerId(int bhash, long id) {</span>
<span class="nc" id="L5214">            _bhash = bhash;</span>
<span class="nc" id="L5215">            _id = id;</span>
<span class="nc" id="L5216">        }</span>

<span class="nc" id="L5218">        public StateManagerId(String str) {</span>
<span class="nc" id="L5219">            str = str.substring(STRING_PREFIX.length());</span>
<span class="nc" id="L5220">            int idx = str.indexOf(':');</span>
<span class="nc" id="L5221">            _bhash = Integer.parseInt(str.substring(0, idx));</span>
<span class="nc" id="L5222">            _id = Long.parseLong(str.substring(idx + 1));</span>
<span class="nc" id="L5223">        }</span>

        @Override
        public boolean equals(Object other) {
<span class="nc bnc" id="L5227" title="All 2 branches missed.">            if (other == this)</span>
<span class="nc" id="L5228">                return true;</span>
<span class="nc bnc" id="L5229" title="All 4 branches missed.">            if ((other == null) || (other.getClass() != this.getClass()))</span>
<span class="nc" id="L5230">                return false;</span>

<span class="nc" id="L5232">            StateManagerId sid = (StateManagerId) other;</span>
<span class="nc bnc" id="L5233" title="All 4 branches missed.">            return _bhash == sid._bhash &amp;&amp; _id == sid._id;</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L5238">            return (int) (_id ^ (_id &gt;&gt;&gt; 32));</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L5243">            return STRING_PREFIX + _bhash + &quot;:&quot; + _id;</span>
        }
    }

    /**
     * Collection type that holds state managers but whose interface deals
     * with the corresponding managed objects.
     */
    private static class ManagedObjectCollection
        extends AbstractCollection {

        private final Collection _states;

<span class="nc" id="L5256">        public ManagedObjectCollection(Collection states) {</span>
<span class="nc" id="L5257">            _states = states;</span>
<span class="nc" id="L5258">        }</span>

        public Collection getStateManagers() {
<span class="nc" id="L5261">            return _states;</span>
        }

        @Override
        public int size() {
<span class="nc" id="L5266">            return _states.size();</span>
        }

        @Override
        public Iterator iterator() {
<span class="nc" id="L5271">            return new Iterator() {</span>
<span class="nc" id="L5272">                private final Iterator _itr = _states.iterator();</span>

                @Override
                public boolean hasNext() {
<span class="nc" id="L5276">                    return _itr.hasNext();</span>
                }

                @Override
                public Object next() {
<span class="nc" id="L5281">                    return ((OpenJPAStateManager) _itr.next()).</span>
<span class="nc" id="L5282">                        getManagedInstance();</span>
                }

                @Override
                public void remove() {
<span class="nc" id="L5287">                    throw new UnsupportedException();</span>
                }
            };
        }
    }

    /**
     * Assign the object id to the cache. Exception will be
     * thrown if the id already exists in the cache.
     */
    protected void assignObjectId(Object cache, Object id,
        StateManagerImpl sm) {
<span class="nc" id="L5299">        ((ManagedCache) cache).assignObjectId(id, sm);</span>
<span class="nc" id="L5300">    }</span>

    /**
     * This method makes sure we don't already have the instance cached
     */
    protected void checkForDuplicateId(Object id, Object obj, ClassMetaData meta) {
<span class="nc" id="L5306">        FieldMetaData[] pks = meta.getPrimaryKeyFields();</span>
<span class="nc bnc" id="L5307" title="All 6 branches missed.">        if (pks != null &amp;&amp; pks.length == 1 &amp;&amp; pks[0].getValueStrategy() == ValueStrategies.AUTOASSIGN) {</span>
<span class="nc" id="L5308">            return;</span>
        }
<span class="nc" id="L5310">        StateManagerImpl other = getStateManagerImplById(id, false);</span>
<span class="nc bnc" id="L5311" title="All 6 branches missed.">        if (other != null &amp;&amp; !other.isDeleted() &amp;&amp; !other.isNew())</span>
<span class="nc" id="L5312">            throw new ObjectExistsException(_loc.get(&quot;cache-exists&quot;,</span>
<span class="nc" id="L5313">                obj.getClass().getName(), id)).setFailedObject(obj);</span>
<span class="nc" id="L5314">    }</span>

    @Override
    public boolean getCachePreparedQuery() {
<span class="nc" id="L5318">        lock();</span>
        try {
<span class="nc bnc" id="L5320" title="All 2 branches missed.">            return _cachePreparedQuery</span>
<span class="nc bnc" id="L5321" title="All 2 branches missed.">               &amp;&amp; _conf.getQuerySQLCacheInstance() != null;</span>
        } finally {
<span class="nc" id="L5323">            unlock();</span>
        }
    }

    @Override
    public void setCachePreparedQuery(boolean flag) {
<span class="nc" id="L5329">        lock();</span>
        try {
<span class="nc" id="L5331">            _cachePreparedQuery = flag;</span>
        } finally {
<span class="nc" id="L5333">            unlock();</span>
        }
<span class="nc" id="L5335">    }</span>

    public boolean getCacheFinderQuery() {
<span class="nc" id="L5338">        lock();</span>
        try {
<span class="nc bnc" id="L5340" title="All 2 branches missed.">            return _cacheFinderQuery</span>
<span class="nc bnc" id="L5341" title="All 2 branches missed.">               &amp;&amp; _conf.getFinderCacheInstance() != null;</span>
        } finally {
<span class="nc" id="L5343">            unlock();</span>
        }
    }

    public void setCacheFinderQuery(boolean flag) {
<span class="nc" id="L5348">        lock();</span>
        try {
<span class="nc" id="L5350">            _cachePreparedQuery = flag;</span>
        } finally {
<span class="nc" id="L5352">            unlock();</span>
        }
<span class="nc" id="L5354">    }</span>

    public boolean isFromWriteBehindCallback() {
<span class="nc" id="L5357">        return _fromWriteBehindCallback;</span>
    }

    /**
     * Return the 'JTA' connectionFactoryName
     */
    @Override
    public String getConnectionFactoryName() {
<span class="nc" id="L5365">        return _connectionFactoryName;</span>
    }

    /**
     * Set the 'JTA' ConnectionFactoryName. Input will be trimmed to null before being stored.
     */
    @Override
    public void setConnectionFactoryName(String connectionFactoryName) {
<span class="nc" id="L5373">        this._connectionFactoryName = StringUtil.trimToNull(connectionFactoryName);</span>
<span class="nc" id="L5374">    }</span>

    /**
     * Return the 'NonJTA' ConnectionFactoryName.
     */
    @Override
    public String getConnectionFactory2Name() {
<span class="nc" id="L5381">        return _connectionFactory2Name;</span>
    }

    /**
     * Set the 'NonJTA' ConnectionFactoryName. Input will be trimmed to null before being stored.
     */
    @Override
    public void setConnectionFactory2Name(String connectionFactory2Name) {
<span class="nc" id="L5389">        this._connectionFactory2Name = StringUtil.trimToNull(connectionFactory2Name);</span>
<span class="nc" id="L5390">    }</span>

    /**
     * Return the 'JTA' ConnectionFactory, looking it up from JNDI if needed.
     *
     * @return the JTA connection factory or null if connectionFactoryName is blank.
     */
    @Override
    public Object getConnectionFactory() {
<span class="nc bnc" id="L5399" title="All 2 branches missed.">        if(StringUtil.isNotBlank(_connectionFactoryName)) {</span>
<span class="nc" id="L5400">            return Configurations.lookup(_connectionFactoryName, &quot;openjpa.ConnectionFactory&quot;, _log );</span>
        }
        else {
<span class="nc" id="L5403">            return null;</span>
        }
    }

    /**
     * Return the 'NonJTA' ConnectionFactory, looking it up from JNDI if needed.
     *
     * @return the NonJTA connection factory or null if connectionFactoryName is blank.
     */
    @Override
    public Object getConnectionFactory2() {
<span class="nc bnc" id="L5414" title="All 2 branches missed.">        if(StringUtil.isNotBlank(_connectionFactory2Name)) {</span>
<span class="nc" id="L5415">            return  Configurations.lookup(_connectionFactory2Name, &quot;openjpa.ConnectionFactory2&quot;, _log);</span>
        }
        else {
<span class="nc" id="L5418">            return null;</span>
        }
    }

    @Override
    public boolean isCached(List&lt;Object&gt; oids) {
<span class="nc" id="L5424">        BitSet loaded = new BitSet(oids.size());</span>
        //check L1 cache first
<span class="nc bnc" id="L5426" title="All 2 branches missed.">        for (int i = 0; i &lt; oids.size(); i++) {</span>
<span class="nc" id="L5427">            Object oid = oids.get(i);</span>
<span class="nc bnc" id="L5428" title="All 2 branches missed.">            if (_cache.getById(oid, false) != null) {</span>
<span class="nc" id="L5429">                loaded.set(i);</span>
            }
        }
<span class="nc bnc" id="L5432" title="All 2 branches missed.">        if(loaded.cardinality()==oids.size()){</span>
<span class="nc" id="L5433">            return true;</span>
        }
<span class="nc" id="L5435">        return _store.isCached(oids, loaded);</span>
    }

    @Override
    public boolean getAllowReferenceToSiblingContext() {
<span class="nc" id="L5440">        return _allowReferenceToSiblingContext;</span>
    }

    @Override
    public void setAllowReferenceToSiblingContext(boolean allow) {
<span class="nc" id="L5445">        _allowReferenceToSiblingContext = allow;</span>
<span class="nc" id="L5446">    }</span>

    protected boolean isFlushing() {
<span class="nc bnc" id="L5449" title="All 2 branches missed.">        return ((_flags &amp; FLAG_FLUSHING) != 0);</span>
    }

     @Override
    public boolean getPostLoadOnMerge() {
<span class="nc" id="L5454">         return _postLoadOnMerge;</span>
     }

     @Override
    public void setPostLoadOnMerge(boolean allow) {
<span class="nc" id="L5459">         _postLoadOnMerge = allow;</span>
<span class="nc" id="L5460">     }</span>

    /**
     * Asserts consistencey of given automatic detachment option value.
     */
    private void assertAutoDetachValue(int value) {
<span class="nc bnc" id="L5466" title="All 4 branches missed.">       if (((value &amp; AutoDetach.DETACH_NONE) != 0) &amp;&amp; (value != AutoDetach.DETACH_NONE)) {</span>
<span class="nc" id="L5467">               throw new UserException(_loc.get(&quot;detach-none-exclusive&quot;, toAutoDetachString(value)));</span>
       }
<span class="nc" id="L5469">    }</span>

    /**
     * Generates a user-readable String from the given integral value of AutoDetach options.
     */
    private String toAutoDetachString(int value) {
<span class="nc" id="L5475">       List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L5476" title="All 2 branches missed.">       for (int i = 0; i &lt; AutoDetach.values.length; i++) {</span>
<span class="nc bnc" id="L5477" title="All 2 branches missed.">               if ((value &amp; AutoDetach.values[i]) != 0) {</span>
<span class="nc" id="L5478">                       result.add(AutoDetach.names[i]);</span>
               }
       }
<span class="nc" id="L5481">       return Arrays.toString(result.toArray(new String[result.size()]));</span>
    }

    private boolean operatingAdd(Object o){
<span class="nc" id="L5485">        _operatingDirty = true;</span>
<span class="nc" id="L5486">        return _operating.add(o);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>