<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DetachedStateManager.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-kernel</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.kernel</a> &gt; <span class="el_source">DetachedStateManager.java</span></div><h1>DetachedStateManager.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.kernel;

import java.io.IOException;
import java.io.ObjectOutput;
import java.io.Serializable;
import java.util.BitSet;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.openjpa.conf.Compatibility;
import org.apache.openjpa.enhance.PersistenceCapable;
import org.apache.openjpa.enhance.StateManager;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.meta.ClassMetaData;
import org.apache.openjpa.meta.FieldMetaData;
import org.apache.openjpa.meta.JavaTypes;
import org.apache.openjpa.meta.ValueMetaData;
import org.apache.openjpa.util.Exceptions;
import org.apache.openjpa.util.ImplHelper;
import org.apache.openjpa.util.Proxy;
import org.apache.openjpa.util.UnsupportedException;

/**
 * Internal state manager for detached instances. Does not fully
 * implement {@link OpenJPAStateManager} contract to allow for serialization.
 *
 * @author Steve Kim
 */
public class DetachedStateManager
    extends AttachStrategy
    implements OpenJPAStateManager, Serializable {

    private static final long serialVersionUID = 4112223665584731100L;

<span class="nc" id="L54">    private static final Localizer _loc = Localizer.forPackage</span>
<span class="nc" id="L55">        (DetachedStateManager.class);</span>

    private final PersistenceCapable _pc;
    private final boolean _embedded;
    private final boolean _access;
    private final BitSet _loaded;
    private final BitSet _dirty;
    private final Object _oid;
    private final Object _version;
    private final ReentrantLock _lock;
    private final boolean _useDSFForUnproxy;   // old releases will default to FALSE, which is the old behavior

    /**
     * Constructor.
     *
     * @param pc the managed instance
     * @param sm the instance's state manager
     * @param load the set of detached field indexes
     * @param access whether to allow access to unloaded fields
     * @param multithreaded whether the instance will be used concurrently
     * by multiple threads
     */
    public DetachedStateManager(PersistenceCapable pc, OpenJPAStateManager sm,
<span class="nc" id="L78">        BitSet load, boolean access, boolean multithreaded) {</span>
<span class="nc" id="L79">        _pc = pc;</span>
<span class="nc" id="L80">        _embedded = sm.isEmbedded();</span>
<span class="nc" id="L81">        _loaded = load;</span>
<span class="nc" id="L82">        _access = access;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (!sm.isFlushed())</span>
<span class="nc" id="L84">            _dirty = (BitSet) sm.getDirty().clone();</span>
        else
<span class="nc" id="L86">            _dirty = new BitSet(_loaded.length());</span>
<span class="nc" id="L87">        _oid = sm.fetchObjectId();</span>
<span class="nc" id="L88">        _version = sm.getVersion();</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">        if (multithreaded)</span>
<span class="nc" id="L90">            _lock = new ReentrantLock();</span>
        else
<span class="nc" id="L92">            _lock = null;</span>
<span class="nc bnc" id="L93" title="All 4 branches missed.">        if (sm.getContext() != null &amp;&amp; sm.getContext().getConfiguration() != null) {</span>
<span class="nc" id="L94">            Compatibility compat = sm.getContext().getConfiguration().getCompatibilityInstance();</span>
<span class="nc bnc" id="L95" title="All 4 branches missed.">            if (compat != null &amp;&amp; !compat.getIgnoreDetachedStateFieldForProxySerialization())</span>
<span class="nc" id="L96">                _useDSFForUnproxy = true;      // new 2.0 behavior</span>
            else
<span class="nc" id="L98">                _useDSFForUnproxy = false;</span>
<span class="nc" id="L99">        } else</span>
<span class="nc" id="L100">            _useDSFForUnproxy = false;</span>
<span class="nc" id="L101">    }</span>

    /////////////////////////////////
    // AttachStrategy implementation
    /////////////////////////////////

    @Override
    public Object attach(AttachManager manager, Object toAttach,
        ClassMetaData meta, PersistenceCapable into, OpenJPAStateManager owner,
        ValueMetaData ownerMeta, boolean explicit) {
<span class="nc" id="L111">        BrokerImpl broker = manager.getBroker();</span>
        StateManagerImpl sm;
<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (_embedded) {</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">            if (_dirty.length () &gt; 0)</span>
<span class="nc" id="L115">                owner.dirty(ownerMeta.getFieldMetaData().getIndex());</span>
<span class="nc" id="L116">            sm = (StateManagerImpl) broker.embed(_pc, _oid, owner, ownerMeta);</span>
<span class="nc" id="L117">            ImplHelper.toPersistenceCapable(toAttach, broker.getConfiguration())</span>
<span class="nc" id="L118">                .pcReplaceStateManager(this);</span>
        } else {
<span class="nc bnc" id="L120" title="All 2 branches missed.">            PCState state = (_dirty.length() &gt; 0) ? PCState.PDIRTY</span>
<span class="nc" id="L121">                : PCState.PCLEAN;</span>
<span class="nc" id="L122">            sm = (StateManagerImpl) broker.copy(this, state);</span>
        }
<span class="nc" id="L124">        PersistenceCapable pc = sm.getPersistenceCapable();</span>
<span class="nc" id="L125">        manager.setAttachedCopy(toAttach, pc);</span>

<span class="nc" id="L127">        manager.fireBeforeAttach(toAttach, meta);</span>

        // pre-load for efficiency: current field values for restore, dependent
        // for delete
<span class="nc" id="L131">        FieldMetaData[] fields = sm.getMetaData().getFields();</span>
<span class="nc" id="L132">        int restore = broker.getRestoreState();</span>

<span class="nc" id="L134">        boolean postLoadOnMerge = broker.getPostLoadOnMerge();</span>
<span class="nc bnc" id="L135" title="All 4 branches missed.">        if (_dirty.length() &gt; 0 || postLoadOnMerge) {</span>
<span class="nc" id="L136">            BitSet load = new BitSet(fields.length);</span>
<span class="nc bnc" id="L137" title="All 4 branches missed.">            if (postLoadOnMerge &amp;&amp; broker.getLifecycleEventManager().hasLoadListeners(pc, meta)) {</span>
                // load all fields
                // this will automatically lead to invoking the PostLoad lifecycle event
                // when the last field got set
                // @see StateManagerImpl#postLoad(String, FetchConfiguration)
<span class="nc" id="L142">                load.set(0, fields.length);</span>
            }
            else {
<span class="nc bnc" id="L145" title="All 2 branches missed.">                for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">                    if (!_dirty.get(i))</span>
<span class="nc" id="L147">                        continue;</span>

<span class="nc bnc" id="L149" title="All 3 branches missed.">                    switch (fields[i].getDeclaredTypeCode()) {</span>
                        case JavaTypes.ARRAY:
                        case JavaTypes.COLLECTION:
<span class="nc bnc" id="L152" title="All 2 branches missed.">                            if (restore == RestoreState.RESTORE_ALL</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                                || fields[i].getElement().getCascadeDelete()</span>
                                == ValueMetaData.CASCADE_AUTO)
<span class="nc" id="L155">                                load.set(i);</span>
                            break;
                        case JavaTypes.MAP:
<span class="nc bnc" id="L158" title="All 2 branches missed.">                            if (restore == RestoreState.RESTORE_ALL</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">                                || fields[i].getElement().getCascadeDelete()</span>
                                == ValueMetaData.CASCADE_AUTO
<span class="nc bnc" id="L161" title="All 2 branches missed.">                                || fields[i].getKey().getCascadeDelete()</span>
                                == ValueMetaData.CASCADE_AUTO)
<span class="nc" id="L163">                                load.set(i);</span>
                            break;
                        default:
<span class="nc bnc" id="L166" title="All 2 branches missed.">                            if (restore != RestoreState.RESTORE_NONE</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">                                || fields[i].getCascadeDelete()</span>
                                == ValueMetaData.CASCADE_AUTO)
<span class="nc" id="L169">                                load.set(i);</span>
                    }
                }
            }

<span class="nc bnc" id="L174" title="All 2 branches missed.">            if (!postLoadOnMerge) {</span>
                // prevent PostLoad callbacks even for the load operation
<span class="nc" id="L176">                sm.setPostLoadCallback(false);</span>
            }
<span class="nc" id="L178">            FetchConfiguration fc = broker.getFetchConfiguration();</span>
<span class="nc" id="L179">            sm.loadFields(load, fc, fc.getWriteLockLevel(), null);</span>
        }
<span class="nc" id="L181">        Object origVersion = sm.getVersion();</span>
<span class="nc" id="L182">        sm.setVersion(_version);</span>

<span class="nc" id="L184">        BitSet loaded = sm.getLoaded();</span>
<span class="nc" id="L185">        int set = StateManager.SET_ATTACH;</span>
<span class="nc" id="L186">        sm.setPostLoadCallback(false);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (!_loaded.get(i))</span>
<span class="nc" id="L189">                continue;</span>
            // don't reload already loaded non-mutable objects
<span class="nc bnc" id="L191" title="All 6 branches missed.">            if (!_dirty.get(i) &amp;&amp; loaded.get(i) &amp;&amp; ignoreLoaded(fields[i]))</span>
<span class="nc" id="L192">                continue;</span>

<span class="nc" id="L194">            provideField(i);</span>
<span class="nc bnc" id="L195" title="All 13 branches missed.">            switch (fields[i].getDeclaredTypeCode()) {</span>
                case JavaTypes.BOOLEAN:
<span class="nc bnc" id="L197" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc" id="L198">                        sm.settingBooleanField(pc, i,</span>
<span class="nc bnc" id="L199" title="All 6 branches missed.">                            (loaded.get(i)) &amp;&amp; sm.fetchBooleanField(i),</span>
                            longval == 1, set);
                    else
<span class="nc bnc" id="L202" title="All 2 branches missed.">                        sm.storeBooleanField(i, longval == 1);</span>
<span class="nc" id="L203">                    break;</span>
                case JavaTypes.BYTE:
<span class="nc bnc" id="L205" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">                        sm.settingByteField(pc, i, (!loaded.get(i)) ? (byte) 0</span>
<span class="nc" id="L207">                            : sm.fetchByteField(i), (byte) longval, set);</span>
                    else
<span class="nc" id="L209">                        sm.storeByteField(i, (byte) longval);</span>
<span class="nc" id="L210">                    break;</span>
                case JavaTypes.CHAR:
<span class="nc bnc" id="L212" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                        sm.settingCharField(pc, i, (!loaded.get(i)) ? (char) 0</span>
<span class="nc" id="L214">                            : sm.fetchCharField(i), (char) longval, set);</span>
                    else
<span class="nc" id="L216">                        sm.storeCharField(i, (char) longval);</span>
<span class="nc" id="L217">                    break;</span>
                case JavaTypes.INT:
<span class="nc bnc" id="L219" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">                        sm.settingIntField(pc, i, (!loaded.get(i)) ? 0</span>
<span class="nc" id="L221">                            : sm.fetchIntField(i), (int) longval, set);</span>
                    else
<span class="nc" id="L223">                        sm.storeIntField(i, (int) longval);</span>
<span class="nc" id="L224">                    break;</span>
                case JavaTypes.LONG:
<span class="nc bnc" id="L226" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                        sm.settingLongField(pc, i, (!loaded.get(i)) ? 0L</span>
<span class="nc" id="L228">                            : sm.fetchLongField(i), longval, set);</span>
                    else
<span class="nc" id="L230">                        sm.storeLongField(i, longval);</span>
<span class="nc" id="L231">                    break;</span>
                case JavaTypes.SHORT:
<span class="nc bnc" id="L233" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc" id="L234">                        sm.settingShortField(pc, i,</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                            (!loaded.get(i)) ? (short) 0 : sm.fetchShortField(i), (short) longval, set);</span>
                    else
<span class="nc" id="L237">                        sm.storeShortField(i, (short) longval);</span>
<span class="nc" id="L238">                    break;</span>
                case JavaTypes.FLOAT:
<span class="nc bnc" id="L240" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                        sm.settingFloatField(pc, i, (!loaded.get(i)) ? 0F</span>
<span class="nc" id="L242">                            : sm.fetchFloatField(i), (float) dblval, set);</span>
                    else
<span class="nc" id="L244">                        sm.storeFloatField(i, (float) dblval);</span>
<span class="nc" id="L245">                    break;</span>
                case JavaTypes.DOUBLE:
<span class="nc bnc" id="L247" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">                        sm.settingDoubleField(pc, i, (!loaded.get(i)) ? 0D</span>
<span class="nc" id="L249">                            : sm.fetchDoubleField(i), dblval, set);</span>
                    else
<span class="nc" id="L251">                        sm.storeDoubleField(i, dblval);</span>
<span class="nc" id="L252">                    break;</span>
                case JavaTypes.STRING:
<span class="nc bnc" id="L254" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                        sm.settingStringField(pc, i, (!loaded.get(i)) ? null</span>
<span class="nc" id="L256">                            : sm.fetchStringField(i), (String) objval, set);</span>
                    else
<span class="nc" id="L258">                        sm.storeStringField(i, (String) objval);</span>
<span class="nc" id="L259">                    objval = null;</span>
<span class="nc" id="L260">                    break;</span>
                case JavaTypes.PC:
                case JavaTypes.PC_UNTYPED:
<span class="nc bnc" id="L263" title="All 2 branches missed.">                    if (fields[i].getCascadeAttach() == ValueMetaData</span>
                        .CASCADE_NONE) {
                        // Use the attached copy of the object, if available
<span class="nc" id="L266">                        PersistenceCapable cpy = manager.getAttachedCopy(objval);</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">                        if (cpy != null) {</span>
<span class="nc" id="L268">                            objval = cpy;</span>
                        } else {
<span class="nc" id="L270">                        	objval = getReference(manager, objval, sm, fields[i]);</span>
                        }
<span class="nc" id="L272">                    }</span>
                    else {
<span class="nc" id="L274">                        PersistenceCapable toPC = null;</span>
<span class="nc bnc" id="L275" title="All 4 branches missed.">                        if (objval != null &amp;&amp; fields[i].isEmbeddedPC())</span>
<span class="nc" id="L276">                            toPC = ImplHelper.toPersistenceCapable(objval,</span>
<span class="nc" id="L277">                                broker.getConfiguration());</span>
<span class="nc" id="L278">                        objval = manager.attach(objval, toPC, sm, fields[i],</span>
                            false);
                    }
<span class="nc bnc" id="L281" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                        sm.settingObjectField(pc, i, (!loaded.get(i)) ? null</span>
<span class="nc" id="L283">                            : sm.fetchObjectField(i), objval, set);</span>
                    else
<span class="nc" id="L285">                        sm.storeObjectField(i, objval);</span>
<span class="nc" id="L286">                    objval = null;</span>
<span class="nc" id="L287">                    break;</span>
                case JavaTypes.COLLECTION:
<span class="nc" id="L289">                    Collection coll = (Collection) objval;</span>
<span class="nc" id="L290">                    objval = null;</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                    if (coll != null)</span>
<span class="nc" id="L292">                        coll = attachCollection(manager, coll, sm, fields[i]);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">                        sm.settingObjectField(pc, i, (!loaded.get(i)) ? null</span>
<span class="nc" id="L295">                            : sm.fetchObjectField(i), coll, set);</span>
                    else
<span class="nc" id="L297">                        sm.storeObjectField(i, coll);</span>
<span class="nc" id="L298">                    break;</span>
                case JavaTypes.MAP:
<span class="nc" id="L300">                    Map map = (Map) objval;</span>
<span class="nc" id="L301">                    objval = null;</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">                    if (map != null)</span>
<span class="nc" id="L303">                        map = attachMap(manager, map, sm, fields[i]);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                        sm.settingObjectField(pc, i, (!loaded.get(i)) ? null</span>
<span class="nc" id="L306">                            : sm.fetchObjectField(i), map, set);</span>
                    else
<span class="nc" id="L308">                        sm.storeObjectField(i, map);</span>
<span class="nc" id="L309">                    break;</span>
                default:
<span class="nc bnc" id="L311" title="All 2 branches missed.">                    if (_dirty.get(i))</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                        sm.settingObjectField(pc, i, (!loaded.get(i)) ? null</span>
<span class="nc" id="L313">                            : sm.fetchObjectField(i), objval, set);</span>
                    else
<span class="nc" id="L315">                        sm.storeObjectField(i, objval);</span>
<span class="nc" id="L316">                    objval = null;</span>
            }
        }
<span class="nc" id="L319">        sm.setPostLoadCallback(true);</span>
<span class="nc" id="L320">        pc.pcReplaceStateManager(sm);</span>

        // if we were clean at least make sure a version check is done to
        // prevent using old state
<span class="nc bnc" id="L324" title="All 8 branches missed.">        if (!sm.isVersionCheckRequired() &amp;&amp; broker.isActive()</span>
            &amp;&amp; _version != origVersion &amp;&amp; (origVersion == null
<span class="nc bnc" id="L326" title="All 2 branches missed.">            || broker.getStoreManager().compareVersion(sm, _version,</span>
            origVersion) != StoreManager.VERSION_SAME)) {
<span class="nc" id="L328">            broker.transactional(sm.getManagedInstance(), false,</span>
<span class="nc" id="L329">                manager.getBehavior());</span>
        }

<span class="nc" id="L332">        return sm.getManagedInstance();</span>
    }

    @Override
    protected Object getDetachedObjectId(AttachManager manager,
        Object toAttach) {
<span class="nc" id="L338">        return _oid;</span>
    }

    void provideField(int field) {
<span class="nc" id="L342">        _pc.pcProvideField(field);</span>
<span class="nc" id="L343">    }</span>

    @Override
    protected void provideField(Object toAttach, StateManagerImpl sm,
        int field) {
<span class="nc" id="L348">        provideField(field);</span>
<span class="nc" id="L349">    }</span>

    /**
     * Ignore if the field is not dirty but loaded
     */
    protected static boolean ignoreLoaded(FieldMetaData fmd) {
<span class="nc bnc" id="L355" title="All 2 branches missed.">        switch (fmd.getTypeCode()) {</span>
            case JavaTypes.BOOLEAN:
            case JavaTypes.BOOLEAN_OBJ:
            case JavaTypes.BYTE:
            case JavaTypes.BYTE_OBJ:
            case JavaTypes.INT:
            case JavaTypes.INT_OBJ:
            case JavaTypes.LONG:
            case JavaTypes.LONG_OBJ:
            case JavaTypes.SHORT:
            case JavaTypes.SHORT_OBJ:
            case JavaTypes.DOUBLE:
            case JavaTypes.DOUBLE_OBJ:
            case JavaTypes.FLOAT:
            case JavaTypes.FLOAT_OBJ:
            case JavaTypes.CHAR:
            case JavaTypes.CHAR_OBJ:
            case JavaTypes.STRING:
<span class="nc" id="L373">                return true;</span>
        }
<span class="nc" id="L375">        return false;</span>
    }

    ///////////////////////////////
    // StateManager implementation
    ///////////////////////////////

    @Override
    public Object getGenericContext() {
<span class="nc" id="L384">        return null;</span>
    }

    @Override
    public Object getPCPrimaryKey(Object oid, int field) {
<span class="nc" id="L389">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public StateManager replaceStateManager(StateManager sm) {
<span class="nc" id="L394">        return sm;</span>
    }

    @Override
    public Object getVersion() {
<span class="nc" id="L399">        return _version;</span>
    }

    @Override
    public void setVersion(Object version) {
<span class="nc" id="L404">        throw new UnsupportedException();</span>
    }

    @Override
    public boolean isDirty() {
<span class="nc bnc" id="L409" title="All 2 branches missed.">        return _dirty.length() != 0;</span>
    }

    @Override
    public boolean isTransactional() {
<span class="nc" id="L414">        return false;</span>
    }

    @Override
    public boolean isPersistent() {
<span class="nc" id="L419">        return false;</span>
    }

    @Override
    public boolean isNew() {
<span class="nc" id="L424">        return false;</span>
    }

    @Override
    public boolean isDeleted() {
<span class="nc" id="L429">        return false;</span>
    }

    @Override
    public boolean isDetached() {
<span class="nc" id="L434">        return true;</span>
    }

    @Override
    public boolean isVersionUpdateRequired() {
<span class="nc" id="L439">        return false;</span>
    }

    @Override
    public boolean isVersionCheckRequired() {
<span class="nc" id="L444">        return false;</span>
    }

    @Override
    public void dirty(String field) {
        // should we store ClassMetaData?
<span class="nc" id="L450">        throw new UnsupportedException();</span>
    }

    @Override
    public Object fetchObjectId() {
<span class="nc" id="L455">        return _oid;</span>
    }

    @Override
    public void accessingField(int idx) {
<span class="nc bnc" id="L460" title="All 4 branches missed.">        if (!_access &amp;&amp; !_loaded.get(idx))</span>
            // do not access the pc fields by implictly invoking _pc.toString()
            // may cause infinite loop if again tries to access unloaded field
<span class="nc" id="L463">            throw new IllegalStateException(_loc.get(&quot;unloaded-detached&quot;,</span>
<span class="nc" id="L464">               Exceptions.toString(_pc)).getMessage());</span>
<span class="nc" id="L465">    }</span>

    @Override
    public boolean serializing() {
<span class="nc" id="L469">        return false;</span>
    }

    @Override
    public boolean writeDetached(ObjectOutput out)
        throws IOException {
<span class="nc" id="L475">        out.writeObject(_pc.pcGetDetachedState());</span>
<span class="nc" id="L476">        out.writeObject(this);</span>
<span class="nc" id="L477">        return false;</span>
    }

    @Override
    public void proxyDetachedDeserialized(int idx) {
<span class="nc" id="L482">        lock();</span>
        try {
<span class="nc" id="L484">            _pc.pcProvideField(idx);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">            if (objval instanceof Proxy)</span>
<span class="nc" id="L486">                ((Proxy) objval).setOwner(this, idx);</span>
<span class="nc" id="L487">            objval = null;</span>
        } finally {
<span class="nc" id="L489">            unlock();</span>
        }
<span class="nc" id="L491">    }</span>

    @Override
    public void settingBooleanField(PersistenceCapable pc, int idx,
        boolean cur, boolean next, int set) {
<span class="nc" id="L496">        accessingField(idx);</span>
<span class="nc bnc" id="L497" title="All 4 branches missed.">        if (cur == next || !_loaded.get(idx))</span>
<span class="nc" id="L498">            return;</span>
<span class="nc" id="L499">        lock();</span>
        try {
<span class="nc" id="L501">            _dirty.set(idx);</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">            longval = next ? 1 : 0;</span>
<span class="nc" id="L503">            pc.pcReplaceField(idx);</span>
        } finally {
<span class="nc" id="L505">            unlock();</span>
        }
<span class="nc" id="L507">    }</span>

    @Override
    public void settingCharField(PersistenceCapable pc, int idx, char cur,
        char next, int set) {
<span class="nc" id="L512">        accessingField(idx);</span>
<span class="nc bnc" id="L513" title="All 4 branches missed.">        if (cur == next || !_loaded.get(idx))</span>
<span class="nc" id="L514">            return;</span>
<span class="nc" id="L515">        lock();</span>
        try {
<span class="nc" id="L517">            _dirty.set(idx);</span>
<span class="nc" id="L518">            longval = next;</span>
<span class="nc" id="L519">            pc.pcReplaceField(idx);</span>
        } finally {
<span class="nc" id="L521">            unlock();</span>
        }
<span class="nc" id="L523">    }</span>

    @Override
    public void settingByteField(PersistenceCapable pc, int idx, byte cur,
        byte next, int set) {
<span class="nc" id="L528">        accessingField(idx);</span>
<span class="nc bnc" id="L529" title="All 4 branches missed.">        if (cur == next || !_loaded.get(idx))</span>
<span class="nc" id="L530">            return;</span>
<span class="nc" id="L531">        lock();</span>
        try {
<span class="nc" id="L533">            _dirty.set(idx);</span>
<span class="nc" id="L534">            longval = next;</span>
<span class="nc" id="L535">            pc.pcReplaceField(idx);</span>
        } finally {
<span class="nc" id="L537">            unlock();</span>
        }
<span class="nc" id="L539">    }</span>

    @Override
    public void settingShortField(PersistenceCapable pc, int idx, short cur,
        short next, int set) {
<span class="nc" id="L544">        accessingField(idx);</span>
<span class="nc bnc" id="L545" title="All 4 branches missed.">        if (cur == next || !_loaded.get(idx))</span>
<span class="nc" id="L546">            return;</span>
<span class="nc" id="L547">        lock();</span>
        try {
<span class="nc" id="L549">            _dirty.set(idx);</span>
<span class="nc" id="L550">            longval = next;</span>
<span class="nc" id="L551">            pc.pcReplaceField(idx);</span>
        } finally {
<span class="nc" id="L553">            unlock();</span>
        }
<span class="nc" id="L555">    }</span>

    @Override
    public void settingIntField(PersistenceCapable pc, int idx, int cur,
        int next, int set) {
<span class="nc" id="L560">        accessingField(idx);</span>
<span class="nc bnc" id="L561" title="All 4 branches missed.">        if (cur == next || !_loaded.get(idx))</span>
<span class="nc" id="L562">            return;</span>
<span class="nc" id="L563">        lock();</span>
        try {
<span class="nc" id="L565">            _dirty.set(idx);</span>
<span class="nc" id="L566">            longval = next;</span>
<span class="nc" id="L567">            pc.pcReplaceField(idx);</span>
        } finally {
<span class="nc" id="L569">            unlock();</span>
        }
<span class="nc" id="L571">    }</span>

    @Override
    public void settingLongField(PersistenceCapable pc, int idx, long cur,
        long next, int set) {
<span class="nc" id="L576">        accessingField(idx);</span>
<span class="nc bnc" id="L577" title="All 4 branches missed.">        if (cur == next || !_loaded.get(idx))</span>
<span class="nc" id="L578">            return;</span>
<span class="nc" id="L579">        lock();</span>
        try {
<span class="nc" id="L581">            _dirty.set(idx);</span>
<span class="nc" id="L582">            longval = next;</span>
<span class="nc" id="L583">            pc.pcReplaceField(idx);</span>
        } finally {
<span class="nc" id="L585">            unlock();</span>
        }
<span class="nc" id="L587">    }</span>

    @Override
    public void settingFloatField(PersistenceCapable pc, int idx, float cur,
        float next, int set) {
<span class="nc" id="L592">        accessingField(idx);</span>
<span class="nc bnc" id="L593" title="All 4 branches missed.">        if (cur == next || !_loaded.get(idx))</span>
<span class="nc" id="L594">            return;</span>
<span class="nc" id="L595">        lock();</span>
        try {
<span class="nc" id="L597">            _dirty.set(idx);</span>
<span class="nc" id="L598">            dblval = next;</span>
<span class="nc" id="L599">            pc.pcReplaceField(idx);</span>
        } finally {
<span class="nc" id="L601">            unlock();</span>
        }
<span class="nc" id="L603">    }</span>

    @Override
    public void settingDoubleField(PersistenceCapable pc, int idx, double cur,
        double next, int set) {
<span class="nc" id="L608">        accessingField(idx);</span>
<span class="nc bnc" id="L609" title="All 4 branches missed.">        if (cur == next || !_loaded.get(idx))</span>
<span class="nc" id="L610">            return;</span>
<span class="nc" id="L611">        lock();</span>
        try {
<span class="nc" id="L613">            _dirty.set(idx);</span>
<span class="nc" id="L614">            dblval = next;</span>
<span class="nc" id="L615">            pc.pcReplaceField(idx);</span>
        } finally {
<span class="nc" id="L617">            unlock();</span>
        }
<span class="nc" id="L619">    }</span>

    @Override
    public void settingStringField(PersistenceCapable pc, int idx, String cur,
        String next, int set) {
<span class="nc" id="L624">        accessingField(idx);</span>
<span class="nc bnc" id="L625" title="All 6 branches missed.">        if (cur == next || (cur != null &amp;&amp; cur.equals(next))</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">                || !_loaded.get(idx))</span>
<span class="nc" id="L627">            return;</span>
<span class="nc" id="L628">        lock();</span>
        try {
<span class="nc" id="L630">            _dirty.set(idx);</span>
<span class="nc" id="L631">            objval = next;</span>
<span class="nc" id="L632">            pc.pcReplaceField(idx);</span>
        } finally {
<span class="nc" id="L634">            unlock();</span>
<span class="nc" id="L635">            objval = null;</span>
        }
<span class="nc" id="L637">    }</span>

    @Override
    public void settingObjectField(PersistenceCapable pc, int idx, Object cur,
        Object next, int set) {
<span class="nc" id="L642">        accessingField(idx);</span>
<span class="nc bnc" id="L643" title="All 4 branches missed.">        if (cur == next || !_loaded.get(idx))</span>
<span class="nc" id="L644">            return;</span>
<span class="nc" id="L645">        lock();</span>
        try {
<span class="nc" id="L647">            _dirty.set(idx);</span>
<span class="nc" id="L648">            objval = next;</span>
<span class="nc" id="L649">            pc.pcReplaceField(idx);</span>
        } finally {
<span class="nc" id="L651">            unlock();</span>
<span class="nc" id="L652">            objval = null;</span>
        }
<span class="nc" id="L654">    }</span>

    @Override
    public void providedBooleanField(PersistenceCapable pc, int idx,
        boolean cur) {
<span class="nc bnc" id="L659" title="All 2 branches missed.">        longval = cur ? 1 : 0;</span>
<span class="nc" id="L660">    }</span>

    @Override
    public void providedCharField(PersistenceCapable pc, int idx, char cur) {
<span class="nc" id="L664">        longval = cur;</span>
<span class="nc" id="L665">    }</span>

    @Override
    public void providedByteField(PersistenceCapable pc, int idx, byte cur) {
<span class="nc" id="L669">        longval = cur;</span>
<span class="nc" id="L670">    }</span>

    @Override
    public void providedShortField(PersistenceCapable pc, int idx, short cur) {
<span class="nc" id="L674">        longval = cur;</span>
<span class="nc" id="L675">    }</span>

    @Override
    public void providedIntField(PersistenceCapable pc, int idx, int cur) {
<span class="nc" id="L679">        longval = cur;</span>
<span class="nc" id="L680">    }</span>

    @Override
    public void providedLongField(PersistenceCapable pc, int idx, long cur) {
<span class="nc" id="L684">        longval = cur;</span>
<span class="nc" id="L685">    }</span>

    @Override
    public void providedFloatField(PersistenceCapable pc, int idx, float cur) {
<span class="nc" id="L689">        dblval = cur;</span>
<span class="nc" id="L690">    }</span>

    @Override
    public void providedDoubleField(PersistenceCapable pc, int idx,
        double cur) {
<span class="nc" id="L695">        dblval = cur;</span>
<span class="nc" id="L696">    }</span>

    @Override
    public void providedStringField(PersistenceCapable pc, int idx,
        String cur) {
<span class="nc" id="L701">        objval = cur;</span>
<span class="nc" id="L702">    }</span>

    @Override
    public void providedObjectField(PersistenceCapable pc, int idx,
        Object cur) {
<span class="nc" id="L707">        objval = cur;</span>
<span class="nc" id="L708">    }</span>

    @Override
    public boolean replaceBooleanField(PersistenceCapable pc, int idx) {
<span class="nc bnc" id="L712" title="All 2 branches missed.">        return longval == 1;</span>
    }

    @Override
    public char replaceCharField(PersistenceCapable pc, int idx) {
<span class="nc" id="L717">        return (char) longval;</span>
    }

    @Override
    public byte replaceByteField(PersistenceCapable pc, int idx) {
<span class="nc" id="L722">        return (byte) longval;</span>
    }

    @Override
    public short replaceShortField(PersistenceCapable pc, int idx) {
<span class="nc" id="L727">        return (short) longval;</span>
    }

    @Override
    public int replaceIntField(PersistenceCapable pc, int idx) {
<span class="nc" id="L732">        return (int) longval;</span>
    }

    @Override
    public long replaceLongField(PersistenceCapable pc, int idx) {
<span class="nc" id="L737">        return longval;</span>
    }

    @Override
    public float replaceFloatField(PersistenceCapable pc, int idx) {
<span class="nc" id="L742">        return (float) dblval;</span>
    }

    @Override
    public double replaceDoubleField(PersistenceCapable pc, int idx) {
<span class="nc" id="L747">        return dblval;</span>
    }

    @Override
    public String replaceStringField(PersistenceCapable pc, int idx) {
<span class="nc" id="L752">        String str = (String) objval;</span>
<span class="nc" id="L753">        objval = null;</span>
<span class="nc" id="L754">        return str;</span>
    }

    @Override
    public Object replaceObjectField(PersistenceCapable pc, int idx) {
<span class="nc" id="L759">        Object ret = objval;</span>
<span class="nc" id="L760">        objval = null;</span>
<span class="nc" id="L761">        return ret;</span>
    }

    //////////////////////////////////////
    // OpenJPAStateManager implementation
    //////////////////////////////////////

    @Override
    public void initialize(Class forType, PCState state) {
<span class="nc" id="L770">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void load(FetchConfiguration fetch) {
<span class="nc" id="L775">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object getManagedInstance() {
<span class="nc" id="L780">        return _pc;</span>
    }

    @Override
    public PersistenceCapable getPersistenceCapable() {
<span class="nc" id="L785">        return _pc;</span>
    }

    @Override
    public ClassMetaData getMetaData() {
<span class="nc" id="L790">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public OpenJPAStateManager getOwner() {
<span class="nc" id="L795">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public int getOwnerIndex() {
<span class="nc" id="L800">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean isEmbedded() {
<span class="nc" id="L805">        return _embedded;</span>
    }

    @Override
    public boolean isFlushed() {
<span class="nc" id="L810">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean isFlushedDirty() {
<span class="nc" id="L815">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean isProvisional() {
<span class="nc" id="L820">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public BitSet getLoaded() {
<span class="nc" id="L825">        return _loaded;</span>
    }

    @Override
    public BitSet getDirty() {
<span class="nc" id="L830">        return _dirty;</span>
    }

    /**
     * Should DetachedStateField be used by Proxies to determine when to remove
     * $proxy wrappers during serialization.
     * @since 2.0.0
     */
    public boolean getUseDSFForUnproxy() {
<span class="nc" id="L839">        return _useDSFForUnproxy;</span>
    }

    @Override
    public BitSet getFlushed() {
<span class="nc" id="L844">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public BitSet getUnloaded(FetchConfiguration fetch) {
<span class="nc" id="L849">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object newProxy(int field) {
<span class="nc" id="L854">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object newFieldProxy(int field) {
<span class="nc" id="L859">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean isDefaultValue(int field) {
<span class="nc" id="L864">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public StoreContext getContext() {
<span class="nc" id="L869">        return null;</span>
    }

    @Override
    public PCState getPCState() {
<span class="nc" id="L874">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object getObjectId() {
<span class="nc" id="L879">        return _oid;</span>
    }

    @Override
    public void setObjectId(Object oid) {
<span class="nc" id="L884">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean assignObjectId(boolean flush) {
<span class="nc" id="L889">        return true;</span>
    }

    @Override
    public Object getId() {
<span class="nc" id="L894">        return getObjectId();</span>
    }

    @Override
    public Object getLock() {
<span class="nc" id="L899">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void setLock(Object lock) {
<span class="nc" id="L904">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void setNextVersion(Object version) {
<span class="nc" id="L909">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object getImplData() {
<span class="nc" id="L914">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object setImplData(Object data, boolean cacheable) {
<span class="nc" id="L919">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean isImplDataCacheable() {
<span class="nc" id="L924">        return false;</span>
    }

    @Override
    public Object getImplData(int field) {
<span class="nc" id="L929">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object setImplData(int field, Object data) {
<span class="nc" id="L934">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean isImplDataCacheable(int field) {
<span class="nc" id="L939">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object getIntermediate(int field) {
<span class="nc" id="L944">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void setIntermediate(int field, Object data) {
<span class="nc" id="L949">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void removed(int field, Object removed, boolean key) {
<span class="nc" id="L954">        dirty(field);</span>
<span class="nc" id="L955">    }</span>

    @Override
    public boolean beforeRefresh(boolean all) {
<span class="nc" id="L959">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void dirty(int field) {
<span class="nc" id="L964">        lock();</span>
        try {
<span class="nc" id="L966">            _dirty.set(field);</span>
        } finally {
<span class="nc" id="L968">            unlock();</span>
        }
<span class="nc" id="L970">    }</span>

    @Override
    public void storeBoolean(int field, boolean extVal) {
<span class="nc" id="L974">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void storeByte(int field, byte extVal) {
<span class="nc" id="L979">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void storeChar(int field, char extVal) {
<span class="nc" id="L984">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void storeInt(int field, int extVal) {
<span class="nc" id="L989">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void storeShort(int field, short extVal) {
<span class="nc" id="L994">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void storeLong(int field, long extVal) {
<span class="nc" id="L999">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void storeFloat(int field, float extVal) {
<span class="nc" id="L1004">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void storeDouble(int field, double extVal) {
<span class="nc" id="L1009">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void storeString(int field, String extVal) {
<span class="nc" id="L1014">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void storeObject(int field, Object extVal) {
<span class="nc" id="L1019">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void store(int field, Object extVal) {
<span class="nc" id="L1024">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void storeField(int field, Object value) {
<span class="nc" id="L1029">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean fetchBoolean(int field) {
<span class="nc" id="L1034">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public byte fetchByte(int field) {
<span class="nc" id="L1039">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public char fetchChar(int field) {
<span class="nc" id="L1044">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public short fetchShort(int field) {
<span class="nc" id="L1049">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public int fetchInt(int field) {
<span class="nc" id="L1054">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public long fetchLong(int field) {
<span class="nc" id="L1059">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public float fetchFloat(int field) {
<span class="nc" id="L1064">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public double fetchDouble(int field) {
<span class="nc" id="L1069">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public String fetchString(int field) {
<span class="nc" id="L1074">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object fetchObject(int field) {
<span class="nc" id="L1079">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object fetch(int field) {
<span class="nc" id="L1084">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object fetchField(int field, boolean transitions) {
<span class="nc" id="L1089">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Object fetchInitialField(int field) {
<span class="nc" id="L1094">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void setRemote(int field, Object value) {
<span class="nc" id="L1099">        throw new UnsupportedOperationException();</span>
    }

    public void lock() {
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (_lock != null)</span>
<span class="nc" id="L1104">            _lock.lock();</span>
<span class="nc" id="L1105">    }</span>

    public void unlock() {
<span class="nc bnc" id="L1108" title="All 2 branches missed.">        if (_lock != null)</span>
<span class="nc" id="L1109">            _lock.unlock();</span>
<span class="nc" id="L1110">    }</span>

    @Override
    public boolean isDelayed(int field) {
<span class="nc" id="L1114">        return false;</span>
    }

    @Override
    public void setDelayed(int field, boolean delay) {
<span class="nc" id="L1119">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void loadDelayedField(int field) {
<span class="nc" id="L1124">        throw new UnsupportedOperationException();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>