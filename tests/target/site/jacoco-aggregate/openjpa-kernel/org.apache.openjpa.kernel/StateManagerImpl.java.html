<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StateManagerImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-kernel</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.kernel</a> &gt; <span class="el_source">StateManagerImpl.java</span></div><h1>StateManagerImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.kernel;

import java.io.IOException;
import java.io.NotSerializableException;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.reflect.Modifier;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Calendar;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.TimeZone;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.openjpa.conf.OpenJPAConfiguration;
import org.apache.openjpa.enhance.DynamicPersistenceCapable;
import org.apache.openjpa.enhance.FieldManager;
import org.apache.openjpa.enhance.ManagedInstanceProvider;
import org.apache.openjpa.enhance.PCRegistry;
import org.apache.openjpa.enhance.PersistenceCapable;
import org.apache.openjpa.enhance.RedefinitionHelper;
import org.apache.openjpa.enhance.StateManager;
import org.apache.openjpa.event.LifecycleEvent;
import org.apache.openjpa.event.LifecycleEventManager;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.meta.AccessCode;
import org.apache.openjpa.meta.ClassMetaData;
import org.apache.openjpa.meta.FetchGroup;
import org.apache.openjpa.meta.FieldMetaData;
import org.apache.openjpa.meta.JavaTypes;
import org.apache.openjpa.meta.UpdateStrategies;
import org.apache.openjpa.meta.ValueMetaData;
import org.apache.openjpa.meta.ValueStrategies;
import org.apache.openjpa.util.ApplicationIds;
import org.apache.openjpa.util.Exceptions;
import org.apache.openjpa.util.ImplHelper;
import org.apache.openjpa.util.InternalException;
import org.apache.openjpa.util.InvalidStateException;
import org.apache.openjpa.util.ObjectNotFoundException;
import org.apache.openjpa.util.OpenJPAId;
import org.apache.openjpa.util.ProxyManager;
import org.apache.openjpa.util.RuntimeExceptionTranslator;
import org.apache.openjpa.util.UserException;

/**
 * Implementation of the {@link OpenJPAStateManager} interface for use
 * with this runtime. Each state manager manages the state of a single
 * persistence capable instance. The state manager is also responsible for
 * all communications about the instance to the {@link StoreManager}.
 *  The state manager uses the State pattern in both its interaction with
 * the governed instance and its interaction with the broker.
 * In its interactions with the persistence capable instance, it uses the
 * {@link FieldManager} interface. Similarly, when interacting with the
 * broker, it uses the {@link PCState} singleton that represents
 * the current lifecycle state of the instance.
 *
 * @author Abe White
 */
public class StateManagerImpl implements OpenJPAStateManager, Serializable {
    
    private static final long serialVersionUID = 1L;
    public static final int LOAD_FGS = 0;
    public static final int LOAD_ALL = 1;
    public static final int LOAD_SERIALIZE = 2;

    private static final int FLAG_SAVE = 2 &lt;&lt; 0;
    private static final int FLAG_DEREF = 2 &lt;&lt; 1;
    private static final int FLAG_LOADED = 2 &lt;&lt; 2;
    private static final int FLAG_READ_LOCKED = 2 &lt;&lt; 3;
    private static final int FLAG_WRITE_LOCKED = 2 &lt;&lt; 4;
    private static final int FLAG_OID_ASSIGNED = 2 &lt;&lt; 5;
    private static final int FLAG_LOADING = 2 &lt;&lt; 6;
    private static final int FLAG_PRE_DELETING = 2 &lt;&lt; 7;
    private static final int FLAG_FLUSHED = 2 &lt;&lt; 8;
    private static final int FLAG_PRE_FLUSHED = 2 &lt;&lt; 9;
    private static final int FLAG_FLUSHED_DIRTY = 2 &lt;&lt; 10;
    private static final int FLAG_IMPL_CACHE = 2 &lt;&lt; 11;
    private static final int FLAG_INVERSES = 2 &lt;&lt; 12;
    private static final int FLAG_NO_UNPROXY = 2 &lt;&lt; 13;
    private static final int FLAG_VERSION_CHECK = 2 &lt;&lt; 14;
    private static final int FLAG_VERSION_UPDATE = 2 &lt;&lt; 15;
    private static final int FLAG_DETACHING = 2 &lt;&lt; 16;
    private static final int FLAG_EMBED_DEREF = 2 &lt;&lt; 17;

<span class="nc" id="L112">    private static final Localizer _loc = Localizer.forPackage</span>
<span class="nc" id="L113">        (StateManagerImpl.class);</span>

    // information about the instance
<span class="nc" id="L116">    private transient PersistenceCapable _pc = null;</span>
<span class="nc" id="L117">    protected transient ClassMetaData _meta = null;</span>
<span class="nc" id="L118">    protected BitSet _loaded = null;</span>

    // Care needs to be taken when accessing these fields as they will can be null if no fields are
    // dirty, or have been flushed.
<span class="nc" id="L122">    private BitSet _dirty = null;</span>
<span class="nc" id="L123">    private BitSet _flush = null;</span>

<span class="nc" id="L125">    private BitSet _delayed = null;</span>
<span class="nc" id="L126">    private int _flags = 0;</span>

    // id is the state manager identity; oid is the persistent identity.  oid
    // may be null for embedded and transient-transactional objects or new
    // instances that haven't been assigned an oid.  id is reassigned to oid
    // on successful oid assignment (or flush completion if assignment is
    // during flush)
<span class="nc" id="L133">    private Object _id = null;</span>
<span class="nc" id="L134">    private Object _oid = null;</span>

    // the managing persistence manager and lifecycle state
    private transient BrokerImpl _broker; // this is serialized specially
<span class="nc" id="L138">    protected PCState _state = PCState.TRANSIENT;</span>

    // the current and last loaded version indicators, and the lock object
<span class="nc" id="L141">    protected Object _version = null;</span>
<span class="nc" id="L142">    protected Object _loadVersion = null;</span>
<span class="nc" id="L143">    private Object _lock = null;</span>
<span class="nc" id="L144">    private int _readLockLevel = -1;</span>
<span class="nc" id="L145">    private int _writeLockLevel = -1;</span>

    // delegates when providing/replacing instance data
<span class="nc" id="L148">    private SingleFieldManager _single = null;</span>
<span class="nc" id="L149">    private SaveFieldManager _saved = null;</span>
<span class="nc" id="L150">    private FieldManager _fm = null;</span>

    // impldata; field impldata and intermediate data share the same array
<span class="nc" id="L153">    private Object _impl = null;</span>
<span class="nc" id="L154">    protected Object[] _fieldImpl = null;</span>

    // information about the owner of this instance, if it is embedded
<span class="nc" id="L157">    private StateManagerImpl _owner = null;</span>
    // for embeddable object from query result
<span class="nc" id="L159">    private Object _ownerId = null;</span>
<span class="nc" id="L160">    private int _ownerIndex = -1;</span>
<span class="nc" id="L161">    private List&lt;FieldMetaData&gt; _mappedByIdFields = null;</span>

<span class="nc" id="L163">    private transient ReentrantLock _instanceLock = null;</span>

<span class="nc" id="L165">    private int _datePrecision = -1;</span>

    /**
     * &lt;p&gt;set to &lt;code&gt;false&lt;/code&gt; to prevent the postLoad method from
     * sending lifecycle callback events.&lt;/p&gt;
     * &lt;p&gt;Callbacks are enabled by default&lt;/&gt;
     */
<span class="nc" id="L172">    private boolean postLoadCallback = true;</span>

    /**
     * Constructor; supply id, type metadata, and owning persistence manager.
     */
<span class="nc" id="L177">    protected StateManagerImpl(Object id, ClassMetaData meta, BrokerImpl broker) {</span>
<span class="nc" id="L178">        _id = id;</span>
<span class="nc" id="L179">        _meta = meta;</span>
<span class="nc" id="L180">        _broker = broker;</span>
<span class="nc" id="L181">        _single = new SingleFieldManager(this, broker);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (broker.getMultithreaded())</span>
<span class="nc" id="L183">        	_instanceLock = new ReentrantLock();</span>

<span class="nc bnc" id="L185" title="All 4 branches missed.">        if (_meta.getIdentityType() == ClassMetaData.ID_UNKNOWN &amp;&amp; !_meta.isEmbeddable())</span>
<span class="nc" id="L186">            throw new UserException(_loc.get(&quot;meta-unknownid&quot;, _meta));</span>
<span class="nc" id="L187">    }</span>

    /**
     * Create a new StateManager instance based on the StateManager provided. A
     * new PersistenceCapable instance will be created and associated with the
     * new StateManager. All fields will be copied into the ne PC instance as
     * well as the dirty, loaded, and flushed bitsets.
     *
     * @param sm A statemanager instance which will effectively be cloned.
     */
    public StateManagerImpl(StateManagerImpl sm) {
<span class="nc" id="L198">        this(sm, sm.getPCState());</span>
<span class="nc" id="L199">    }</span>

    /**
     * Create a new StateManager instance, optionally overriding the state
     * (FLUSHED, DELETED, etc) of the underlying PersistenceCapable instance).
     *
     * @param sm
     *            A statemanager instance which will effectively be cloned.
     * @param newState
     *            The new state of the underlying persistence capable object.
     */
    public StateManagerImpl(StateManagerImpl sm, PCState newState) {
<span class="nc" id="L211">        this(sm.getId(), sm.getMetaData(), sm.getBroker());</span>

<span class="nc" id="L213">        PersistenceCapable origPC = sm.getPersistenceCapable();</span>
<span class="nc" id="L214">        _pc = origPC.pcNewInstance(sm, false);</span>

<span class="nc" id="L216">        int[] fields = new int[sm.getMetaData().getFields().length];</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">        for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc" id="L218">            fields[i] = i;</span>
        }
<span class="nc" id="L220">        _pc.pcCopyFields(origPC, fields);</span>
<span class="nc" id="L221">        _pc.pcReplaceStateManager(this);</span>
<span class="nc" id="L222">        _state = newState;</span>

        // clone the field bitsets.
<span class="nc" id="L225">        _dirty=(BitSet)sm.getDirty().clone();</span>
<span class="nc" id="L226">        _loaded = (BitSet)sm.getLoaded().clone();</span>
<span class="nc" id="L227">        _flush = (BitSet) sm.getFlushed().clone();</span>
<span class="nc" id="L228">        _version = sm.getVersion();</span>

<span class="nc" id="L230">        _oid = sm.getObjectId();</span>
<span class="nc" id="L231">        _id = sm.getId();</span>

        // more data may need to be copied.
<span class="nc" id="L234">    }</span>

    /**
     * Set the owning state and field if this is an embedded instance.
     */
    void setOwner(StateManagerImpl owner, ValueMetaData ownerMeta) {
<span class="nc" id="L240">        _owner = owner;</span>
<span class="nc" id="L241">        _ownerIndex = ownerMeta.getFieldMetaData().getIndex();</span>
<span class="nc" id="L242">    }</span>

    /**
     * Whether this state manager is in the middle of a load.
     */
    boolean isLoading() {
<span class="nc bnc" id="L248" title="All 2 branches missed.">        return (_flags &amp; FLAG_LOADING) &gt; 0;</span>
    }

    /**
     * Whether this state manager is in the middle of a load initiated
     * by outside code; for any internal methods that cause loading, the
     * loading flag is set automatically.
     */
    void setLoading(boolean loading) {
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (loading)</span>
<span class="nc" id="L258">            _flags |= FLAG_LOADING;</span>
        else
<span class="nc" id="L260">            _flags &amp;= ~FLAG_LOADING;</span>
<span class="nc" id="L261">    }</span>

    /**
     * Set or reset the lifecycle state of the managed instance. If the
     * transactional state of the instance changes, it will be enlisted/
     * delisted from the current transaction as necessary. The given
     * state will be initialized after being set. If the given state
     * is the same as the current state, this method will have no effect.
     */
    private void setPCState(PCState state) {
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (_state == state)</span>
<span class="nc" id="L272">            return;</span>

<span class="nc" id="L274">        PCState prev = _state;</span>
<span class="nc" id="L275">        lock();</span>
        try {
            // notify the store manager that we're changing states; can veto
<span class="nc" id="L278">            _broker.getStoreManager().beforeStateChange(this, _state, state);</span>

            // replace state
<span class="nc" id="L281">            boolean wasDeleted = _state.isDeleted();</span>
<span class="nc" id="L282">            boolean wasDirty = _state.isDirty();</span>
<span class="nc" id="L283">            boolean wasPending = _state.isPendingTransactional();</span>
<span class="nc" id="L284">            _state = state;</span>

            // enlist/delist from transaction
<span class="nc bnc" id="L287" title="All 2 branches missed.">            if (_state.isTransactional()) {</span>
<span class="nc" id="L288">                _broker.addToTransaction(this);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">                if (_state.isDeleted() != wasDeleted)</span>
<span class="nc bnc" id="L290" title="All 4 branches missed.">                    _broker.setDirty(this, !wasDirty || isFlushed());</span>
<span class="nc bnc" id="L291" title="All 4 branches missed.">                else if (_state.isDirty() &amp;&amp; !wasDirty)</span>
<span class="nc" id="L292">                    _broker.setDirty(this, true);</span>
<span class="nc bnc" id="L293" title="All 4 branches missed.">            } else if (!wasPending &amp;&amp; _state.isPendingTransactional())</span>
<span class="nc" id="L294">                _broker.addToPendingTransaction(this);</span>
<span class="nc bnc" id="L295" title="All 4 branches missed.">            else if (wasPending &amp;&amp; !_state.isPendingTransactional())</span>
<span class="nc" id="L296">                _broker.removeFromPendingTransaction(this);</span>
            else
<span class="nc" id="L298">                _broker.removeFromTransaction(this);</span>

<span class="nc" id="L300">            _state.initialize(this, prev);</span>
<span class="nc bnc" id="L301" title="All 4 branches missed.">            if (_state.isDeleted() &amp;&amp; !wasDeleted)</span>
<span class="nc" id="L302">                fireLifecycleEvent(LifecycleEvent.AFTER_DELETE);</span>
        } finally {
<span class="nc" id="L304">            unlock();</span>
        }
<span class="nc" id="L306">    }</span>

    //////////////////////////////////////
    // OpenJPAStateManager implementation
    //////////////////////////////////////

    @Override
    public void initialize(Class cls, PCState state) {
        // check to see if our current object id instance is the
        // correct id type for the specified class; this is for cases
        // when we have an application id hierarchy and we had set the
        // metadata to a superclass id -- the subclass' id may be a
        // different class, so we need to reset it
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (_meta.getDescribedType() != cls) {</span>
<span class="nc" id="L320">            ClassMetaData sub = _meta.getRepository().getMetaData</span>
<span class="nc" id="L321">                (cls, _broker.getClassLoader(), true);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (_oid != null) {</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                if (_meta.getIdentityType() == ClassMetaData.ID_DATASTORE)</span>
<span class="nc" id="L324">                    _oid = _broker.getStoreManager().copyDataStoreId(_oid,</span>
                        sub);
<span class="nc bnc" id="L326" title="All 2 branches missed.">                else if (_meta.isOpenJPAIdentity())</span>
<span class="nc" id="L327">                    _oid = ApplicationIds.copy(_oid, sub);</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">                else if (sub.getObjectIdType() != _meta.getObjectIdType()) {</span>
<span class="nc" id="L329">                    Object[] pkFields = ApplicationIds.toPKValues(_oid, _meta);</span>
<span class="nc" id="L330">                    _oid = ApplicationIds.fromPKValues(pkFields, sub);</span>
                }
            }
<span class="nc" id="L333">            _meta = sub;</span>
        }

<span class="nc" id="L336">        PersistenceCapable inst = PCRegistry.newInstance(cls, this, _oid, true);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        if (inst == null) {</span>
            // the instance was null: check to see if the instance is
            // abstract (as can sometimes be the case when the
            // class discriminator strategy is not configured correctly)
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (Modifier.isAbstract(cls.getModifiers()))</span>
<span class="nc" id="L342">                throw new UserException(_loc.get(&quot;instantiate-abstract&quot;,</span>
<span class="nc" id="L343">                    cls.getName(), _oid));</span>
<span class="nc" id="L344">            throw new InternalException();</span>
        }

<span class="nc" id="L347">        initialize(inst, state);</span>
<span class="nc" id="L348">    }</span>

    /**
     * Initialize with the given instance and state.
     */
    protected void initialize(PersistenceCapable pc, PCState state) {
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (pc == null)</span>
<span class="nc" id="L355">            throw new UserException(_loc.get(&quot;init-null-pc&quot;, _meta));</span>
<span class="nc bnc" id="L356" title="All 4 branches missed.">        if (pc.pcGetStateManager() != null &amp;&amp; pc.pcGetStateManager() != this)</span>
<span class="nc" id="L357">            throw new UserException(_loc.get(&quot;init-sm-pc&quot;,</span>
<span class="nc" id="L358">                Exceptions.toString(pc))).setFailedObject(pc);</span>
<span class="nc" id="L359">        pc.pcReplaceStateManager(this);</span>

<span class="nc" id="L361">        FieldMetaData[] fmds = _meta.getFields();</span>
<span class="nc" id="L362">        _loaded = new BitSet(fmds.length);</span>

        // mark primary key and non-persistent fields as loaded
<span class="nc bnc" id="L365" title="All 2 branches missed.">        for(int i : _meta.getPkAndNonPersistentManagedFmdIndexes()){</span>
<span class="nc" id="L366">            _loaded.set(i);</span>
        }

<span class="nc" id="L369">        _mappedByIdFields = _meta.getMappyedByIdFields();</span>

        // record whether there are any managed inverse fields
<span class="nc bnc" id="L372" title="All 4 branches missed.">        if (_broker.getInverseManager() != null &amp;&amp; _meta.hasInverseManagedFields())</span>
<span class="nc" id="L373">            _flags |= FLAG_INVERSES;</span>

<span class="nc" id="L375">        pc.pcSetDetachedState(null);</span>
<span class="nc" id="L376">        _pc = pc;</span>

<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (_oid instanceof OpenJPAId)</span>
<span class="nc" id="L379">            ((OpenJPAId) _oid).setManagedInstanceType(_meta.getDescribedType());</span>

        // initialize our state and add ourselves to the broker's cache
<span class="nc" id="L382">        setPCState(state);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if ( _oid == null ||</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">            _broker.getStateManagerImplById(_oid, false) == null) {</span>
<span class="nc" id="L385">        	_broker.setStateManager(_id, this, BrokerImpl.STATUS_INIT);</span>
        }
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (state == PCState.PNEW)</span>
<span class="nc" id="L388">            fireLifecycleEvent(LifecycleEvent.AFTER_PERSIST);</span>

        // if this is a non-tracking PC, add a hard ref to the appropriate data
        // sets and give it an opportunity to make a state snapshot.
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (!isIntercepting()) {</span>
<span class="nc" id="L393">            saveFields(true);</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (!isNew())</span>
<span class="nc" id="L395">                RedefinitionHelper.assignLazyLoadProxies(this);</span>
        }
<span class="nc" id="L397">    }</span>

    /**
     * Whether or not data access in this instance is intercepted. This differs
     * from {@link ClassMetaData#isIntercepting()} in that it checks for
     * property access + subclassing in addition to the redefinition /
     * enhancement checks.
     *
     * @since 1.0.0
     */
    public boolean isIntercepting() {
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (getMetaData().isIntercepting())</span>
<span class="nc" id="L409">            return true;</span>
        // TODO:JRB Intercepting
<span class="nc bnc" id="L411" title="All 4 branches missed.">        if (AccessCode.isProperty(getMetaData().getAccessType())</span>
            &amp;&amp; _pc instanceof DynamicPersistenceCapable)
<span class="nc" id="L413">            return true;</span>
<span class="nc" id="L414">        return false;</span>
    }

    /**
     * Fire the given lifecycle event to all listeners.
     */
    private boolean fireLifecycleEvent(int type) {
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (type == LifecycleEvent.AFTER_PERSIST</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                &amp;&amp; _broker.getConfiguration().getCallbackOptionsInstance().getPostPersistCallbackImmediate()) {</span>
<span class="nc" id="L423">            fetchObjectId();</span>
        }
<span class="nc" id="L425">        return _broker.fireLifecycleEvent(getManagedInstance(), null, _meta, type);</span>
    }

    @Override
    public void load(FetchConfiguration fetch) {
<span class="nc" id="L430">        load(fetch, LOAD_FGS, null, null, false);</span>
<span class="nc" id="L431">    }</span>

    /**
     * Load the state of this instance based on the given fetch configuration
     * and load mode. Return true if any data was loaded, false otherwise.
     */
    protected boolean load(FetchConfiguration fetch, int loadMode,
        BitSet exclude, Object sdata, boolean forWrite) {
<span class="nc bnc" id="L439" title="All 2 branches missed.">        if (!forWrite</span>
<span class="nc bnc" id="L440" title="All 8 branches missed.">            &amp;&amp; (!isPersistent() || (isNew() &amp;&amp; !isFlushed()) || isDeleted()))</span>
<span class="nc" id="L441">            return false;</span>

        // if any fields being loaded, do state transitions for read
<span class="nc" id="L444">        BitSet fields = getUnloadedInternal(fetch, loadMode, exclude);</span>
<span class="nc" id="L445">        boolean active = _broker.isActive();</span>
<span class="nc bnc" id="L446" title="All 4 branches missed.">        if (!forWrite &amp;&amp; fields != null)</span>
<span class="nc" id="L447">            beforeRead(-1);</span>

        // call load even if no fields are being loaded, because it takes
        // care of checking if the DFG is loaded, making sure version info
        // is loaded, etc
<span class="nc" id="L452">        int lockLevel = calculateLockLevel(active, forWrite, fetch);</span>
<span class="nc" id="L453">        boolean ret = loadFields(fields, fetch, lockLevel, sdata);</span>
<span class="nc" id="L454">        obtainLocks(active, forWrite, lockLevel, fetch, sdata);</span>
<span class="nc" id="L455">        return ret;</span>
    }

    @Override
    public Object getManagedInstance() {
<span class="nc bnc" id="L460" title="All 2 branches missed.">        if (_pc instanceof ManagedInstanceProvider)</span>
<span class="nc" id="L461">            return ((ManagedInstanceProvider) _pc).getManagedInstance();</span>
        else
<span class="nc" id="L463">            return _pc;</span>
    }

    @Override
    public PersistenceCapable getPersistenceCapable() {
<span class="nc" id="L468">        return _pc;</span>
    }

    @Override
    public ClassMetaData getMetaData() {
<span class="nc" id="L473">        return _meta;</span>
    }

    @Override
    public OpenJPAStateManager getOwner() {
<span class="nc" id="L478">        return _owner;</span>
    }

    @Override
    public int getOwnerIndex() {
<span class="nc" id="L483">        return _ownerIndex;</span>
    }

    public void setOwner(Object oid) {
<span class="nc" id="L487">        _ownerId = oid;</span>
<span class="nc" id="L488">    }</span>

    @Override
    public boolean isEmbedded() {
        // _owner may not be set if embed object is from query result
<span class="nc bnc" id="L493" title="All 4 branches missed.">        return _owner != null || _state instanceof ENonTransState;</span>
    }

    @Override
    public boolean isFlushed() {
<span class="nc bnc" id="L498" title="All 2 branches missed.">        return (_flags &amp; FLAG_FLUSHED) &gt; 0;</span>
    }

    @Override
    public boolean isFlushedDirty() {
<span class="nc bnc" id="L503" title="All 2 branches missed.">        return (_flags &amp; FLAG_FLUSHED_DIRTY) &gt; 0;</span>
    }

    @Override
    public BitSet getLoaded() {
<span class="nc" id="L508">        return _loaded;</span>
    }

    @Override
    public BitSet getUnloaded(FetchConfiguration fetch) {
        // collect fields to load from data store based on fetch configuration
<span class="nc" id="L514">        BitSet fields = getUnloadedInternal(fetch, LOAD_FGS, null);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">        return (fields == null) ? new BitSet(0) : fields;</span>
    }

    /**
     * Internal version of {@link OpenJPAStateManager#getUnloaded} that avoids
     * creating an empty bit set by returning null when there are no unloaded
     * fields.
     */
    private BitSet getUnloadedInternal(FetchConfiguration fetch, int mode,
        BitSet exclude) {
<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (exclude == StoreContext.EXCLUDE_ALL)</span>
<span class="nc" id="L526">            return null;</span>

<span class="nc" id="L528">        BitSet fields = null;</span>
<span class="nc" id="L529">        FieldMetaData[] fmds = _meta.getFields();</span>
        boolean load;
<span class="nc bnc" id="L531" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L532" title="All 6 branches missed.">            if (_loaded.get(i) || (exclude != null &amp;&amp; exclude.get(i)))</span>
<span class="nc" id="L533">                continue;</span>

<span class="nc bnc" id="L535" title="All 3 branches missed.">            switch (mode) {</span>
                case LOAD_SERIALIZE:
<span class="nc bnc" id="L537" title="All 2 branches missed.">                    load = !fmds[i].isTransient();</span>
<span class="nc" id="L538">                    break;</span>
                case LOAD_FGS:
<span class="nc bnc" id="L540" title="All 4 branches missed.">                    load = fetch == null || fetch.requiresFetch(fmds[i])</span>
                        != FetchConfiguration.FETCH_NONE;
<span class="nc" id="L542">                    break;</span>
                default: // LOAD_ALL
<span class="nc" id="L544">                    load = true;</span>
            }

<span class="nc bnc" id="L547" title="All 2 branches missed.">            if (load) {</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                if (fields == null)</span>
<span class="nc" id="L549">                    fields = new BitSet(fmds.length);</span>
<span class="nc" id="L550">                fields.set(i);</span>
            }
        }
<span class="nc" id="L553">        return fields;</span>
    }

    @Override
    public StoreContext getContext() {
<span class="nc" id="L558">        return _broker;</span>
    }

    /**
     * Managing broker.
     */
    BrokerImpl getBroker() {
<span class="nc" id="L565">        return _broker;</span>
    }

    @Override
    public Object getId() {
<span class="nc" id="L570">        return _id;</span>
    }

    @Override
    public Object getObjectId() {
<span class="nc" id="L575">        StateManagerImpl sm = this;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">        while (sm.getOwner() != null)</span>
<span class="nc" id="L577">            sm = (StateManagerImpl) sm.getOwner();</span>
<span class="nc bnc" id="L578" title="All 4 branches missed.">        if (sm.isEmbedded() &amp;&amp; sm.getOwner() == null)</span>
<span class="nc" id="L579">            return sm._ownerId;</span>
<span class="nc" id="L580">        return sm._oid;</span>
    }

    @Override
    public void setObjectId(Object oid) {
<span class="nc" id="L585">        _oid = oid;</span>
<span class="nc bnc" id="L586" title="All 4 branches missed.">        if (_pc != null &amp;&amp; oid instanceof OpenJPAId)</span>
<span class="nc" id="L587">            ((OpenJPAId) oid).setManagedInstanceType(_meta.getDescribedType());</span>
<span class="nc" id="L588">    }</span>

    public StateManagerImpl getObjectIdOwner() {
<span class="nc" id="L591">        StateManagerImpl sm = this;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">        while (sm.getOwner() != null)</span>
<span class="nc" id="L593">            sm = (StateManagerImpl) sm.getOwner();</span>
<span class="nc" id="L594">        return sm;</span>
    }
    @Override
    public boolean assignObjectId(boolean flush) {
<span class="nc" id="L598">        lock();</span>
        try {
<span class="nc" id="L600">            return assignObjectId(flush, false);</span>
        } finally {
<span class="nc" id="L602">            unlock();</span>
        }
    }

    /**
     * Ask store manager to assign our oid, optionally flushing and
     * optionally recaching on the new oid.
     */
    boolean assignObjectId(boolean flush, boolean preFlushing) {
<span class="nc bnc" id="L611" title="All 6 branches missed.">        if (_oid != null || isEmbedded() || !isPersistent())</span>
<span class="nc" id="L612">            return true;</span>

<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (_broker.getStoreManager().assignObjectId(this, preFlushing)) {</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (!preFlushing)</span>
<span class="nc" id="L616">                assertObjectIdAssigned(true);</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        } else if (flush)</span>
<span class="nc" id="L618">            _broker.flush();</span>
        else
<span class="nc" id="L620">            return false;</span>
<span class="nc" id="L621">        return true;</span>
    }

    /**
     * Make sure we were assigned an oid, and perform actions to make it
     * permanent.
     *
     * @param recache whether to recache ourself on the new oid
     */
    private void assertObjectIdAssigned(boolean recache) {
<span class="nc bnc" id="L631" title="All 8 branches missed.">        if (!isNew() || isDeleted() || isProvisional()</span>
            || (_flags &amp; FLAG_OID_ASSIGNED) != 0)
<span class="nc" id="L633">            return;</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">        if (_oid == null) {</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">            if (_meta.getIdentityType() == ClassMetaData.ID_DATASTORE)</span>
<span class="nc" id="L636">                throw new InternalException(Exceptions.toString</span>
<span class="nc" id="L637">                    (getManagedInstance()));</span>
<span class="nc" id="L638">            _oid = ApplicationIds.create(_pc, _meta);</span>
        }

<span class="nc" id="L641">        Object orig = _id;</span>
<span class="nc" id="L642">        _id = _oid;</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">        if (recache) {</span>
            try {
<span class="nc" id="L645">                _broker.setStateManager(orig, this,</span>
                    BrokerImpl.STATUS_OID_ASSIGN);
<span class="nc" id="L647">            } catch (RuntimeException re) {</span>
<span class="nc" id="L648">                _id = orig;</span>
<span class="nc" id="L649">                _oid = null;</span>
<span class="nc" id="L650">                throw re;</span>
<span class="nc" id="L651">            }</span>
        }
<span class="nc" id="L653">        _flags |= FLAG_OID_ASSIGNED;</span>
<span class="nc" id="L654">    }</span>

    /**
     * Assign the proper generated value to the given field based on its
     * value-strategy.
     */
    private boolean assignField(int field, boolean preFlushing) {
<span class="nc" id="L661">        OpenJPAStateManager sm = this;</span>
<span class="nc bnc" id="L662" title="All 4 branches missed.">        while (sm != null &amp;&amp; sm.isEmbedded())</span>
<span class="nc" id="L663">            sm = sm.getOwner();</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">        if (sm == null)</span>
<span class="nc" id="L665">            return false;</span>
<span class="nc bnc" id="L666" title="All 6 branches missed.">        if (!sm.isNew() || sm.isFlushed() || sm.isDeleted())</span>
<span class="nc" id="L667">            return false;</span>

        // special-case oid fields, which require us to look inside the oid
        // object
<span class="nc" id="L671">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">        if (fmd.getDeclaredTypeCode() == JavaTypes.OID) {</span>
            // try to shortcut if possible
<span class="nc bnc" id="L674" title="All 6 branches missed.">            if (_oid != null || isEmbedded() || !isPersistent())</span>
<span class="nc" id="L675">                return true;</span>

            // check embedded fields of oid for value strategy + default value
<span class="nc" id="L678">            FieldMetaData[] pks = fmd.getEmbeddedMetaData().getFields();</span>
<span class="nc" id="L679">            OpenJPAStateManager oidsm = null;</span>
<span class="nc" id="L680">            boolean assign = false;</span>
<span class="nc bnc" id="L681" title="All 4 branches missed.">            for (int i = 0; !assign &amp;&amp; i &lt; pks.length; i++) {</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">                if (pks[i].getValueStrategy() == ValueStrategies.NONE)</span>
<span class="nc" id="L683">                    continue;</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                if (oidsm == null)</span>
<span class="nc" id="L685">                    oidsm = new ObjectIdStateManager(fetchObjectField(field),</span>
                        this, fmd);
<span class="nc" id="L687">                assign = oidsm.isDefaultValue(i);</span>
            }
<span class="nc bnc" id="L689" title="All 6 branches missed.">            return assign &amp;&amp; assignObjectId(!preFlushing, preFlushing);</span>
        }

        // Just return if there's no value generation strategy
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (fmd.getValueStrategy() == ValueStrategies.NONE)</span>
<span class="nc" id="L694">            return false;</span>

        // Throw exception if field already has a value assigned.
        // @GeneratedValue overrides POJO initial values and setter methods
<span class="nc bnc" id="L698" title="All 4 branches missed.">        if (!fmd.isValueGenerated() &amp;&amp; !isDefaultValue(field))</span>
<span class="nc" id="L699">            throw new InvalidStateException(_loc.get(</span>
<span class="nc" id="L700">                &quot;existing-value-override-excep&quot;, fmd.getFullName(false)));</span>

        // for primary key fields, assign the object id and recache so that
        // to the user, so it looks like the oid always matches the pk fields
<span class="nc bnc" id="L704" title="All 4 branches missed.">        if (fmd.isPrimaryKey() &amp;&amp; !isEmbedded())</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">            return assignObjectId(!preFlushing, preFlushing);</span>

        // for other fields just assign the field or flush if needed
<span class="nc bnc" id="L708" title="All 2 branches missed.">        if (_broker.getStoreManager().assignField(this, field, preFlushing)) {</span>
<span class="nc" id="L709">            fmd.setValueGenerated(true);</span>
<span class="nc" id="L710">            return true;</span>
        }
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (!preFlushing)</span>
<span class="nc" id="L713">            _broker.flush();</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">        return !preFlushing;</span>
    }

    @Override
    public Object getLock() {
<span class="nc" id="L719">        return _lock;</span>
    }

    @Override
    public void setLock(Object lock) {
<span class="nc" id="L724">        _lock = lock;</span>
<span class="nc" id="L725">    }</span>

    @Override
    public Object getVersion() {
<span class="nc" id="L729">        return _version;</span>
    }

    @Override
    public void setVersion(Object version) {
<span class="nc" id="L734">        _loadVersion = version;</span>
<span class="nc" id="L735">        assignVersionField(version);</span>
<span class="nc" id="L736">    }</span>

    Object getLoadVersion() {
<span class="nc" id="L739">        return _loadVersion;</span>
    }

    @Override
    public void setNextVersion(Object version) {
<span class="nc" id="L744">        assignVersionField(version);</span>
<span class="nc" id="L745">    }</span>

    public static Timestamp roundTimestamp(Timestamp val, int datePrecision) {
        // ensure that we do not insert dates at a greater precision than
        // that at which they will be returned by a SELECT
<span class="nc" id="L750">        int rounded = (int) Math.round(val.getNanos() / (double) datePrecision);</span>
<span class="nc" id="L751">        long time = val.getTime();</span>
<span class="nc" id="L752">        int nanos = rounded * datePrecision;</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (nanos &gt; 999999999) {</span>
            // rollover to next second
<span class="nc" id="L755">            time = time + 1000;</span>
<span class="nc" id="L756">            nanos = 0;</span>
        }

<span class="nc" id="L759">        val = new Timestamp(time);</span>
<span class="nc" id="L760">        val.setNanos(nanos);</span>
<span class="nc" id="L761">        return val;</span>
    }

    private void assignVersionField(Object version) {

<span class="nc bnc" id="L766" title="All 2 branches missed.">        if (version instanceof Timestamp) {</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">            if (_datePrecision == -1) {</span>
                try {
<span class="nc" id="L769">                    OpenJPAConfiguration conf = _broker.getConfiguration();</span>
<span class="nc" id="L770">                    Class confCls = Class.forName(&quot;org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl&quot;);</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">                    if (confCls.isAssignableFrom(conf.getClass())) {</span>
<span class="nc" id="L772">                        Object o = conf.getClass().getMethod(&quot;getDBDictionaryInstance&quot;).invoke(conf, (Object[]) null);</span>
<span class="nc" id="L773">                        _datePrecision = o.getClass().getField(&quot;datePrecision&quot;).getInt(o);</span>
<span class="nc" id="L774">                    } else {</span>
<span class="nc" id="L775">                        _datePrecision = 1000;</span>
                    }
<span class="nc" id="L777">                } catch (Throwable e) {</span>
<span class="nc" id="L778">                    _datePrecision = 1000;</span>
<span class="nc" id="L779">                }</span>
            }

<span class="nc" id="L782">            version = roundTimestamp((Timestamp) version, _datePrecision);</span>
        }
<span class="nc" id="L784">        _version = version;</span>
<span class="nc" id="L785">        FieldMetaData vfield = _meta.getVersionField();</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">        if (vfield != null)</span>
<span class="nc" id="L787">            store(vfield.getIndex(), JavaTypes.convert(version, vfield.getTypeCode()));</span>
<span class="nc" id="L788">    }</span>

    @Override
    public PCState getPCState() {
<span class="nc" id="L792">        return _state;</span>
    }

    @Override
    public synchronized Object getImplData() {
<span class="nc" id="L797">        return _impl;</span>
    }

    @Override
    public synchronized Object setImplData(Object data, boolean cacheable) {
<span class="nc" id="L802">        Object old = _impl;</span>
<span class="nc" id="L803">        _impl = data;</span>
<span class="nc bnc" id="L804" title="All 4 branches missed.">        if (cacheable &amp;&amp; data != null)</span>
<span class="nc" id="L805">            _flags |= FLAG_IMPL_CACHE;</span>
        else
<span class="nc" id="L807">            _flags &amp;= ~FLAG_IMPL_CACHE;</span>
<span class="nc" id="L808">        return old;</span>
    }

    @Override
    public boolean isImplDataCacheable() {
<span class="nc bnc" id="L813" title="All 2 branches missed.">        return (_flags &amp; FLAG_IMPL_CACHE) != 0;</span>
    }

    @Override
    public Object getImplData(int field) {
<span class="nc" id="L818">        return getExtraFieldData(field, true);</span>
    }

    @Override
    public Object setImplData(int field, Object data) {
<span class="nc" id="L823">        return setExtraFieldData(field, data, true);</span>
    }

    @Override
    public synchronized boolean isImplDataCacheable(int field) {
<span class="nc bnc" id="L828" title="All 4 branches missed.">        if (_fieldImpl == null || !_loaded.get(field))</span>
<span class="nc" id="L829">            return false;</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">        if (_meta.getField(field).usesImplData() != null)</span>
<span class="nc" id="L831">            return false;</span>
<span class="nc" id="L832">        int idx = _meta.getExtraFieldDataIndex(field);</span>
<span class="nc bnc" id="L833" title="All 4 branches missed.">        return idx != -1 &amp;&amp; _fieldImpl[idx] != null;</span>
    }

    @Override
    public Object getIntermediate(int field) {
<span class="nc" id="L838">        return getExtraFieldData(field, false);</span>
    }

    @Override
    public void setIntermediate(int field, Object data) {
<span class="nc" id="L843">        setExtraFieldData(field, data, false);</span>
<span class="nc" id="L844">    }</span>

    /**
     * Return the data from the proper index of the extra field data array.
     */
    protected synchronized Object getExtraFieldData(int field, boolean isLoaded) {
        // only return the field data if the field is in the right loaded
        // state; otherwise we might return intermediate for impl data or
        // vice versa
<span class="nc bnc" id="L853" title="All 4 branches missed.">        if (_fieldImpl == null || _loaded.get(field) != isLoaded)</span>
<span class="nc" id="L854">            return null;</span>
<span class="nc" id="L855">        int idx = _meta.getExtraFieldDataIndex(field);</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">        return (idx == -1) ? null : _fieldImpl[idx];</span>
    }

    /**
     * Set the data from to proper index of the extra field data array.
     */
    private synchronized Object setExtraFieldData(int field, Object data,
        boolean loaded) {
<span class="nc" id="L864">        int idx = _meta.getExtraFieldDataIndex(field);</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">        if (idx == -1)</span>
<span class="nc" id="L866">            throw new InternalException(String.valueOf(_meta.getField(field)));</span>

<span class="nc bnc" id="L868" title="All 2 branches missed.">        Object old = (_fieldImpl == null) ? null : _fieldImpl[idx];</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">        if (data != null) {</span>
            // cannot set if field in wrong loaded state
<span class="nc bnc" id="L871" title="All 2 branches missed.">            if (_loaded.get(field) != loaded)</span>
<span class="nc" id="L872">                throw new InternalException(String.valueOf(_meta.getField</span>
<span class="nc" id="L873">                    (field)));</span>

            // set data
<span class="nc bnc" id="L876" title="All 2 branches missed.">            if (_fieldImpl == null)</span>
<span class="nc" id="L877">                _fieldImpl = new Object[_meta.getExtraFieldDataLength()];</span>
<span class="nc" id="L878">            _fieldImpl[idx] = data;</span>
<span class="nc bnc" id="L879" title="All 4 branches missed.">        } else if (_fieldImpl != null &amp;&amp; _loaded.get(field) == loaded)</span>
<span class="nc" id="L880">            _fieldImpl[idx] = null;</span>
<span class="nc" id="L881">        return old;</span>
    }

    @Override
    public Object fetch(int field) {
<span class="nc" id="L886">        Object val = fetchField(field, false);</span>
<span class="nc" id="L887">        return _meta.getField(field).getExternalValue(val, _broker);</span>
    }

    @Override
    public Object fetchField(int field, boolean transitions) {
<span class="nc" id="L892">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">        if (fmd == null)</span>
<span class="nc" id="L894">            throw new UserException(_loc.get(&quot;no-field&quot;,</span>
<span class="nc" id="L895">                String.valueOf(field), getManagedInstance().getClass())).</span>
<span class="nc" id="L896">                setFailedObject(getManagedInstance());</span>

        // do normal state transitions
<span class="nc bnc" id="L899" title="All 4 branches missed.">        if (!fmd.isPrimaryKey() &amp;&amp; transitions)</span>
<span class="nc" id="L900">            accessingField(field);</span>

<span class="nc bnc" id="L902" title="All 11 branches missed.">        switch (fmd.getDeclaredTypeCode()) {</span>
            case JavaTypes.STRING:
<span class="nc" id="L904">                return fetchStringField(field);</span>
            case JavaTypes.OBJECT:
<span class="nc" id="L906">                return fetchObjectField(field);</span>
            case JavaTypes.BOOLEAN:
<span class="nc bnc" id="L908" title="All 2 branches missed.">                return (fetchBooleanField(field)) ? Boolean.TRUE</span>
<span class="nc" id="L909">                    : Boolean.FALSE;</span>
            case JavaTypes.BYTE:
<span class="nc" id="L911">                return Byte.valueOf(fetchByteField(field));</span>
            case JavaTypes.CHAR:
<span class="nc" id="L913">                return Character.valueOf(fetchCharField(field));</span>
            case JavaTypes.DOUBLE:
<span class="nc" id="L915">                return Double.valueOf(fetchDoubleField(field));</span>
            case JavaTypes.FLOAT:
<span class="nc" id="L917">                return Float.valueOf(fetchFloatField(field));</span>
            case JavaTypes.INT:
<span class="nc" id="L919">                return fetchIntField(field);</span>
            case JavaTypes.LONG:
<span class="nc" id="L921">                return fetchLongField(field);</span>
            case JavaTypes.SHORT:
<span class="nc" id="L923">                return Short.valueOf(fetchShortField(field));</span>
            default:
<span class="nc" id="L925">                return fetchObjectField(field);</span>
        }
    }

    @Override
    public void store(int field, Object val) {
<span class="nc" id="L931">        val = _meta.getField(field).getFieldValue(val, _broker);</span>
<span class="nc" id="L932">        storeField(field, val);</span>
<span class="nc" id="L933">    }</span>

    @Override
    public void storeField(int field, Object val) {
<span class="nc" id="L937">        storeField(field, val, this);</span>
<span class="nc" id="L938">    }</span>

    /**
     * &lt;p&gt;Checks whether or not &lt;code&gt;_pc&lt;/code&gt; is dirty. In the cases where
     * field tracking is not happening (see below), this method will do a
     * state comparison to find whether &lt;code&gt;_pc&lt;/code&gt; is dirty, and will
     * update this instance with this information. In the cases where field
     * tracking is happening, this method is a no-op.&lt;/p&gt;
     *
     * &lt;p&gt;Fields are tracked for all classes that are run through the OpenJPA
     * enhancer prior to or during deployment, and all classes (enhanced or
     * unenhanced) in a Java 6 environment or newer.&lt;/p&gt;
     *
     * &lt;p&gt;In a Java 5 VM or older:
     * &lt;br&gt;- instances of unenhanced classes that use
     * property access and obey the property access limitations are tracked
     * when the instances are loaded from the database by OpenJPA, and are
     * not tracked when the instances are created by application code.
     * &lt;br&gt;- instances of unenhanced classes that use field access are
     * never tracked.&lt;/p&gt;
     *
     * @since 1.0.0
     */
    public void dirtyCheck() {
<span class="nc bnc" id="L962" title="All 2 branches missed.">        if (!needsDirtyCheck())</span>
<span class="nc" id="L963">            return;</span>

<span class="nc" id="L965">        SaveFieldManager saved = getSaveFieldManager();</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">        if (saved == null)</span>
<span class="nc" id="L967">            throw new InternalException(_loc.get(&quot;no-saved-fields&quot;,</span>
<span class="nc" id="L968">                getMetaData().getDescribedType().getName()));</span>

<span class="nc" id="L970">        FieldMetaData[] fmds = getMetaData().getFields();</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
            // pk and version fields cannot be mutated; don't mark them
            // as such. ##### validate?
<span class="nc bnc" id="L974" title="All 4 branches missed.">            if (!fmds[i].isPrimaryKey() &amp;&amp; !fmds[i].isVersion()</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">                &amp;&amp; _loaded.get(i)) {</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">                if (!saved.isFieldEqual(i, fetch(i))) {</span>
<span class="nc" id="L977">                    dirty(i);</span>
                }
            }
        }
<span class="nc" id="L981">    }</span>

    private boolean needsDirtyCheck() {
<span class="nc bnc" id="L984" title="All 2 branches missed.">        if (isIntercepting())</span>
<span class="nc" id="L985">            return false;</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">        if (isDeleted())</span>
<span class="nc" id="L987">            return false;</span>
<span class="nc bnc" id="L988" title="All 4 branches missed.">        if (isNew() &amp;&amp; !isFlushed())</span>
<span class="nc" id="L989">            return false;</span>
<span class="nc" id="L990">        return true;</span>
    }

    @Override
    public Object fetchInitialField(int field) {
<span class="nc" id="L995">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L996" title="All 4 branches missed.">        if (_broker.getRestoreState() == RestoreState.RESTORE_NONE</span>
            &amp;&amp; ((_flags &amp; FLAG_INVERSES) == 0
<span class="nc bnc" id="L998" title="All 2 branches missed.">            || fmd.getInverseMetaDatas().length == 0))</span>
<span class="nc" id="L999">            throw new InvalidStateException(_loc.get(&quot;restore-unset&quot;));</span>

<span class="nc bnc" id="L1001" title="All 2 branches missed.">        switch (fmd.getDeclaredTypeCode()) {</span>
            case JavaTypes.DATE:
            case JavaTypes.CALENDAR:
            case JavaTypes.ARRAY:
            case JavaTypes.COLLECTION:
            case JavaTypes.MAP:
            case JavaTypes.OBJECT:
                // if we're not saving mutable types, throw an exception
<span class="nc bnc" id="L1009" title="All 4 branches missed.">                if (_broker.getRestoreState() != RestoreState.RESTORE_ALL</span>
                    &amp;&amp; ((_flags &amp; FLAG_INVERSES) == 0
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                    || fmd.getInverseMetaDatas().length == 0))</span>
<span class="nc" id="L1012">                    throw new InvalidStateException(_loc.get</span>
<span class="nc" id="L1013">                        (&quot;mutable-restore-unset&quot;));</span>
        }

<span class="nc" id="L1016">        lock();</span>
        try {
<span class="nc bnc" id="L1018" title="All 6 branches missed.">            if (_saved == null || !_loaded.get(field) || !isFieldDirty(field))</span>
<span class="nc" id="L1019">                return fetchField(field, false);</span>

            // if the field is dirty but we never loaded it, we can't restore it
<span class="nc bnc" id="L1022" title="All 2 branches missed.">            if (_saved.getUnloaded().get(field))</span>
<span class="nc" id="L1023">                throw new InvalidStateException(_loc.get(&quot;initial-unloaded&quot;,</span>
                    fmd));

<span class="nc" id="L1026">            provideField(_saved.getState(), _single, field);</span>
<span class="nc" id="L1027">            return fetchField(_single, fmd);</span>
        } finally {
<span class="nc" id="L1029">            unlock();</span>
        }
    }

    /**
     * Fetch the specified field from the specified field manager, wrapping it
     * in an object if it's a primitive. A field should be provided to the
     * field manager before this call is made.
     */
    private static Object fetchField(FieldManager fm, FieldMetaData fmd) {
<span class="nc" id="L1039">        int field = fmd.getIndex();</span>
<span class="nc bnc" id="L1040" title="All 10 branches missed.">        switch (fmd.getDeclaredTypeCode()) {</span>
            case JavaTypes.BOOLEAN:
<span class="nc bnc" id="L1042" title="All 2 branches missed.">                return (fm.fetchBooleanField(field)) ? Boolean.TRUE</span>
<span class="nc" id="L1043">                    : Boolean.FALSE;</span>
            case JavaTypes.BYTE:
<span class="nc" id="L1045">                return Byte.valueOf(fm.fetchByteField(field));</span>
            case JavaTypes.CHAR:
<span class="nc" id="L1047">                return Character.valueOf(fm.fetchCharField(field));</span>
            case JavaTypes.DOUBLE:
<span class="nc" id="L1049">                return Double.valueOf(fm.fetchDoubleField(field));</span>
            case JavaTypes.FLOAT:
<span class="nc" id="L1051">                return Float.valueOf(fm.fetchFloatField(field));</span>
            case JavaTypes.INT:
<span class="nc" id="L1053">                return fm.fetchIntField(field);</span>
            case JavaTypes.LONG:
<span class="nc" id="L1055">                return fm.fetchLongField(field);</span>
            case JavaTypes.SHORT:
<span class="nc" id="L1057">                return Short.valueOf(fm.fetchShortField(field));</span>
            case JavaTypes.STRING:
<span class="nc" id="L1059">                return fm.fetchStringField(field);</span>
            default:
<span class="nc" id="L1061">                return fm.fetchObjectField(field);</span>
        }
    }

    @Override
    public void setRemote(int field, Object value) {
<span class="nc" id="L1067">        lock();</span>
        try {
<span class="nc" id="L1069">            Boolean stat = dirty(field, Boolean.FALSE, false);</span>
<span class="nc" id="L1070">            storeField(field, value, _single);</span>
<span class="nc" id="L1071">            replaceField(_pc, _single, field);</span>
<span class="nc" id="L1072">            postDirty(stat);</span>
        } finally {
<span class="nc" id="L1074">            unlock();</span>
        }
<span class="nc" id="L1076">    }</span>

    ////////////////////////
    // Lifecycle operations
    ////////////////////////

    /**
     * Notification that the object is about to be accessed.
     *
     * @param field the field number being read, or -1 if not a single
     * field read
     */
    void beforeRead(int field) {
        // allow unmediated reads of primary key fields
<span class="nc bnc" id="L1090" title="All 4 branches missed.">        if (field != -1 &amp;&amp; _meta.getField(field).isPrimaryKey())</span>
<span class="nc" id="L1091">            return;</span>

<span class="nc bnc" id="L1093" title="All 4 branches missed.">        if (_broker.isActive() &amp;&amp; !_broker.isTransactionEnding()) {</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">            if (_broker.getOptimistic())</span>
<span class="nc" id="L1095">                setPCState(_state.beforeOptimisticRead(this, field));</span>
            else
<span class="nc" id="L1097">                setPCState(_state.beforeRead(this, field));</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">        } else if (_broker.getNontransactionalRead())</span>
<span class="nc" id="L1099">            setPCState(_state.beforeNontransactionalRead(this, field));</span>
        else
<span class="nc" id="L1101">            throw new InvalidStateException(_loc.get(&quot;non-trans-read&quot;)).</span>
<span class="nc" id="L1102">                setFailedObject(getManagedInstance());</span>
<span class="nc" id="L1103">    }</span>

    /**
     * Delegates to the current state.
     *
     * @see PCState#beforeFlush
     */
    void beforeFlush(int reason, OpCallbacks call) {
<span class="nc bnc" id="L1111" title="All 2 branches missed.">        _state.beforeFlush(this, reason == BrokerImpl.FLUSH_LOGICAL, call);</span>
<span class="nc" id="L1112">    }</span>

    /**
     * Delegates to the current state.
     *
     * @see PCState#flush
     */
    void afterFlush(int reason) {
        // nothing happens when we flush non-persistent states
<span class="nc bnc" id="L1121" title="All 2 branches missed.">        if (!isPersistent())</span>
<span class="nc" id="L1122">            return;</span>

<span class="nc bnc" id="L1124" title="All 4 branches missed.">        if (reason != BrokerImpl.FLUSH_ROLLBACK</span>
            &amp;&amp; reason != BrokerImpl.FLUSH_LOGICAL) {
            // analyze previous state for later
<span class="nc" id="L1127">            boolean wasNew = isNew();</span>
<span class="nc" id="L1128">            boolean wasFlushed = isFlushed();</span>
<span class="nc" id="L1129">            boolean wasDeleted = isDeleted();</span>
<span class="nc bnc" id="L1130" title="All 4 branches missed.">            boolean needPostUpdate = !(wasNew &amp;&amp; !wasFlushed)</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">                    &amp;&amp; (ImplHelper.getUpdateFields(this) != null);</span>

            // all dirty fields were flushed, we are referencing the _dirty BitSet directly here
            // because we don't want to instantiate it if we don't have to.
<span class="nc bnc" id="L1135" title="All 2 branches missed.">            if (_dirty != null) {</span>
<span class="nc" id="L1136">                getFlushed().or(_dirty);</span>
            }

            // important to set flushed bit after calling _state.flush so
            // that the state can tell whether this is the first flush
<span class="nc" id="L1141">            setPCState(_state.flush(this));</span>
<span class="nc" id="L1142">            _flags |= FLAG_FLUSHED;</span>
<span class="nc" id="L1143">            _flags &amp;= ~FLAG_FLUSHED_DIRTY;</span>

<span class="nc" id="L1145">            _flags &amp;= ~FLAG_VERSION_CHECK;</span>
<span class="nc" id="L1146">            _flags &amp;= ~FLAG_VERSION_UPDATE;</span>

            // if this was an inc flush during which we had our identity
            // assigned, tell the broker to cache us under our final oid
<span class="nc bnc" id="L1150" title="All 2 branches missed.">            if (reason == BrokerImpl.FLUSH_INC)</span>
<span class="nc" id="L1151">                assertObjectIdAssigned(true);</span>

            // if this object was stored with preFlush, do post-store callback
<span class="nc bnc" id="L1154" title="All 2 branches missed.">            if ((_flags &amp; FLAG_PRE_FLUSHED) &gt; 0)</span>
<span class="nc" id="L1155">                fireLifecycleEvent(LifecycleEvent.AFTER_STORE);</span>

            // do post-update as needed
<span class="nc bnc" id="L1158" title="All 4 branches missed.">            if (wasNew &amp;&amp; !wasFlushed)</span>
<span class="nc" id="L1159">                fireLifecycleEvent(LifecycleEvent.AFTER_PERSIST_PERFORMED);</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">            else if (wasDeleted)</span>
<span class="nc" id="L1161">                fireLifecycleEvent(LifecycleEvent.AFTER_DELETE_PERFORMED);</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">            else if (needPostUpdate)</span>
                // updates and new-flushed with changes
<span class="nc" id="L1164">                fireLifecycleEvent(LifecycleEvent.AFTER_UPDATE_PERFORMED);</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">        } else if (reason == BrokerImpl.FLUSH_ROLLBACK) {</span>
            // revert to last loaded version and original oid
<span class="nc" id="L1167">            assignVersionField(_loadVersion);</span>
<span class="nc bnc" id="L1168" title="All 4 branches missed.">            if (isNew() &amp;&amp; (_flags &amp; FLAG_OID_ASSIGNED) == 0)</span>
<span class="nc" id="L1169">                _oid = null;</span>
        }
<span class="nc" id="L1171">        _flags &amp;= ~FLAG_PRE_FLUSHED;</span>
<span class="nc" id="L1172">    }</span>

    /**
     * Delegates to the current state after checking the value
     * of the RetainState flag.
     *
     * @see PCState#commit
     * @see PCState#commitRetain
     */
    void commit() {
        // release locks before oid updated
<span class="nc" id="L1183">        releaseLocks();</span>

        // update version and oid information
<span class="nc" id="L1186">        setVersion(_version);</span>
<span class="nc" id="L1187">        _flags &amp;= ~FLAG_FLUSHED;</span>
<span class="nc" id="L1188">        _flags &amp;= ~FLAG_FLUSHED_DIRTY;</span>

<span class="nc" id="L1190">        Object orig = _id;</span>
<span class="nc" id="L1191">        assertObjectIdAssigned(false);</span>

<span class="nc bnc" id="L1193" title="All 6 branches missed.">        boolean wasNew = isNew() &amp;&amp; !isDeleted() &amp;&amp; !isProvisional();</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">        if (_broker.getRetainState())</span>
<span class="nc" id="L1195">            setPCState(_state.commitRetain(this));</span>
        else
<span class="nc" id="L1197">            setPCState(_state.commit(this));</span>

        // ask the broker to re-cache us if we were new previously
<span class="nc bnc" id="L1200" title="All 2 branches missed.">        if (wasNew)</span>
<span class="nc" id="L1201">            _broker.setStateManager(orig, this, BrokerImpl.STATUS_COMMIT_NEW);</span>
<span class="nc" id="L1202">    }</span>

    /**
     * Delegates to the current state after checking the value
     * of the RetainState flag.
     *
     * @see PCState#rollback
     * @see PCState#rollbackRestore
     */
    void rollback() {
        // release locks
<span class="nc" id="L1213">        releaseLocks();</span>
<span class="nc" id="L1214">        _flags &amp;= ~FLAG_FLUSHED;</span>
<span class="nc" id="L1215">        _flags &amp;= ~FLAG_FLUSHED_DIRTY;</span>
<span class="nc" id="L1216">        afterFlush(BrokerImpl.FLUSH_ROLLBACK);</span>

<span class="nc bnc" id="L1218" title="All 2 branches missed.">        if (_broker.getRestoreState() != RestoreState.RESTORE_NONE)</span>
<span class="nc" id="L1219">            setPCState(_state.rollbackRestore(this));</span>
        else
<span class="nc" id="L1221">            setPCState(_state.rollback(this));</span>
<span class="nc" id="L1222">    }</span>

    /**
     * Rollback state of the managed instance to the given savepoint.
     */
    void rollbackToSavepoint(SavepointFieldManager savepoint) {
<span class="nc" id="L1228">        _state = savepoint.getPCState();</span>
<span class="nc" id="L1229">        BitSet loaded = savepoint.getLoaded();</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">        for (int i = 0, len = loaded.length(); i &lt; len; i++) {</span>
<span class="nc bnc" id="L1231" title="All 4 branches missed.">            if (loaded.get(i) &amp;&amp; savepoint.restoreField(i)) {</span>
<span class="nc" id="L1232">                provideField(savepoint.getCopy(), savepoint, i);</span>
<span class="nc" id="L1233">                replaceField(_pc, savepoint, i);</span>
            }
        }
<span class="nc" id="L1236">        _loaded = loaded;</span>
<span class="nc" id="L1237">        _dirty = savepoint.getDirty();</span>
<span class="nc" id="L1238">        _flush = savepoint.getFlushed();</span>
<span class="nc" id="L1239">        _version = savepoint.getVersion();</span>
<span class="nc" id="L1240">        _loadVersion = savepoint.getLoadVersion();</span>
<span class="nc" id="L1241">    }</span>

    /**
     * Delegates to the current state.
     *
     * @see PCState#persist
     * @see Broker#persist
     */
    void persist() {
<span class="nc" id="L1250">        setPCState(_state.persist(this));</span>
<span class="nc" id="L1251">    }</span>

    /**
     * Delegates to the current state.
     *
     * @see PCState#delete
     * @see Broker#delete
     */
    void delete() {
<span class="nc" id="L1260">        setPCState(_state.delete(this));</span>
<span class="nc" id="L1261">    }</span>

    /**
     * Delegates to the current state.
     *
     * @see PCState#nontransactional
     * @see Broker#nontransactional
     */
    void nontransactional() {
<span class="nc" id="L1270">        setPCState(_state.nontransactional(this));</span>
<span class="nc" id="L1271">    }</span>

    /**
     * Delegates to the current state.
     *
     * @see PCState#transactional
     * @see Broker#transactional
     */
    void transactional() {
<span class="nc" id="L1280">        setPCState(_state.transactional(this));</span>
<span class="nc" id="L1281">    }</span>

    /**
     * Delegates to the current state.
     *
     * @see PCState#nonprovisional
     */
    void nonprovisional(boolean logical, OpCallbacks call) {
<span class="nc" id="L1289">        setPCState(_state.nonprovisional(this, logical, call));</span>
<span class="nc" id="L1290">    }</span>

    /**
     * Delegates to the current state.
     *
     * @see PCState#release
     * @see Broker#release
     */
    void release(boolean unproxy) {
<span class="nc" id="L1299">        release(unproxy, false);</span>
<span class="nc" id="L1300">    }</span>

    void release(boolean unproxy, boolean force) {
        // optimization for detach-in-place special case when fields are
        // already (un)proxied correctly
<span class="nc bnc" id="L1305" title="All 2 branches missed.">        if (!unproxy)</span>
<span class="nc" id="L1306">            _flags |= FLAG_NO_UNPROXY;</span>
        try {
<span class="nc bnc" id="L1308" title="All 2 branches missed.">            if (force)</span>
<span class="nc" id="L1309">                setPCState(PCState.TRANSIENT);</span>
            else
<span class="nc" id="L1311">                setPCState(_state.release(this));</span>
        } finally {
<span class="nc" id="L1313">            _flags &amp;= ~FLAG_NO_UNPROXY;</span>
        }
<span class="nc" id="L1315">    }</span>

    /**
     * Delegates to the current state.
     *
     * @see PCState#evict
     * @see Broker#evict
     */
    void evict() {
<span class="nc" id="L1324">        setPCState(_state.evict(this));</span>
<span class="nc" id="L1325">    }</span>

    /**
     * Gather relations reachable from values using
     * {@link ValueMetaData#CASCADE_IMMEDIATE}.
     */
    void gatherCascadeRefresh(OpCallbacks call) {
<span class="nc" id="L1332">        FieldMetaData[] fmds = _meta.getFields();</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">            if (!_loaded.get(i))</span>
<span class="nc" id="L1335">                continue;</span>

<span class="nc bnc" id="L1337" title="All 2 branches missed.">            if (fmds[i].getCascadeRefresh() == ValueMetaData.CASCADE_IMMEDIATE</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">                || fmds[i].getKey().getCascadeRefresh()</span>
                == ValueMetaData.CASCADE_IMMEDIATE
<span class="nc bnc" id="L1340" title="All 2 branches missed.">                || fmds[i].getElement().getCascadeRefresh()</span>
                == ValueMetaData.CASCADE_IMMEDIATE) {
<span class="nc" id="L1342">                _single.storeObjectField(i, fetchField(i, false));</span>
<span class="nc" id="L1343">                _single.gatherCascadeRefresh(call);</span>
<span class="nc" id="L1344">                _single.clear();</span>
            }
        }
<span class="nc" id="L1347">    }</span>

    @Override
    public boolean beforeRefresh(boolean refreshAll) {
        // note: all logic placed here rather than in the states for
        // optimization; this method public b/c used by remote package

        // nothing to do for non persistent or new unflushed instances
<span class="nc bnc" id="L1355" title="All 6 branches missed.">        if (!isPersistent() || (isNew() &amp;&amp; !isFlushed()))</span>
<span class="nc" id="L1356">            return false;</span>

<span class="nc" id="L1358">        lock();</span>
        try {
            // if dirty need to clear fields
<span class="nc bnc" id="L1361" title="All 2 branches missed.">            if (isDirty()) {</span>
<span class="nc" id="L1362">                clearFields();</span>
<span class="nc" id="L1363">                return true;</span>
            }

            // if some fields have been loaded but the instance is out of
            // date or this is part of a refreshAll() and we don't want to
            // take the extra hit to see if the instance is out of date, clear
<span class="nc bnc" id="L1369" title="All 6 branches missed.">            if (_loaded.length() &gt; 0 &amp;&amp; (refreshAll || isEmbedded()</span>
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                || !syncVersion(null))) {</span>
<span class="nc" id="L1371">                Object version = _version;</span>
<span class="nc" id="L1372">                clearFields();</span>

                // if syncVersion just replaced the version, reset it
<span class="nc bnc" id="L1375" title="All 4 branches missed.">                if (!refreshAll &amp;&amp; !isEmbedded())</span>
<span class="nc" id="L1376">                    setVersion(version);</span>
<span class="nc" id="L1377">                return true;</span>
            }
<span class="nc" id="L1379">            return false;</span>
        } finally {
<span class="nc" id="L1381">            unlock();</span>
        }
    }

    /**
     * Perform state transitions after refresh. This method is only
     * called if {@link #beforeRefresh} returns true.
     */
    void afterRefresh() {
<span class="nc" id="L1390">        lock();</span>
        try {
            // transition to clean or nontransactional depending on trans status
<span class="nc bnc" id="L1393" title="All 2 branches missed.">            if (!_broker.isActive())</span>
<span class="nc" id="L1394">                setPCState(_state.afterNontransactionalRefresh());</span>
<span class="nc bnc" id="L1395" title="All 2 branches missed.">            else if (_broker.getOptimistic())</span>
<span class="nc" id="L1396">                setPCState(_state.afterOptimisticRefresh());</span>
            else
<span class="nc" id="L1398">                setPCState(_state.afterRefresh());</span>
        } finally {
<span class="nc" id="L1400">            unlock();</span>
        }
<span class="nc" id="L1402">    }</span>

    /**
     * Mark this object as a dereferenced dependent object.
     */
    void setDereferencedDependent(boolean deref, boolean notify) {
<span class="nc bnc" id="L1408" title="All 4 branches missed.">        if (!deref &amp;&amp; (_flags &amp; FLAG_DEREF) &gt; 0) {</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">            if (notify)</span>
<span class="nc" id="L1410">                _broker.removeDereferencedDependent(this);</span>
<span class="nc" id="L1411">            _flags &amp;= ~FLAG_DEREF;</span>
<span class="nc bnc" id="L1412" title="All 4 branches missed.">        } else if (deref &amp;&amp; (_flags &amp; FLAG_DEREF) == 0) {</span>
<span class="nc" id="L1413">            _flags |= FLAG_DEREF;</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">            if (notify)</span>
<span class="nc" id="L1415">                _broker.addDereferencedDependent(this);</span>
        }
<span class="nc" id="L1417">    }</span>

    void setDereferencedEmbedDependent(boolean deref) {
<span class="nc bnc" id="L1420" title="All 4 branches missed.">        if (!deref &amp;&amp; (_flags &amp; FLAG_EMBED_DEREF) &gt; 0) {</span>
<span class="nc" id="L1421">            _flags &amp;= ~FLAG_EMBED_DEREF;</span>
<span class="nc bnc" id="L1422" title="All 4 branches missed.">        } else if (deref &amp;&amp; (_flags &amp; FLAG_EMBED_DEREF) == 0) {</span>
<span class="nc" id="L1423">            _flags |= FLAG_EMBED_DEREF;</span>
        }
<span class="nc" id="L1425">    }</span>

    public boolean getDereferencedEmbedDependent() {
<span class="nc bnc" id="L1428" title="All 2 branches missed.">        return ((_flags &amp; FLAG_EMBED_DEREF) == 0 ? false : true);</span>
    }

    ///////////
    // Locking
    ///////////

    /**
     * Notification that we've been read-locked. Pass in the level at which
     * we were locked and the level at which we should write lock ourselves
     * on dirty.
     */
    void readLocked(int readLockLevel, int writeLockLevel) {
        // make sure object is added to transaction so lock will get
        // cleared on commit/rollback
<span class="nc bnc" id="L1443" title="All 2 branches missed.">        if (readLockLevel != LockLevels.LOCK_NONE)</span>
<span class="nc" id="L1444">            transactional();</span>

<span class="nc" id="L1446">        _readLockLevel = readLockLevel;</span>
<span class="nc" id="L1447">        _writeLockLevel = writeLockLevel;</span>
<span class="nc" id="L1448">        _flags |= FLAG_READ_LOCKED;</span>
<span class="nc" id="L1449">        _flags &amp;= ~FLAG_WRITE_LOCKED;</span>
<span class="nc" id="L1450">    }</span>

    /**
     * Return the lock level to use when loading state.
     */
    private int calculateLockLevel(boolean active, boolean forWrite,
        FetchConfiguration fetch) {
<span class="nc bnc" id="L1457" title="All 2 branches missed.">        if (!active)</span>
<span class="nc" id="L1458">            return LockLevels.LOCK_NONE;</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">        if (fetch == null)</span>
<span class="nc" id="L1460">            fetch = _broker.getFetchConfiguration();</span>

<span class="nc bnc" id="L1462" title="All 4 branches missed.">        if (_readLockLevel == -1 || _readLockLevel &lt; fetch.getReadLockLevel())</span>
<span class="nc" id="L1463">            _readLockLevel = fetch.getReadLockLevel();</span>
<span class="nc bnc" id="L1464" title="All 4 branches missed.">        if (_writeLockLevel == -1 || _writeLockLevel &lt; fetch.getWriteLockLevel())</span>
<span class="nc" id="L1465">            _writeLockLevel = fetch.getWriteLockLevel();</span>
<span class="nc bnc" id="L1466" title="All 2 branches missed.">        return (forWrite) ? _writeLockLevel : _readLockLevel;</span>
    }

    /**
     * Make sure we're locked at the given level.
     */
    private void obtainLocks(boolean active, boolean forWrite, int lockLevel,
        FetchConfiguration fetch, Object sdata) {
<span class="nc bnc" id="L1474" title="All 2 branches missed.">        if (!active)</span>
<span class="nc" id="L1475">            return;</span>

        // if we haven't been locked yet, lock now at the given level
<span class="nc bnc" id="L1478" title="All 2 branches missed.">        int flag = (forWrite) ? FLAG_WRITE_LOCKED : FLAG_READ_LOCKED;</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">        if ((_flags &amp; flag) == 0) {</span>
            // make sure object is added to transaction so lock will get
            // cleared on commit/rollback
<span class="nc bnc" id="L1482" title="All 2 branches missed.">            if (lockLevel != LockLevels.LOCK_NONE)</span>
<span class="nc" id="L1483">                transactional();</span>

<span class="nc bnc" id="L1485" title="All 2 branches missed.">            if (fetch == null)</span>
<span class="nc" id="L1486">                fetch = _broker.getFetchConfiguration();</span>
<span class="nc" id="L1487">            _broker.getLockManager().lock(this, lockLevel,</span>
<span class="nc" id="L1488">                fetch.getLockTimeout(), sdata);</span>
<span class="nc" id="L1489">            _flags |= FLAG_READ_LOCKED;</span>
<span class="nc" id="L1490">            _flags |= flag;</span>
        }
<span class="nc" id="L1492">    }</span>

    /**
     * Release locks.
     */
    private void releaseLocks() {
<span class="nc bnc" id="L1498" title="All 2 branches missed.">        if (_lock != null)</span>
<span class="nc" id="L1499">            _broker.getLockManager().release(this);</span>
<span class="nc" id="L1500">        _readLockLevel = -1;</span>
<span class="nc" id="L1501">        _writeLockLevel = -1;</span>
<span class="nc" id="L1502">        _flags &amp;= ~FLAG_READ_LOCKED;</span>
<span class="nc" id="L1503">        _flags &amp;= ~FLAG_WRITE_LOCKED;</span>
<span class="nc" id="L1504">    }</span>

    ////////////////////////////////////////////
    // Implementation of StateManager interface
    ////////////////////////////////////////////

    /**
     * @return whether or not unloaded fields should be closed.
     */
    @Override
    public boolean serializing() {
        // if the broker is in the midst of a serialization, then no special
        // handling should be performed on the instance, and no subsequent
        // load should happen
<span class="nc bnc" id="L1518" title="All 2 branches missed.">        if (_broker.isSerializing())</span>
<span class="nc" id="L1519">            return false;</span>

        try {
<span class="nc bnc" id="L1522" title="All 2 branches missed.">            if (_meta.isDetachable())</span>
<span class="nc" id="L1523">                return DetachManager.preSerialize(this);</span>

<span class="nc" id="L1525">            load(_broker.getFetchConfiguration(), LOAD_SERIALIZE, null, null,</span>
                false);
<span class="nc" id="L1527">            return false;</span>
<span class="nc" id="L1528">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1529">            throw translate(re);</span>
        }
    }

    @Override
    public boolean writeDetached(ObjectOutput out)
        throws IOException {
<span class="nc" id="L1536">        BitSet idxs = new BitSet(_meta.getFields().length);</span>
<span class="nc" id="L1537">        lock();</span>
        try {
<span class="nc" id="L1539">            boolean detsm = DetachManager.writeDetachedState(this, out, idxs);</span>
<span class="nc bnc" id="L1540" title="All 2 branches missed.">            if (detsm)</span>
<span class="nc" id="L1541">                _flags |= FLAG_DETACHING;</span>

<span class="nc" id="L1543">            FieldMetaData[] fmds = _meta.getFields();</span>
<span class="nc bnc" id="L1544" title="All 2 branches missed.">            for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L1545" title="All 2 branches missed.">                if (fmds[i].isTransient())</span>
<span class="nc" id="L1546">                    continue;</span>
<span class="nc" id="L1547">                provideField(_pc, _single, i);</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">                _single.serialize(out, !idxs.get(i));</span>
<span class="nc" id="L1549">                _single.clear();</span>
            }
<span class="nc" id="L1551">            return true;</span>
<span class="nc" id="L1552">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1553">            throw translate(re);</span>
        } finally {
<span class="nc" id="L1555">            _flags &amp;= ~FLAG_DETACHING;</span>
<span class="nc" id="L1556">            unlock();</span>
        }
    }

    @Override
    public void proxyDetachedDeserialized(int idx) {
        // we don't serialize state manager impls
<span class="nc" id="L1563">        throw new InternalException();</span>
    }

    @Override
    public boolean isTransactional() {
        // special case for TCLEAN, which we want to appear non-trans to
        // internal code, but which publicly should be transactional
<span class="nc bnc" id="L1570" title="All 4 branches missed.">        return _state == PCState.TCLEAN || _state.isTransactional();</span>
    }

    public boolean isPendingTransactional() {
<span class="nc" id="L1574">        return _state.isPendingTransactional();</span>
    }

    @Override
    public boolean isProvisional() {
<span class="nc" id="L1579">        return _state.isProvisional();</span>
    }

    @Override
    public boolean isPersistent() {
<span class="nc" id="L1584">        return _state.isPersistent();</span>
    }

    @Override
    public boolean isNew() {
<span class="nc" id="L1589">        return _state.isNew();</span>
    }

    @Override
    public boolean isDeleted() {
<span class="nc" id="L1594">        return _state.isDeleted();</span>
    }

    @Override
    public boolean isDirty() {
<span class="nc" id="L1599">        return _state.isDirty();</span>
    }

    @Override
    public boolean isDetached() {
<span class="nc bnc" id="L1604" title="All 2 branches missed.">        return (_flags &amp; FLAG_DETACHING) != 0;</span>
    }

    @Override
    public Object getGenericContext() {
<span class="nc" id="L1609">        return _broker;</span>
    }

    @Override
    public Object fetchObjectId() {
        try {
<span class="nc bnc" id="L1615" title="All 6 branches missed.">            if (hasGeneratedKey() &amp;&amp; _state instanceof PNewState &amp;&amp;</span>
                _oid == null)
<span class="nc" id="L1617">                return _oid;</span>
<span class="nc" id="L1618">            assignObjectId(true);</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">            if (_oid == null || !_broker.getConfiguration().</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">                getCompatibilityInstance().getCopyObjectIds())</span>
<span class="nc" id="L1621">                return _oid;</span>

<span class="nc bnc" id="L1623" title="All 2 branches missed.">            if (_meta.getIdentityType() == ClassMetaData.ID_DATASTORE)</span>
<span class="nc" id="L1624">                return _broker.getStoreManager().copyDataStoreId(_oid, _meta);</span>
<span class="nc" id="L1625">            return ApplicationIds.copy(_oid, _meta);</span>
<span class="nc" id="L1626">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1627">            throw translate(re);</span>
        }
    }

    private boolean hasGeneratedKey() {
<span class="nc" id="L1632">        FieldMetaData[] pkFields = _meta.getPrimaryKeyFields();</span>
<span class="nc bnc" id="L1633" title="All 2 branches missed.">        for (int i = 0; i &lt; pkFields.length; i++) {</span>
<span class="nc bnc" id="L1634" title="All 2 branches missed.">            if (pkFields[i].getValueStrategy() == ValueStrategies.AUTOASSIGN)</span>
<span class="nc" id="L1635">                return true;</span>
        }
<span class="nc" id="L1637">        return false;</span>
    }

    @Override
    public Object getPCPrimaryKey(Object oid, int field) {
<span class="nc" id="L1642">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc" id="L1643">        Object pk = ApplicationIds.get(oid, fmd);</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">        if (pk == null)</span>
<span class="nc" id="L1645">            return null;</span>

<span class="nc" id="L1647">        ClassMetaData relmeta = fmd.getDeclaredTypeMetaData();</span>
<span class="nc" id="L1648">        pk = ApplicationIds.wrap(relmeta, pk);</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">        if (relmeta.getIdentityType() == ClassMetaData.ID_DATASTORE</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">            &amp;&amp; fmd.getObjectIdFieldTypeCode() == JavaTypes.LONG)</span>
<span class="nc" id="L1651">            pk = _broker.getStoreManager().newDataStoreId(pk, relmeta);</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">        else if (relmeta.getIdentityType() == ClassMetaData.ID_APPLICATION</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">            &amp;&amp; fmd.getObjectIdFieldType() != relmeta.getObjectIdType())</span>
<span class="nc" id="L1654">            pk = ApplicationIds.fromPKValues(new Object[] { pk }, relmeta);</span>
<span class="nc" id="L1655">        return _broker.find(pk, false, null);</span>
    }

    public byte replaceFlags() {
        // we always use load required so that we can detect when objects
        // are touched for locking or making transactional
<span class="nc" id="L1661">        return PersistenceCapable.LOAD_REQUIRED;</span>
    }

    @Override
    public StateManager replaceStateManager(StateManager sm) {
<span class="nc" id="L1666">        return sm;</span>
    }

    @Override
    public void accessingField(int field) {
        // possibly change state
        try {
            // If this field is loaded, and not a PK field allow pass through
            // TODO -- what about version fields? Could probably UT this
<span class="nc bnc" id="L1675" title="All 4 branches missed.">            if(_loaded.get(field) &amp;&amp; !_meta.getField(field).isPrimaryKey())</span>
<span class="nc" id="L1676">                return;</span>

<span class="nc" id="L1678">            beforeRead(field);</span>
<span class="nc" id="L1679">            beforeAccessField(field);</span>
<span class="nc" id="L1680">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1681">            throw translate(re);</span>
<span class="nc" id="L1682">        }</span>
<span class="nc" id="L1683">    }</span>

    @Override
    public boolean isDelayed(int field) {
<span class="nc bnc" id="L1687" title="All 2 branches missed.">        if (_delayed == null) {</span>
<span class="nc" id="L1688">            return false;</span>
        }
<span class="nc" id="L1690">        return _delayed.get(field);</span>
    }

    @Override
    public void setDelayed(int field, boolean delay) {
<span class="nc bnc" id="L1695" title="All 2 branches missed.">        if (_delayed == null) {</span>
<span class="nc" id="L1696">            _delayed = new BitSet();</span>
        }
<span class="nc bnc" id="L1698" title="All 2 branches missed.">        if (delay) {</span>
<span class="nc" id="L1699">            _delayed.set(field);</span>
        } else {
<span class="nc" id="L1701">            _delayed.clear(field);</span>
        }
<span class="nc" id="L1703">    }</span>

    /**
     * Loads a delayed access field.
     */
    @Override
    public void loadDelayedField(int field) {
<span class="nc bnc" id="L1710" title="All 2 branches missed.">        if (!isDelayed(field)) {</span>
<span class="nc" id="L1711">            return;</span>
        }

        try {
<span class="nc" id="L1715">            beforeRead(field);</span>
<span class="nc" id="L1716">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1717">            throw translate(re);</span>
<span class="nc" id="L1718">        }</span>
<span class="nc" id="L1719">        lock();</span>
        try {
<span class="nc" id="L1721">            boolean active = _broker.isActive();</span>
<span class="nc" id="L1722">            int lockLevel = calculateLockLevel(active, false, null);</span>
<span class="nc" id="L1723">            BitSet fields = new BitSet();</span>
<span class="nc" id="L1724">            fields.set(field);</span>
<span class="nc bnc" id="L1725" title="All 2 branches missed.">            if (!_broker.getStoreManager().load(this, fields, _broker.getFetchConfiguration(), lockLevel, null)) {</span>
<span class="nc" id="L1726">                throw new ObjectNotFoundException(_loc.get(&quot;del-instance&quot;, _meta.getDescribedType(), _oid)).</span>
<span class="nc" id="L1727">                    setFailedObject(getManagedInstance());</span>
            }
            // Cleared the delayed bit
<span class="nc" id="L1730">            _delayed.clear(field);</span>
<span class="nc" id="L1731">            obtainLocks(active, false, lockLevel, null, null);</span>
<span class="nc" id="L1732">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1733">            throw translate(re);</span>
        } finally {
<span class="nc" id="L1735">            unlock();</span>
        }
<span class="nc" id="L1737">    }</span>

    /**
     * Load the given field before access.
     */
    protected void beforeAccessField(int field) {
<span class="nc" id="L1743">        lock();</span>
        try {
<span class="nc" id="L1745">            boolean active = _broker.isActive();</span>
<span class="nc" id="L1746">            int lockLevel = calculateLockLevel(active, false, null);</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">            if (!_loaded.get(field))</span>
<span class="nc" id="L1748">                loadField(field, lockLevel, false, true);</span>
            else
<span class="nc" id="L1750">                assignField(field, false);</span>
<span class="nc" id="L1751">            obtainLocks(active, false, lockLevel, null, null);</span>
<span class="nc" id="L1752">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1753">            throw translate(re);</span>
        } finally {
<span class="nc" id="L1755">            unlock();</span>
        }
<span class="nc" id="L1757">    }</span>

    @Override
    public void dirty(String field) {
<span class="nc" id="L1761">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">        if (fmd == null)</span>
<span class="nc" id="L1763">            throw translate(new UserException(_loc.get(&quot;no-field&quot;, field,</span>
<span class="nc" id="L1764">                ImplHelper.getManagedInstance(_pc).getClass()))</span>
<span class="nc" id="L1765">                .setFailedObject(getManagedInstance()));</span>

<span class="nc" id="L1767">        dirty(fmd.getIndex(), null, true);</span>
<span class="nc" id="L1768">    }</span>

    @Override
    public void dirty(int field) {
<span class="nc" id="L1772">        dirty(field, null, true);</span>
<span class="nc" id="L1773">    }</span>

    private boolean isEmbeddedNotUpdatable() {
        // embeddable object returned from query result is not uptable
<span class="nc bnc" id="L1777" title="All 4 branches missed.">        return (_owner == null &amp;&amp; _ownerId != null);</span>
    }

    /**
     * Make the given field dirty.
     *
     * @param mutate if null, may be an SCO mutation; if true, is certainly
     * a mutation (or at least treat as one)
     * @return {@link Boolean#FALSE} if this instance was already dirty,
     * &lt;code&gt;null&lt;/code&gt; if it was dirty but not since flush, and
     * {@link Boolean#TRUE} if it was not dirty
     */
    private Boolean dirty(int field, Boolean mutate, boolean loadFetchGroup) {
<span class="nc" id="L1790">        boolean locked = false;</span>
<span class="nc" id="L1791">        boolean newFlush = false;</span>
<span class="nc" id="L1792">        boolean clean = false;</span>
        try {
<span class="nc" id="L1794">            FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L1795" title="All 4 branches missed.">            if (!isNew() || isFlushed()) {</span>
<span class="nc bnc" id="L1796" title="All 2 branches missed.">                if (fmd.getUpdateStrategy() == UpdateStrategies.RESTRICT)</span>
<span class="nc" id="L1797">                    throw new InvalidStateException(_loc.get</span>
<span class="nc" id="L1798">                        (&quot;update-restrict&quot;, fmd));</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">                if (fmd.getUpdateStrategy() == UpdateStrategies.IGNORE)</span>
<span class="nc" id="L1800">                    return Boolean.FALSE;</span>
            }

<span class="nc bnc" id="L1803" title="All 2 branches missed.">            if (isEmbedded()) {</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">                if (isEmbeddedNotUpdatable())</span>
<span class="nc" id="L1805">                    throw new UserException(_loc.get</span>
<span class="nc" id="L1806">                        (&quot;cant-update-embed-in-query-result&quot;)).setFailedObject</span>
<span class="nc" id="L1807">                        (getManagedInstance());</span>
                else
                    // notify owner of change
<span class="nc" id="L1810">                    _owner.dirty(_ownerIndex, Boolean.TRUE, loadFetchGroup);</span>
            }

            // is this a direct mutation of an sco field?
<span class="nc bnc" id="L1814" title="All 2 branches missed.">            if (mutate == null) {</span>
<span class="nc bnc" id="L1815" title="All 3 branches missed.">                switch (fmd.getDeclaredTypeCode()) {</span>
                    case JavaTypes.COLLECTION:
                    case JavaTypes.MAP:
                    case JavaTypes.ARRAY:
                    case JavaTypes.DATE:
                    case JavaTypes.CALENDAR:
                    case JavaTypes.OBJECT:
<span class="nc" id="L1822">                        mutate = Boolean.TRUE;</span>
<span class="nc" id="L1823">                        break;</span>
                    case JavaTypes.PC:
                        mutate =
<span class="nc bnc" id="L1826" title="All 2 branches missed.">                            (fmd.isEmbedded()) ? Boolean.TRUE : Boolean.FALSE;</span>
<span class="nc" id="L1827">                        break;</span>
                    default:
<span class="nc" id="L1829">                        mutate = Boolean.FALSE; // not sco</span>
                }
            }

            // possibly change state
<span class="nc" id="L1834">            boolean active = _broker.isActive();</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">            clean = !_state.isDirty(); // intentional direct access</span>

            // fire event fast before state change.
<span class="nc bnc" id="L1838" title="All 2 branches missed.">            if (clean)</span>
<span class="nc" id="L1839">                fireLifecycleEvent(LifecycleEvent.BEFORE_DIRTY);</span>
<span class="nc bnc" id="L1840" title="All 2 branches missed.">            if (active) {</span>
<span class="nc bnc" id="L1841" title="All 2 branches missed.">                if (_broker.getOptimistic())</span>
<span class="nc" id="L1842">                    setPCState(_state.beforeOptimisticWrite(this, field,</span>
<span class="nc" id="L1843">                        mutate.booleanValue()));</span>
                else
<span class="nc" id="L1845">                    setPCState(_state.beforeWrite(this, field,</span>
<span class="nc" id="L1846">                        mutate.booleanValue()));</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">            } else if (fmd.getManagement() == FieldMetaData.MANAGE_PERSISTENT) {</span>
<span class="nc bnc" id="L1848" title="All 4 branches missed.">                if (isPersistent() &amp;&amp; !_broker.getNontransactionalWrite())</span>
<span class="nc" id="L1849">                    throw new InvalidStateException(_loc.get</span>
<span class="nc" id="L1850">                        (&quot;non-trans-write&quot;)).setFailedObject</span>
<span class="nc" id="L1851">                        (getManagedInstance());</span>

<span class="nc" id="L1853">                setPCState(_state.beforeNontransactionalWrite(this, field,</span>
<span class="nc" id="L1854">                    mutate.booleanValue()));</span>
            }

<span class="nc bnc" id="L1857" title="All 2 branches missed.">            if ((_flags &amp; FLAG_FLUSHED) != 0) {</span>
<span class="nc bnc" id="L1858" title="All 2 branches missed.">                newFlush = (_flags &amp; FLAG_FLUSHED_DIRTY) == 0;</span>
<span class="nc" id="L1859">                _flags |= FLAG_FLUSHED_DIRTY;</span>
            }

<span class="nc" id="L1862">            lock();</span>
<span class="nc" id="L1863">            locked = true;</span>

            // note that the field is in need of flushing again, and tell the
            // broker too
<span class="nc" id="L1867">            clearFlushField(field);</span>
<span class="nc bnc" id="L1868" title="All 4 branches missed.">            _broker.setDirty(this, newFlush &amp;&amp; !clean);</span>

            // save the field for rollback if needed
<span class="nc" id="L1871">            saveField(field);</span>

            // dirty the field and mark loaded; load fetch group if needed
<span class="nc" id="L1874">            int lockLevel = calculateLockLevel(active, true, null);</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">            if (!isFieldDirty(field)) {</span>
<span class="nc" id="L1876">                setLoaded(field, true);</span>
<span class="nc" id="L1877">                setFieldDirty(field);</span>

                // make sure the field's fetch group is loaded
<span class="nc bnc" id="L1880" title="All 4 branches missed.">                if (loadFetchGroup &amp;&amp; isPersistent()</span>
<span class="nc bnc" id="L1881" title="All 2 branches missed.">                    &amp;&amp; fmd.getManagement() == FieldMetaData.MANAGE_PERSISTENT)</span>
<span class="nc" id="L1882">                    loadField(field, lockLevel, true, true);</span>
            }
<span class="nc" id="L1884">            obtainLocks(active, true, lockLevel, null, null);</span>
<span class="nc" id="L1885">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1886">            throw translate(re);</span>
        } finally {
<span class="nc bnc" id="L1888" title="All 2 branches missed.">            if (locked)</span>
<span class="nc" id="L1889">                unlock();</span>
        }

<span class="nc bnc" id="L1892" title="All 2 branches missed.">        if (clean)</span>
<span class="nc" id="L1893">            return Boolean.TRUE;</span>
<span class="nc bnc" id="L1894" title="All 2 branches missed.">        if (newFlush) {</span>
            // this event can be fired later cause we're already dirty.
<span class="nc" id="L1896">            fireLifecycleEvent(LifecycleEvent.BEFORE_DIRTY_FLUSHED);</span>
<span class="nc" id="L1897">            return null;</span>
        }
<span class="nc" id="L1899">        return Boolean.FALSE;</span>
    }

    /**
     * Fire post-dirty events after field value changes.
     *
     * @param status return value from {@link #dirty(int, Boolean, boolean)}
     */
    private void postDirty(Boolean status) {
<span class="nc bnc" id="L1908" title="All 2 branches missed.">        if (Boolean.TRUE.equals(status))</span>
<span class="nc" id="L1909">            fireLifecycleEvent(LifecycleEvent.AFTER_DIRTY);</span>
<span class="nc bnc" id="L1910" title="All 2 branches missed.">        else if (status == null)</span>
<span class="nc" id="L1911">            fireLifecycleEvent(LifecycleEvent.AFTER_DIRTY_FLUSHED);</span>
<span class="nc" id="L1912">    }</span>

    @Override
    public void removed(int field, Object removed, boolean key) {
<span class="nc bnc" id="L1916" title="All 2 branches missed.">        if (removed == null)</span>
<span class="nc" id="L1917">            return;</span>

        try {
            // dereference dependent fields, delete embedded
<span class="nc" id="L1921">            FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L1922" title="All 2 branches missed.">            ValueMetaData vmd = (key) ? fmd.getKey() : fmd.getElement();</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">            if (vmd.isEmbeddedPC())</span>
<span class="nc" id="L1924">                _single.delete(vmd, removed, null);</span>
<span class="nc bnc" id="L1925" title="All 2 branches missed.">            else if (vmd.getCascadeDelete() == ValueMetaData.CASCADE_AUTO)</span>
<span class="nc" id="L1926">                _single.dereferenceDependent(removed);</span>
<span class="nc" id="L1927">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1928">            throw translate(re);</span>
<span class="nc" id="L1929">        }</span>
<span class="nc" id="L1930">    }</span>

    @Override
    public Object newProxy(int field) {
<span class="nc" id="L1934">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L1935" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L1936">            return newFieldProxy(field);</span>

<span class="nc bnc" id="L1938" title="All 5 branches missed.">        switch (fmd.getTypeCode()) {</span>
            case JavaTypes.DATE:
<span class="nc bnc" id="L1940" title="All 2 branches missed.">                if (fmd.getDeclaredType() == java.sql.Date.class)</span>
<span class="nc" id="L1941">                    return new java.sql.Date(System.currentTimeMillis());</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">                if (fmd.getDeclaredType() == java.sql.Timestamp.class)</span>
<span class="nc" id="L1943">                    return new java.sql.Timestamp(System.currentTimeMillis());</span>
<span class="nc bnc" id="L1944" title="All 2 branches missed.">                if (fmd.getDeclaredType() == java.sql.Time.class)</span>
<span class="nc" id="L1945">                    return new java.sql.Time(System.currentTimeMillis());</span>
<span class="nc" id="L1946">                return new Date();</span>
            case JavaTypes.CALENDAR:
<span class="nc" id="L1948">                return Calendar.getInstance();</span>
            case JavaTypes.COLLECTION:
<span class="nc" id="L1950">                return new ArrayList();</span>
            case JavaTypes.MAP:
<span class="nc" id="L1952">                return new HashMap();</span>
        }
<span class="nc" id="L1954">        return null;</span>
    }

    @Override
    public Object newFieldProxy(int field) {
<span class="nc" id="L1959">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc" id="L1960">        ProxyManager mgr = _broker.getConfiguration().</span>
<span class="nc" id="L1961">            getProxyManagerInstance();</span>
<span class="nc" id="L1962">        Object init = fmd.getInitializer();</span>

<span class="nc bnc" id="L1964" title="All 5 branches missed.">        switch (fmd.getDeclaredTypeCode()) {</span>
            case JavaTypes.DATE:
<span class="nc" id="L1966">                return mgr.newDateProxy(fmd.getDeclaredType());</span>
            case JavaTypes.CALENDAR:
<span class="nc" id="L1968">                return mgr.newCalendarProxy(fmd.getDeclaredType(),</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">                    init instanceof TimeZone ? (TimeZone) init : null);</span>
            case JavaTypes.COLLECTION:
<span class="nc" id="L1971">                return mgr.newCollectionProxy(fmd.getProxyType(),</span>
<span class="nc" id="L1972">                    fmd.getElement().getDeclaredType(),</span>
<span class="nc bnc" id="L1973" title="All 2 branches missed.">                    init instanceof Comparator ? (Comparator) init : null,</span>
<span class="nc" id="L1974">                        _broker.getConfiguration().getCompatibilityInstance().getAutoOff());</span>
            case JavaTypes.MAP:
<span class="nc" id="L1976">                return mgr.newMapProxy(fmd.getProxyType(),</span>
<span class="nc" id="L1977">                    fmd.getKey().getDeclaredType(),</span>
<span class="nc" id="L1978">                    fmd.getElement().getDeclaredType(),</span>
<span class="nc bnc" id="L1979" title="All 2 branches missed.">                    init instanceof Comparator ? (Comparator) init : null,</span>
<span class="nc" id="L1980">                        _broker.getConfiguration().getCompatibilityInstance().getAutoOff());</span>
        }
<span class="nc" id="L1982">        return null;</span>
    }

    @Override
    public boolean isDefaultValue(int field) {
<span class="nc" id="L1987">        lock();</span>
        try {
<span class="nc" id="L1989">            _single.clear();</span>
<span class="nc" id="L1990">            provideField(_pc, _single, field);</span>
<span class="nc" id="L1991">            boolean ret = _single.isDefaultValue();</span>
<span class="nc" id="L1992">            _single.clear();</span>
<span class="nc" id="L1993">            return ret;</span>
        } finally {
<span class="nc" id="L1995">            unlock();</span>
        }
    }

    /////////////////////////////////////////////////////////
    // Record that the field is dirty (which might load DFG)
    /////////////////////////////////////////////////////////

    @Override
    public void settingBooleanField(PersistenceCapable pc, int field,
        boolean curVal, boolean newVal, int set) {
<span class="nc bnc" id="L2006" title="All 2 branches missed.">        if (set != SET_REMOTE) {</span>
<span class="nc bnc" id="L2007" title="All 4 branches missed.">            if (newVal == curVal &amp;&amp; _loaded.get(field))</span>
<span class="nc" id="L2008">                return;</span>
<span class="nc" id="L2009">            assertNoPrimaryKeyChange(field);</span>
        }

<span class="nc" id="L2012">        lock();</span>
        try {
<span class="nc bnc" id="L2014" title="All 2 branches missed.">            Boolean stat = dirty(field, Boolean.FALSE, set == SET_USER);</span>
<span class="nc" id="L2015">            _single.storeBooleanField(field, newVal);</span>
<span class="nc" id="L2016">            replaceField(pc, _single, field);</span>
<span class="nc" id="L2017">            postDirty(stat);</span>
        } finally {
<span class="nc" id="L2019">            unlock();</span>
        }
<span class="nc" id="L2021">    }</span>

    @Override
    public void settingByteField(PersistenceCapable pc, int field,
        byte curVal, byte newVal, int set) {
<span class="nc bnc" id="L2026" title="All 2 branches missed.">        if (set != SET_REMOTE) {</span>
<span class="nc bnc" id="L2027" title="All 4 branches missed.">            if (newVal == curVal &amp;&amp; _loaded.get(field))</span>
<span class="nc" id="L2028">                return;</span>
<span class="nc" id="L2029">            assertNoPrimaryKeyChange(field);</span>
        }

<span class="nc" id="L2032">        lock();</span>
        try {
<span class="nc bnc" id="L2034" title="All 2 branches missed.">            Boolean stat = dirty(field, Boolean.FALSE, set == SET_USER);</span>
<span class="nc" id="L2035">            _single.storeByteField(field, newVal);</span>
<span class="nc" id="L2036">            replaceField(pc, _single, field);</span>
<span class="nc" id="L2037">            postDirty(stat);</span>
        } finally {
<span class="nc" id="L2039">            unlock();</span>
        }
<span class="nc" id="L2041">    }</span>

    @Override
    public void settingCharField(PersistenceCapable pc, int field,
        char curVal, char newVal, int set) {
<span class="nc bnc" id="L2046" title="All 2 branches missed.">        if (set != SET_REMOTE) {</span>
<span class="nc bnc" id="L2047" title="All 4 branches missed.">            if (newVal == curVal &amp;&amp; _loaded.get(field))</span>
<span class="nc" id="L2048">                return;</span>
<span class="nc" id="L2049">            assertNoPrimaryKeyChange(field);</span>
        }

<span class="nc" id="L2052">        lock();</span>
        try {
<span class="nc bnc" id="L2054" title="All 2 branches missed.">            Boolean stat = dirty(field, Boolean.FALSE, set == SET_USER);</span>
<span class="nc" id="L2055">            _single.storeCharField(field, newVal);</span>
<span class="nc" id="L2056">            replaceField(pc, _single, field);</span>
<span class="nc" id="L2057">            postDirty(stat);</span>
        } finally {
<span class="nc" id="L2059">            unlock();</span>
        }
<span class="nc" id="L2061">    }</span>

    @Override
    public void settingDoubleField(PersistenceCapable pc, int field,
        double curVal, double newVal, int set) {
<span class="nc bnc" id="L2066" title="All 2 branches missed.">        if (set != SET_REMOTE) {</span>
<span class="nc bnc" id="L2067" title="All 4 branches missed.">            if (newVal == curVal &amp;&amp; _loaded.get(field))</span>
<span class="nc" id="L2068">                return;</span>
<span class="nc" id="L2069">            assertNoPrimaryKeyChange(field);</span>
        }

<span class="nc" id="L2072">        lock();</span>
        try {
<span class="nc bnc" id="L2074" title="All 2 branches missed.">            Boolean stat = dirty(field, Boolean.FALSE, set == SET_USER);</span>
<span class="nc" id="L2075">            _single.storeDoubleField(field, newVal);</span>
<span class="nc" id="L2076">            replaceField(pc, _single, field);</span>
<span class="nc" id="L2077">            postDirty(stat);</span>
        } finally {
<span class="nc" id="L2079">            unlock();</span>
        }
<span class="nc" id="L2081">    }</span>

    @Override
    public void settingFloatField(PersistenceCapable pc, int field,
        float curVal, float newVal, int set) {
<span class="nc bnc" id="L2086" title="All 2 branches missed.">        if (set != SET_REMOTE) {</span>
<span class="nc bnc" id="L2087" title="All 4 branches missed.">            if (newVal == curVal &amp;&amp; _loaded.get(field))</span>
<span class="nc" id="L2088">                return;</span>
<span class="nc" id="L2089">            assertNoPrimaryKeyChange(field);</span>
        }

<span class="nc" id="L2092">        lock();</span>
        try {
<span class="nc bnc" id="L2094" title="All 2 branches missed.">            Boolean stat = dirty(field, Boolean.FALSE, set == SET_USER);</span>
<span class="nc" id="L2095">            _single.storeFloatField(field, newVal);</span>
<span class="nc" id="L2096">            replaceField(pc, _single, field);</span>
<span class="nc" id="L2097">            postDirty(stat);</span>
        } finally {
<span class="nc" id="L2099">            unlock();</span>
        }
<span class="nc" id="L2101">    }</span>

    @Override
    public void settingIntField(PersistenceCapable pc, int field,
        int curVal, int newVal, int set) {
<span class="nc bnc" id="L2106" title="All 2 branches missed.">        if (set != SET_REMOTE) {</span>
<span class="nc bnc" id="L2107" title="All 4 branches missed.">            if (newVal == curVal &amp;&amp; _loaded.get(field))</span>
<span class="nc" id="L2108">                return;</span>
<span class="nc" id="L2109">            assertNoPrimaryKeyChange(field);</span>
        }

<span class="nc" id="L2112">        lock();</span>
        try {
<span class="nc bnc" id="L2114" title="All 2 branches missed.">            Boolean stat = dirty(field, Boolean.FALSE, set == SET_USER);</span>
<span class="nc" id="L2115">            _single.storeIntField(field, newVal);</span>
<span class="nc" id="L2116">            replaceField(pc, _single, field);</span>
<span class="nc" id="L2117">            postDirty(stat);</span>
        } finally {
<span class="nc" id="L2119">            unlock();</span>
        }
<span class="nc" id="L2121">    }</span>

    @Override
    public void settingLongField(PersistenceCapable pc, int field,
        long curVal, long newVal, int set) {
<span class="nc bnc" id="L2126" title="All 2 branches missed.">        if (set != SET_REMOTE) {</span>
<span class="nc bnc" id="L2127" title="All 4 branches missed.">            if (newVal == curVal &amp;&amp; _loaded.get(field))</span>
<span class="nc" id="L2128">                return;</span>
<span class="nc" id="L2129">            assertNoPrimaryKeyChange(field);</span>
        }

<span class="nc" id="L2132">        lock();</span>
        try {
<span class="nc bnc" id="L2134" title="All 2 branches missed.">            Boolean stat = dirty(field, Boolean.FALSE, set == SET_USER);</span>
<span class="nc" id="L2135">            _single.storeLongField(field, newVal);</span>
<span class="nc" id="L2136">            replaceField(pc, _single, field);</span>
<span class="nc" id="L2137">            postDirty(stat);</span>
        } finally {
<span class="nc" id="L2139">            unlock();</span>
        }
<span class="nc" id="L2141">    }</span>

    @Override
    public void settingObjectField(PersistenceCapable pc, int field,
        Object curVal, Object newVal, int set) {
<span class="nc bnc" id="L2146" title="All 2 branches missed.">        if (set != SET_REMOTE) {</span>
<span class="nc" id="L2147">            FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2148" title="All 2 branches missed.">            if (_loaded.get(field)) {</span>
<span class="nc bnc" id="L2149" title="All 2 branches missed.">                if (newVal == curVal)</span>
<span class="nc" id="L2150">                    return;</span>

                // only compare new to old values if the comparison is going to
                // be cheap -- don't compare collections, maps, UDTs
<span class="nc bnc" id="L2154" title="All 3 branches missed.">                switch (fmd.getDeclaredTypeCode()) {</span>
                    case JavaTypes.ARRAY:
                    case JavaTypes.COLLECTION:
                    case JavaTypes.MAP:
                    case JavaTypes.PC_UNTYPED:
<span class="nc" id="L2159">                        break;</span>
                    case JavaTypes.PC:
<span class="nc bnc" id="L2161" title="All 2 branches missed.">                        if (_meta.getField(field).isPrimaryKey()) {</span>
                            // this field is a derived identity
                            //if (newVal != null &amp;&amp; newVal.equals(curVal))
                            //    return;
                            //else {
<span class="nc bnc" id="L2166" title="All 8 branches missed.">                                if (curVal != null &amp;&amp; newVal != null &amp;&amp;</span>
                                    curVal instanceof PersistenceCapable &amp;&amp; newVal instanceof PersistenceCapable) {
<span class="nc" id="L2168">                                    PersistenceCapable curPc = (PersistenceCapable) curVal;</span>
<span class="nc" id="L2169">                                    PersistenceCapable newPc = (PersistenceCapable) newVal;</span>
<span class="nc bnc" id="L2170" title="All 2 branches missed.">                                    if (curPc.pcFetchObjectId().equals(newPc.pcFetchObjectId()))</span>
<span class="nc" id="L2171">                                        return;</span>

                                }
                            //}
                        } else
                            break;
                    default:
<span class="nc bnc" id="L2178" title="All 4 branches missed.">                        if (newVal != null &amp;&amp; newVal.equals(curVal))</span>
<span class="nc" id="L2179">                            return;</span>
                }
            } else {
                // if this is a dependent unloaded field, make sure to load
                // it now
<span class="nc bnc" id="L2184" title="All 2 branches missed.">                if (fmd.getCascadeDelete() == ValueMetaData.CASCADE_AUTO</span>
<span class="nc bnc" id="L2185" title="All 2 branches missed.">                    || fmd.getKey().getCascadeDelete()</span>
                    == ValueMetaData.CASCADE_AUTO
<span class="nc bnc" id="L2187" title="All 2 branches missed.">                    || fmd.getElement().getCascadeDelete()</span>
                    == ValueMetaData.CASCADE_AUTO)
<span class="nc" id="L2189">                    curVal = fetchObjectField(field);</span>
            }

<span class="nc" id="L2192">            assertNoPrimaryKeyChange(field);</span>
<span class="nc bnc" id="L2193" title="All 2 branches missed.">            if (fmd.getDeclaredTypeCode() == JavaTypes.OID)</span>
<span class="nc" id="L2194">                assertNotManagedObjectId(newVal);</span>
        }

<span class="nc" id="L2197">        lock();</span>
        try {
<span class="nc bnc" id="L2199" title="All 2 branches missed.">            Boolean stat = dirty(field, Boolean.FALSE, set == SET_USER);</span>
<span class="nc bnc" id="L2200" title="All 2 branches missed.">            if (set != SET_REMOTE) {</span>
<span class="nc" id="L2201">                _single.storeObjectField(field, curVal);</span>
<span class="nc" id="L2202">                _single.unproxy();</span>
<span class="nc" id="L2203">                _single.dereferenceDependent();</span>
<span class="nc" id="L2204">                _single.clear();</span>
            }
<span class="nc" id="L2206">            _single.storeObjectField(field, newVal);</span>
<span class="nc" id="L2207">            replaceField(pc, _single, field);</span>
<span class="nc" id="L2208">            postDirty(stat);</span>
        } finally {
<span class="nc" id="L2210">            unlock();</span>
        }
<span class="nc" id="L2212">    }</span>

    @Override
    public void settingShortField(PersistenceCapable pc, int field,
        short curVal, short newVal, int set) {
<span class="nc bnc" id="L2217" title="All 2 branches missed.">        if (set != SET_REMOTE) {</span>
<span class="nc bnc" id="L2218" title="All 4 branches missed.">            if (newVal == curVal &amp;&amp; _loaded.get(field))</span>
<span class="nc" id="L2219">                return;</span>
<span class="nc" id="L2220">            assertNoPrimaryKeyChange(field);</span>
        }

<span class="nc" id="L2223">        lock();</span>
        try {
<span class="nc bnc" id="L2225" title="All 2 branches missed.">            Boolean stat = dirty(field, Boolean.FALSE, set == SET_USER);</span>
<span class="nc" id="L2226">            _single.storeShortField(field, newVal);</span>
<span class="nc" id="L2227">            replaceField(pc, _single, field);</span>
<span class="nc" id="L2228">            postDirty(stat);</span>
        } finally {
<span class="nc" id="L2230">            unlock();</span>
        }
<span class="nc" id="L2232">    }</span>

    @Override
    public void settingStringField(PersistenceCapable pc, int field,
        String curVal, String newVal, int set) {
<span class="nc bnc" id="L2237" title="All 2 branches missed.">        if (set != SET_REMOTE) {</span>
<span class="nc bnc" id="L2238" title="All 4 branches missed.">            if (Objects.equals(newVal, curVal) &amp;&amp; _loaded.get(field))</span>
<span class="nc" id="L2239">                return;</span>
<span class="nc" id="L2240">            assertNoPrimaryKeyChange(field);</span>
        }

<span class="nc" id="L2243">        lock();</span>
        try {
<span class="nc bnc" id="L2245" title="All 2 branches missed.">            Boolean stat = dirty(field, Boolean.FALSE, set == SET_USER);</span>
<span class="nc" id="L2246">            _single.storeStringField(field, newVal);</span>
<span class="nc" id="L2247">            replaceField(pc, _single, field);</span>
<span class="nc" id="L2248">            postDirty(stat);</span>
        } finally {
<span class="nc" id="L2250">            unlock();</span>
        }
<span class="nc" id="L2252">    }</span>

    /**
     * Disallows changing primary key fields for instances.
     */
    private void assertNoPrimaryKeyChange(int field) {
<span class="nc bnc" id="L2258" title="All 4 branches missed.">        if (_oid != null &amp;&amp; _meta.getField(field).isPrimaryKey())</span>
<span class="nc" id="L2259">            throw translate(new InvalidStateException(_loc.get</span>
<span class="nc" id="L2260">                (&quot;change-identity&quot;)).setFailedObject(getManagedInstance()));</span>
<span class="nc" id="L2261">    }</span>

    /**
     * Disallows setting an object id field to a managed instance.
     */
    void assertNotManagedObjectId(Object val) {
<span class="nc bnc" id="L2267" title="All 2 branches missed.">        if (val != null</span>
<span class="nc" id="L2268">            &amp;&amp; (ImplHelper.toPersistenceCapable(val,</span>
<span class="nc bnc" id="L2269" title="All 2 branches missed.">                 getContext().getConfiguration())).pcGetGenericContext()!= null)</span>
<span class="nc" id="L2270">            throw translate(new InvalidStateException(_loc.get</span>
<span class="nc" id="L2271">                (&quot;managed-oid&quot;, Exceptions.toString(val),</span>
<span class="nc" id="L2272">                    Exceptions.toString(getManagedInstance()))).</span>
<span class="nc" id="L2273">                setFailedObject(getManagedInstance()));</span>
<span class="nc" id="L2274">    }</span>

    ////////////////////////////
    // Delegate to FieldManager
    ////////////////////////////

    @Override
    public void providedBooleanField(PersistenceCapable pc, int field,
        boolean curVal) {
<span class="nc" id="L2283">        _fm.storeBooleanField(field, curVal);</span>
<span class="nc" id="L2284">    }</span>

    @Override
    public void providedByteField(PersistenceCapable pc, int field,
        byte curVal) {
<span class="nc" id="L2289">        _fm.storeByteField(field, curVal);</span>
<span class="nc" id="L2290">    }</span>

    @Override
    public void providedCharField(PersistenceCapable pc, int field,
        char curVal) {
<span class="nc" id="L2295">        _fm.storeCharField(field, curVal);</span>
<span class="nc" id="L2296">    }</span>

    @Override
    public void providedDoubleField(PersistenceCapable pc, int field,
        double curVal) {
<span class="nc" id="L2301">        _fm.storeDoubleField(field, curVal);</span>
<span class="nc" id="L2302">    }</span>

    @Override
    public void providedFloatField(PersistenceCapable pc, int field,
        float curVal) {
<span class="nc" id="L2307">        _fm.storeFloatField(field, curVal);</span>
<span class="nc" id="L2308">    }</span>

    @Override
    public void providedIntField(PersistenceCapable pc, int field,
        int curVal) {
<span class="nc" id="L2313">        _fm.storeIntField(field, curVal);</span>
<span class="nc" id="L2314">    }</span>

    @Override
    public void providedLongField(PersistenceCapable pc, int field,
        long curVal) {
<span class="nc" id="L2319">        _fm.storeLongField(field, curVal);</span>
<span class="nc" id="L2320">    }</span>

    @Override
    public void providedObjectField(PersistenceCapable pc, int field,
        Object curVal) {
<span class="nc" id="L2325">        _fm.storeObjectField(field, curVal);</span>
<span class="nc" id="L2326">    }</span>

    @Override
    public void providedShortField(PersistenceCapable pc, int field,
        short curVal) {
<span class="nc" id="L2331">        _fm.storeShortField(field, curVal);</span>
<span class="nc" id="L2332">    }</span>

    @Override
    public void providedStringField(PersistenceCapable pc, int field,
        String curVal) {
<span class="nc" id="L2337">        _fm.storeStringField(field, curVal);</span>
<span class="nc" id="L2338">    }</span>

    @Override
    public boolean replaceBooleanField(PersistenceCapable pc, int field) {
<span class="nc" id="L2342">        return _fm.fetchBooleanField(field);</span>
    }

    @Override
    public byte replaceByteField(PersistenceCapable pc, int field) {
<span class="nc" id="L2347">        return _fm.fetchByteField(field);</span>
    }

    @Override
    public char replaceCharField(PersistenceCapable pc, int field) {
<span class="nc" id="L2352">        return _fm.fetchCharField(field);</span>
    }

    @Override
    public double replaceDoubleField(PersistenceCapable pc, int field) {
<span class="nc" id="L2357">        return _fm.fetchDoubleField(field);</span>
    }

    @Override
    public float replaceFloatField(PersistenceCapable pc, int field) {
<span class="nc" id="L2362">        return _fm.fetchFloatField(field);</span>
    }

    @Override
    public int replaceIntField(PersistenceCapable pc, int field) {
<span class="nc" id="L2367">        return _fm.fetchIntField(field);</span>
    }

    @Override
    public long replaceLongField(PersistenceCapable pc, int field) {
<span class="nc" id="L2372">        return _fm.fetchLongField(field);</span>
    }

    @Override
    public Object replaceObjectField(PersistenceCapable pc, int field) {
<span class="nc" id="L2377">        return _fm.fetchObjectField(field);</span>
    }

    @Override
    public short replaceShortField(PersistenceCapable pc, int field) {
<span class="nc" id="L2382">        return _fm.fetchShortField(field);</span>
    }

    @Override
    public String replaceStringField(PersistenceCapable pc, int field) {
<span class="nc" id="L2387">        return _fm.fetchStringField(field);</span>
    }

    //////////////////////////////////
    // Implementation of FieldManager
    //////////////////////////////////

    @Override
    public boolean fetchBoolean(int field) {
<span class="nc" id="L2396">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2397" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2398">            return fetchBooleanField(field);</span>

<span class="nc" id="L2400">        Object val = fetchField(field, false);</span>
<span class="nc" id="L2401">        return ((Boolean) fmd.getExternalValue(val, _broker)).booleanValue();</span>
    }

    @Override
    public boolean fetchBooleanField(int field) {
<span class="nc" id="L2406">        lock();</span>
        try {
<span class="nc bnc" id="L2408" title="All 2 branches missed.">            if (!_loaded.get(field))</span>
<span class="nc" id="L2409">                loadField(field, LockLevels.LOCK_NONE, false, false);</span>

<span class="nc" id="L2411">            provideField(_pc, _single, field);</span>
<span class="nc" id="L2412">            return _single.fetchBooleanField(field);</span>
        } finally {
<span class="nc" id="L2414">            unlock();</span>
        }
    }

    @Override
    public byte fetchByte(int field) {
<span class="nc" id="L2420">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2421" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2422">            return fetchByteField(field);</span>

<span class="nc" id="L2424">        Object val = fetchField(field, false);</span>
<span class="nc" id="L2425">        return ((Number) fmd.getExternalValue(val, _broker)).byteValue();</span>
    }

    @Override
    public byte fetchByteField(int field) {
<span class="nc" id="L2430">        lock();</span>
        try {
<span class="nc bnc" id="L2432" title="All 2 branches missed.">            if (!_loaded.get(field))</span>
<span class="nc" id="L2433">                loadField(field, LockLevels.LOCK_NONE, false, false);</span>

<span class="nc" id="L2435">            provideField(_pc, _single, field);</span>
<span class="nc" id="L2436">            return _single.fetchByteField(field);</span>
        } finally {
<span class="nc" id="L2438">            unlock();</span>
        }
    }

    @Override
    public char fetchChar(int field) {
<span class="nc" id="L2444">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2445" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2446">            return fetchCharField(field);</span>

<span class="nc" id="L2448">        Object val = fetchField(field, false);</span>
<span class="nc" id="L2449">        return ((Character) fmd.getExternalValue(val, _broker)).charValue();</span>
    }

    @Override
    public char fetchCharField(int field) {
<span class="nc" id="L2454">        lock();</span>
        try {
<span class="nc bnc" id="L2456" title="All 2 branches missed.">            if (!_loaded.get(field))</span>
<span class="nc" id="L2457">                loadField(field, LockLevels.LOCK_NONE, false, false);</span>

<span class="nc" id="L2459">            provideField(_pc, _single, field);</span>
<span class="nc" id="L2460">            return _single.fetchCharField(field);</span>
        } finally {
<span class="nc" id="L2462">            unlock();</span>
        }
    }

    @Override
    public double fetchDouble(int field) {
<span class="nc" id="L2468">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2469" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2470">            return fetchDoubleField(field);</span>

<span class="nc" id="L2472">        Object val = fetchField(field, false);</span>
<span class="nc" id="L2473">        return ((Number) fmd.getExternalValue(val, _broker)).doubleValue();</span>
    }

    @Override
    public double fetchDoubleField(int field) {
<span class="nc" id="L2478">        lock();</span>
        try {
<span class="nc bnc" id="L2480" title="All 2 branches missed.">            if (!_loaded.get(field))</span>
<span class="nc" id="L2481">                loadField(field, LockLevels.LOCK_NONE, false, false);</span>

<span class="nc" id="L2483">            provideField(_pc, _single, field);</span>
<span class="nc" id="L2484">            return _single.fetchDoubleField(field);</span>
        } finally {
<span class="nc" id="L2486">            unlock();</span>
        }
    }

    @Override
    public float fetchFloat(int field) {
<span class="nc" id="L2492">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2493" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2494">            return fetchFloatField(field);</span>

<span class="nc" id="L2496">        Object val = fetchField(field, false);</span>
<span class="nc" id="L2497">        return ((Number) fmd.getExternalValue(val, _broker)).floatValue();</span>
    }

    @Override
    public float fetchFloatField(int field) {
<span class="nc" id="L2502">        lock();</span>
        try {
<span class="nc bnc" id="L2504" title="All 2 branches missed.">            if (!_loaded.get(field))</span>
<span class="nc" id="L2505">                loadField(field, LockLevels.LOCK_NONE, false, false);</span>

<span class="nc" id="L2507">            provideField(_pc, _single, field);</span>
<span class="nc" id="L2508">            return _single.fetchFloatField(field);</span>
        } finally {
<span class="nc" id="L2510">            unlock();</span>
        }
    }

    @Override
    public int fetchInt(int field) {
<span class="nc" id="L2516">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2517" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2518">            return fetchIntField(field);</span>

<span class="nc" id="L2520">        Object val = fetchField(field, false);</span>
<span class="nc" id="L2521">        return ((Number) fmd.getExternalValue(val, _broker)).intValue();</span>
    }

    @Override
    public int fetchIntField(int field) {
<span class="nc" id="L2526">        lock();</span>
        try {
<span class="nc bnc" id="L2528" title="All 2 branches missed.">            if (!_loaded.get(field))</span>
<span class="nc" id="L2529">                loadField(field, LockLevels.LOCK_NONE, false, false);</span>

<span class="nc" id="L2531">            provideField(_pc, _single, field);</span>
<span class="nc" id="L2532">            return _single.fetchIntField(field);</span>
        } finally {
<span class="nc" id="L2534">            unlock();</span>
        }
    }

    @Override
    public long fetchLong(int field) {
<span class="nc" id="L2540">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2541" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2542">            return fetchLongField(field);</span>

<span class="nc" id="L2544">        Object val = fetchField(field, false);</span>
<span class="nc" id="L2545">        return ((Number) fmd.getExternalValue(val, _broker)).longValue();</span>
    }

    @Override
    public long fetchLongField(int field) {
<span class="nc" id="L2550">        lock();</span>
        try {
<span class="nc bnc" id="L2552" title="All 2 branches missed.">            if (!_loaded.get(field))</span>
<span class="nc" id="L2553">                loadField(field, LockLevels.LOCK_NONE, false, false);</span>

<span class="nc" id="L2555">            provideField(_pc, _single, field);</span>
<span class="nc" id="L2556">            return _single.fetchLongField(field);</span>
        } finally {
<span class="nc" id="L2558">            unlock();</span>
        }
    }

    @Override
    public Object fetchObject(int field) {
<span class="nc" id="L2564">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2565" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2566">            return fetchObjectField(field);</span>

<span class="nc" id="L2568">        Object val = fetchField(field, false);</span>
<span class="nc" id="L2569">        return fmd.getExternalValue(val, _broker);</span>
    }

    @Override
    public Object fetchObjectField(int field) {
<span class="nc" id="L2574">        lock();</span>
        try {
<span class="nc bnc" id="L2576" title="All 2 branches missed.">            if (!_loaded.get(field))</span>
<span class="nc" id="L2577">                loadField(field, LockLevels.LOCK_NONE, false, false);</span>

<span class="nc" id="L2579">            provideField(_pc, _single, field);</span>
<span class="nc" id="L2580">            return _single.fetchObjectField(field);</span>
        } finally {
<span class="nc" id="L2582">            unlock();</span>
        }
    }

    @Override
    public short fetchShort(int field) {
<span class="nc" id="L2588">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2589" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2590">            return fetchShortField(field);</span>

<span class="nc" id="L2592">        Object val = fetchField(field, false);</span>
<span class="nc" id="L2593">        return ((Number) fmd.getExternalValue(val, _broker)).shortValue();</span>
    }

    @Override
    public short fetchShortField(int field) {
<span class="nc" id="L2598">        lock();</span>
        try {
<span class="nc bnc" id="L2600" title="All 2 branches missed.">            if (!_loaded.get(field))</span>
<span class="nc" id="L2601">                loadField(field, LockLevels.LOCK_NONE, false, false);</span>

<span class="nc" id="L2603">            provideField(_pc, _single, field);</span>
<span class="nc" id="L2604">            return _single.fetchShortField(field);</span>
        } finally {
<span class="nc" id="L2606">            unlock();</span>
        }
    }

    @Override
    public String fetchString(int field) {
<span class="nc" id="L2612">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2613" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2614">            return fetchStringField(field);</span>

<span class="nc" id="L2616">        Object val = fetchField(field, false);</span>
<span class="nc" id="L2617">        return (String) fmd.getExternalValue(val, _broker);</span>
    }

    @Override
    public String fetchStringField(int field) {
<span class="nc" id="L2622">        lock();</span>
        try {
<span class="nc bnc" id="L2624" title="All 2 branches missed.">            if (!_loaded.get(field))</span>
<span class="nc" id="L2625">                loadField(field, LockLevels.LOCK_NONE, false, false);</span>

<span class="nc" id="L2627">            provideField(_pc, _single, field);</span>
<span class="nc" id="L2628">            return _single.fetchStringField(field);</span>
        } finally {
<span class="nc" id="L2630">            unlock();</span>
        }
    }

    @Override
    public void storeBoolean(int field, boolean externalVal) {
<span class="nc" id="L2636">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2637" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2638">            storeBooleanField(field, externalVal);</span>
        else {
<span class="nc bnc" id="L2640" title="All 2 branches missed.">            Object val = (externalVal) ? Boolean.TRUE : Boolean.FALSE;</span>
<span class="nc" id="L2641">            storeField(field, fmd.getFieldValue(val, _broker));</span>
        }
<span class="nc" id="L2643">    }</span>

    @Override
    public void storeBooleanField(int field, boolean curVal) {
<span class="nc" id="L2647">        lock();</span>
        try {
<span class="nc" id="L2649">            _single.storeBooleanField(field, curVal);</span>
<span class="nc" id="L2650">            replaceField(_pc, _single, field);</span>
<span class="nc" id="L2651">            setLoaded(field, true);</span>
<span class="nc" id="L2652">            postLoad(field, null);</span>
        } finally {
<span class="nc" id="L2654">            unlock();</span>
        }
<span class="nc" id="L2656">    }</span>

    @Override
    public void storeByte(int field, byte externalVal) {
<span class="nc" id="L2660">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2661" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2662">            storeByteField(field, externalVal);</span>
        else
<span class="nc" id="L2664">            storeField(field, fmd.getFieldValue(Byte.valueOf(externalVal),</span>
                _broker));
<span class="nc" id="L2666">    }</span>

    @Override
    public void storeByteField(int field, byte curVal) {
<span class="nc" id="L2670">        lock();</span>
        try {
<span class="nc" id="L2672">            _single.storeByteField(field, curVal);</span>
<span class="nc" id="L2673">            replaceField(_pc, _single, field);</span>
<span class="nc" id="L2674">            setLoaded(field, true);</span>
<span class="nc" id="L2675">            postLoad(field, null);</span>
        } finally {
<span class="nc" id="L2677">            unlock();</span>
        }
<span class="nc" id="L2679">    }</span>

    @Override
    public void storeChar(int field, char externalVal) {
<span class="nc" id="L2683">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2684" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2685">            storeCharField(field, externalVal);</span>
        else
<span class="nc" id="L2687">            storeField(field, fmd.getFieldValue(Character.valueOf(externalVal),</span>
                _broker));
<span class="nc" id="L2689">    }</span>

    @Override
    public void storeCharField(int field, char curVal) {
<span class="nc" id="L2693">        lock();</span>
        try {
<span class="nc" id="L2695">            _single.storeCharField(field, curVal);</span>
<span class="nc" id="L2696">            replaceField(_pc, _single, field);</span>
<span class="nc" id="L2697">            setLoaded(field, true);</span>
<span class="nc" id="L2698">            postLoad(field, null);</span>
        } finally {
<span class="nc" id="L2700">            unlock();</span>
        }
<span class="nc" id="L2702">    }</span>

    @Override
    public void storeDouble(int field, double externalVal) {
<span class="nc" id="L2706">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2707" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2708">            storeDoubleField(field, externalVal);</span>
        else
<span class="nc" id="L2710">            storeField(field, fmd.getFieldValue(Double.valueOf(externalVal), _broker));</span>
<span class="nc" id="L2711">    }</span>

    @Override
    public void storeDoubleField(int field, double curVal) {
<span class="nc" id="L2715">        lock();</span>
        try {
<span class="nc" id="L2717">            _single.storeDoubleField(field, curVal);</span>
<span class="nc" id="L2718">            replaceField(_pc, _single, field);</span>
<span class="nc" id="L2719">            setLoaded(field, true);</span>
<span class="nc" id="L2720">            postLoad(field, null);</span>
        } finally {
<span class="nc" id="L2722">            unlock();</span>
        }
<span class="nc" id="L2724">    }</span>

    @Override
    public void storeFloat(int field, float externalVal) {
<span class="nc" id="L2728">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2729" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2730">            storeFloatField(field, externalVal);</span>
        else
<span class="nc" id="L2732">            storeField(field, fmd.getFieldValue(Float.valueOf(externalVal), _broker));</span>
<span class="nc" id="L2733">    }</span>

    @Override
    public void storeFloatField(int field, float curVal) {
<span class="nc" id="L2737">        lock();</span>
        try {
<span class="nc" id="L2739">            _single.storeFloatField(field, curVal);</span>
<span class="nc" id="L2740">            replaceField(_pc, _single, field);</span>
<span class="nc" id="L2741">            setLoaded(field, true);</span>
<span class="nc" id="L2742">            postLoad(field, null);</span>
        } finally {
<span class="nc" id="L2744">            unlock();</span>
        }
<span class="nc" id="L2746">    }</span>

    @Override
    public void storeInt(int field, int externalVal) {
<span class="nc" id="L2750">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2751" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2752">            storeIntField(field, externalVal);</span>
        else
<span class="nc" id="L2754">            storeField(field, fmd.getFieldValue(externalVal,</span>
                _broker));
<span class="nc" id="L2756">    }</span>

    @Override
    public void storeIntField(int field, int curVal) {
<span class="nc" id="L2760">        lock();</span>
        try {
<span class="nc" id="L2762">            _single.storeIntField(field, curVal);</span>
<span class="nc" id="L2763">            replaceField(_pc, _single, field);</span>
<span class="nc" id="L2764">            setLoaded(field, true);</span>
<span class="nc" id="L2765">            postLoad(field, null);</span>
        } finally {
<span class="nc" id="L2767">            unlock();</span>
        }
<span class="nc" id="L2769">    }</span>

    @Override
    public void storeLong(int field, long externalVal) {
<span class="nc" id="L2773">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2774" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2775">            storeLongField(field, externalVal);</span>
        else
<span class="nc" id="L2777">            storeField(field, fmd.getFieldValue(externalVal,</span>
                _broker));
<span class="nc" id="L2779">    }</span>

    @Override
    public void storeLongField(int field, long curVal) {
<span class="nc" id="L2783">        lock();</span>
        try {
<span class="nc" id="L2785">            _single.storeLongField(field, curVal);</span>
<span class="nc" id="L2786">            replaceField(_pc, _single, field);</span>
<span class="nc" id="L2787">            setLoaded(field, true);</span>
<span class="nc" id="L2788">            postLoad(field, null);</span>
        } finally {
<span class="nc" id="L2790">            unlock();</span>
        }
<span class="nc" id="L2792">    }</span>

    @Override
    public void storeObject(int field, Object externalVal) {
<span class="nc" id="L2796">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc" id="L2797">        externalVal = fmd.order(externalVal);</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2799">            storeObjectField(field, externalVal);</span>
        else
<span class="nc" id="L2801">            storeField(field, fmd.getFieldValue(externalVal, _broker));</span>
<span class="nc" id="L2802">    }</span>

    @Override
    public void storeObjectField(int field, Object curVal) {
<span class="nc" id="L2806">        lock();</span>
        try {
<span class="nc" id="L2808">            _single.storeObjectField(field, curVal);</span>
<span class="nc" id="L2809">            _single.proxy(true, false);</span>
<span class="nc" id="L2810">            replaceField(_pc, _single, field);</span>
<span class="nc" id="L2811">            setLoaded(field, true);</span>
<span class="nc" id="L2812">            postLoad(field, null);</span>
        } finally {
<span class="nc" id="L2814">            unlock();</span>
        }
<span class="nc" id="L2816">    }</span>

    @Override
    public void storeShort(int field, short externalVal) {
<span class="nc" id="L2820">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2821" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2822">            storeShortField(field, externalVal);</span>
        else
<span class="nc" id="L2824">            storeField(field, fmd.getFieldValue(Short.valueOf(externalVal),</span>
                _broker));
<span class="nc" id="L2826">    }</span>

    @Override
    public void storeShortField(int field, short curVal) {
<span class="nc" id="L2830">        lock();</span>
        try {
<span class="nc" id="L2832">            _single.storeShortField(field, curVal);</span>
<span class="nc" id="L2833">            replaceField(_pc, _single, field);</span>
<span class="nc" id="L2834">            setLoaded(field, true);</span>
<span class="nc" id="L2835">            postLoad(field, null);</span>
        } finally {
<span class="nc" id="L2837">            unlock();</span>
        }
<span class="nc" id="L2839">    }</span>

    @Override
    public void storeString(int field, String externalVal) {
<span class="nc" id="L2843">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2844" title="All 2 branches missed.">        if (!fmd.isExternalized())</span>
<span class="nc" id="L2845">            storeStringField(field, externalVal);</span>
        else
<span class="nc" id="L2847">            storeField(field, fmd.getFieldValue(externalVal, _broker));</span>
<span class="nc" id="L2848">    }</span>

    @Override
    public void storeStringField(int field, String curVal) {
<span class="nc" id="L2852">        lock();</span>
        try {
<span class="nc" id="L2854">            _single.storeStringField(field, curVal);</span>
<span class="nc" id="L2855">            replaceField(_pc, _single, field);</span>
<span class="nc" id="L2856">            setLoaded(field, true);</span>
<span class="nc" id="L2857">            postLoad(field, null);</span>
        } finally {
<span class="nc" id="L2859">            unlock();</span>
        }
<span class="nc" id="L2861">    }</span>

    /**
     * Store the given field value into the given field manager.
     */
    private void storeField(int field, Object val, FieldManager fm) {
<span class="nc" id="L2867">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L2868" title="All 2 branches missed.">        if (fmd == null)</span>
<span class="nc" id="L2869">            throw new UserException(_loc.get(&quot;no-field-index&quot;,</span>
<span class="nc" id="L2870">                String.valueOf(field), _meta.getDescribedType())).</span>
<span class="nc" id="L2871">                setFailedObject(getManagedInstance());</span>

<span class="nc bnc" id="L2873" title="All 10 branches missed.">        switch (fmd.getDeclaredTypeCode()) {</span>
            case JavaTypes.BOOLEAN:
<span class="nc bnc" id="L2875" title="All 4 branches missed.">                boolean bool = val != null &amp;&amp; ((Boolean) val).booleanValue();</span>
<span class="nc" id="L2876">                fm.storeBooleanField(field, bool);</span>
<span class="nc" id="L2877">                break;</span>
            case JavaTypes.BYTE:
<span class="nc bnc" id="L2879" title="All 2 branches missed.">                byte b = (val == null) ? 0 : ((Number) val).byteValue();</span>
<span class="nc" id="L2880">                fm.storeByteField(field, b);</span>
<span class="nc" id="L2881">                break;</span>
            case JavaTypes.CHAR:
<span class="nc bnc" id="L2883" title="All 2 branches missed.">                char c = (val == null) ? 0 : ((Character) val).charValue();</span>
<span class="nc" id="L2884">                fm.storeCharField(field, c);</span>
<span class="nc" id="L2885">                break;</span>
            case JavaTypes.DOUBLE:
<span class="nc bnc" id="L2887" title="All 2 branches missed.">                double d = (val == null) ? 0 : ((Number) val).doubleValue();</span>
<span class="nc" id="L2888">                fm.storeDoubleField(field, d);</span>
<span class="nc" id="L2889">                break;</span>
            case JavaTypes.FLOAT:
<span class="nc bnc" id="L2891" title="All 2 branches missed.">                float f = (val == null) ? 0 : ((Number) val).floatValue();</span>
<span class="nc" id="L2892">                fm.storeFloatField(field, f);</span>
<span class="nc" id="L2893">                break;</span>
            case JavaTypes.INT:
<span class="nc bnc" id="L2895" title="All 2 branches missed.">                int i = (val == null) ? 0 : ((Number) val).intValue();</span>
<span class="nc" id="L2896">                fm.storeIntField(field, i);</span>
<span class="nc" id="L2897">                break;</span>
            case JavaTypes.LONG:
<span class="nc bnc" id="L2899" title="All 2 branches missed.">                long l = (val == null) ? 0 : ((Number) val).longValue();</span>
<span class="nc" id="L2900">                fm.storeLongField(field, l);</span>
<span class="nc" id="L2901">                break;</span>
            case JavaTypes.SHORT:
<span class="nc bnc" id="L2903" title="All 2 branches missed.">                short s = (val == null) ? 0 : ((Number) val).shortValue();</span>
<span class="nc" id="L2904">                fm.storeShortField(field, s);</span>
<span class="nc" id="L2905">                break;</span>
            case JavaTypes.STRING:
<span class="nc" id="L2907">                fm.storeStringField(field, (String) val);</span>
<span class="nc" id="L2908">                break;</span>
            default:
<span class="nc" id="L2910">                fm.storeObjectField(field, val);</span>
        }
<span class="nc" id="L2912">    }</span>

    /////////////
    // Utilities
    /////////////

    /**
     * Erase the fact that this instance has been flushed.
     */
    void eraseFlush() {
<span class="nc" id="L2922">        _flags &amp;= ~FLAG_FLUSHED;</span>
<span class="nc" id="L2923">        _flags &amp;= ~FLAG_FLUSHED_DIRTY;</span>

<span class="nc" id="L2925">        _flush = null;</span>
<span class="nc" id="L2926">    }</span>

    /**
     * Records that all instance fields are/are not loaded.
     * Primary key and non-persistent fields are not affected.
     */
    void setLoaded(boolean val) {
<span class="nc" id="L2933">        FieldMetaData[] fmds = _meta.getFields();</span>
<span class="nc bnc" id="L2934" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L2935" title="All 2 branches missed.">            if (!fmds[i].isPrimaryKey()</span>
<span class="nc bnc" id="L2936" title="All 2 branches missed.">                &amp;&amp; fmds[i].getManagement() == FieldMetaData.MANAGE_PERSISTENT)</span>
<span class="nc" id="L2937">                setLoaded(i, val);</span>
        }
<span class="nc bnc" id="L2939" title="All 2 branches missed.">        if (!val) {</span>
<span class="nc" id="L2940">            _flags &amp;= ~FLAG_LOADED;</span>
<span class="nc" id="L2941">            setDirty(false);</span>
        } else
<span class="nc" id="L2943">            _flags |= FLAG_LOADED;</span>
<span class="nc" id="L2944">    }</span>

    /**
     * Records that all instance fields are/are not dirty,
     * and changes the flags of the instance accordingly.
     */
    void setDirty(boolean val) {
<span class="nc" id="L2951">        FieldMetaData[] fmds = _meta.getFields();</span>
<span class="nc bnc" id="L2952" title="All 4 branches missed.">        boolean update = !isNew() || isFlushed();</span>
<span class="nc bnc" id="L2953" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L2954" title="All 6 branches missed.">            if (val &amp;&amp; (!update || fmds[i].getUpdateStrategy() != UpdateStrategies.IGNORE))</span>
<span class="nc" id="L2955">                setFieldDirty(i);</span>
<span class="nc bnc" id="L2956" title="All 2 branches missed.">            else if (!val) {</span>
                // we never consider clean fields flushed; this also takes
                // care of clearing the flushed fields on commit/rollback
<span class="nc" id="L2959">                clearFlushField(i);</span>
<span class="nc" id="L2960">                clearDirty(i);</span>
            }
        }

<span class="nc bnc" id="L2964" title="All 2 branches missed.">        if (val)</span>
<span class="nc" id="L2965">            _flags |= FLAG_LOADED;</span>
<span class="nc" id="L2966">    }</span>

    /**
     * Executes pre-clear callbacks, clears all managed fields, and calls the
     * {@link #setLoaded} method with a value of false. Primary key fields
     * are not cleared.
     */
    void clearFields() {
<span class="nc bnc" id="L2974" title="All 2 branches missed.">        if (!isIntercepting())</span>
<span class="nc" id="L2975">            return;</span>

<span class="nc" id="L2977">        fireLifecycleEvent(LifecycleEvent.BEFORE_CLEAR);</span>

        // unproxy all fields
<span class="nc" id="L2980">        unproxyFields();</span>

<span class="nc" id="L2982">        lock();</span>
        try {
            // clear non-pk fields
<span class="nc" id="L2985">            FieldMetaData[] fmds = _meta.getFields();</span>
<span class="nc bnc" id="L2986" title="All 2 branches missed.">            for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L2987" title="All 4 branches missed.">                if (!fmds[i].isPrimaryKey() &amp;&amp; fmds[i].getManagement()</span>
                    == FieldMetaData.MANAGE_PERSISTENT)
<span class="nc" id="L2989">                    replaceField(_pc, ClearFieldManager.getInstance(), i);</span>
            }

            // forget version info and impl data so we re-read next time
<span class="nc" id="L2993">            setLoaded(false);</span>
<span class="nc" id="L2994">            _version = null;</span>
<span class="nc" id="L2995">            _loadVersion = null;</span>
<span class="nc bnc" id="L2996" title="All 2 branches missed.">            if (_fieldImpl != null)</span>
<span class="nc" id="L2997">                Arrays.fill(_fieldImpl, null);</span>
        } finally {
<span class="nc" id="L2999">            unlock();</span>
        }

<span class="nc" id="L3002">        fireLifecycleEvent(LifecycleEvent.AFTER_CLEAR);</span>
<span class="nc" id="L3003">    }</span>

    /**
     * Record that we should save any fields that change from this point
     * forward.
     */
    void saveFields(boolean immediate) {
<span class="nc bnc" id="L3010" title="All 4 branches missed.">        if (_broker.getRestoreState() == RestoreState.RESTORE_NONE</span>
            &amp;&amp; (_flags &amp; FLAG_INVERSES) == 0)
<span class="nc" id="L3012">            return;</span>

<span class="nc" id="L3014">        _flags |= FLAG_SAVE;</span>
<span class="nc bnc" id="L3015" title="All 2 branches missed.">        if (immediate) {</span>
<span class="nc bnc" id="L3016" title="All 2 branches missed.">            for (int i = 0, len = _loaded.length(); i &lt; len; i++)</span>
<span class="nc" id="L3017">                saveField(i);</span>
<span class="nc" id="L3018">            _flags &amp;= ~FLAG_SAVE;</span>
            // OPENJPA-659
            // record a saved field manager even if no field is currently loaded
            // as existence of a SaveFieldManager is critical for a dirty check
<span class="nc bnc" id="L3022" title="All 2 branches missed.">            if (_saved == null)</span>
<span class="nc" id="L3023">                _saved = new SaveFieldManager(this, getPersistenceCapable(), getDirty());</span>
        }
<span class="nc" id="L3025">    }</span>

    /**
     * If the field isn't already saved, saves the currently loaded field
     * state of the instance. The saved values can all be restored via
     * {@link #restoreFields}.
     */
    private void saveField(int field) {
<span class="nc bnc" id="L3033" title="All 2 branches missed.">        if ((_flags &amp; FLAG_SAVE) == 0)</span>
<span class="nc" id="L3034">            return;</span>

        // if this is a managed inverse field, load it so we're sure to have
        // the original value
<span class="nc bnc" id="L3038" title="All 4 branches missed.">        if (!_loaded.get(field) &amp;&amp; ((_flags &amp; FLAG_INVERSES) != 0</span>
<span class="nc bnc" id="L3039" title="All 2 branches missed.">            &amp;&amp; _meta.getField(field).getInverseMetaDatas().length &gt; 0))</span>
<span class="nc" id="L3040">            loadField(field, LockLevels.LOCK_NONE, false, false);</span>

        // don't bother creating the save field manager if we're not going to
        // save the old field value anyway
<span class="nc bnc" id="L3044" title="All 2 branches missed.">        if (_saved == null) {</span>
<span class="nc bnc" id="L3045" title="All 2 branches missed.">            if (_loaded.get(field))</span>
<span class="nc" id="L3046">                _saved = new SaveFieldManager(this, null, getDirty());</span>
            else
<span class="nc" id="L3048">                return;</span>
        }

        // copy the field to save field manager; if the field is not directly
        // copyable, immediately provide and replace it via the save field
        // manager, which will copy the mutable value to prevent by-ref mods
<span class="nc bnc" id="L3054" title="All 2 branches missed.">        if (_saved.saveField(field)) {</span>
<span class="nc" id="L3055">            provideField(_pc, _saved, field);</span>
<span class="nc" id="L3056">            replaceField(_saved.getState(), _saved, field);</span>
        }
<span class="nc" id="L3058">    }</span>

    /**
     * Notification that the state will not need to be rolled back
     * to that of the last call to {@link #saveFields}.
     */
    void clearSavedFields() {
<span class="nc bnc" id="L3065" title="All 2 branches missed.">        if (isIntercepting()) {</span>
<span class="nc" id="L3066">            _flags &amp;= ~FLAG_SAVE;</span>
<span class="nc" id="L3067">            _saved = null;</span>
        }
<span class="nc" id="L3069">    }</span>

    public SaveFieldManager getSaveFieldManager() {
<span class="nc" id="L3072">        return _saved;</span>
    }

    /**
     * Rollback the state of the instance to the saved state from the
     * last call to {@link #saveFields}, or to default values if never saved.
     */
    void restoreFields() {
<span class="nc" id="L3080">        lock();</span>
        try {
<span class="nc bnc" id="L3082" title="All 2 branches missed.">            if (_saved == null) {</span>
<span class="nc bnc" id="L3083" title="All 2 branches missed.">                if ((_flags &amp; FLAG_SAVE) == 0)</span>
<span class="nc" id="L3084">                    clearFields();</span>
                else // only unloaded fields were dirtied
<span class="nc" id="L3086">                    _loaded.andNot(_loaded);</span>
            }
            // we direct state transitions based on our own getRestoreState
            // method, but to decide whether to actually rollback field
            // values, we consult the broker for the user's setting
<span class="nc bnc" id="L3091" title="All 2 branches missed.">            else if (_broker.getRestoreState() != RestoreState.RESTORE_NONE) {</span>
                // rollback all currently-loaded fields
<span class="nc bnc" id="L3093" title="All 2 branches missed.">                for (int i = 0, len = _loaded.length(); i &lt; len; i++)</span>
<span class="nc bnc" id="L3094" title="All 4 branches missed.">                    if (_loaded.get(i) &amp;&amp; _saved.restoreField(i))</span>
<span class="nc" id="L3095">                        replaceField(_pc, _saved, i);</span>

                // rollback loaded set
<span class="nc" id="L3098">                _loaded.andNot(_saved.getUnloaded());</span>
            }
        }
        finally {
<span class="nc" id="L3102">            unlock();</span>
        }
<span class="nc" id="L3104">    }</span>

    /**
     * Replaces all second class object fields with fresh proxied instances
     * containing the same information as the originals.
     * &lt;br&gt;
     * &lt;B&gt;Note:&lt;/B&gt; Proxying is bypassed if {@link AutoDetach#DETACH_NONE} option is set.
     */
    void proxyFields(boolean reset, boolean replaceNull) {
<span class="nc bnc" id="L3113" title="All 2 branches missed.">    	if (getBroker().getAutoDetach() == AutoDetach.DETACH_NONE)</span>
<span class="nc" id="L3114">           return;</span>
        // we only replace nulls if the runtime can't differentiate between
        // null and empty containers.  we replace nulls in this case to
        // maintain consistency whether values are being retained or not
<span class="nc bnc" id="L3118" title="All 2 branches missed.">        if (replaceNull)</span>
<span class="nc" id="L3119">            replaceNull = !_broker.getConfiguration().supportedOptions().</span>
<span class="nc bnc" id="L3120" title="All 2 branches missed.">                contains(OpenJPAConfiguration.OPTION_NULL_CONTAINER);</span>

<span class="nc" id="L3122">        lock();</span>
        try {
<span class="nc bnc" id="L3124" title="All 2 branches missed.">            for (FieldMetaData fmd : _meta.getProxyFields()) {</span>
<span class="nc" id="L3125">                int index = fmd.getIndex();</span>
                // only reload if dirty
<span class="nc bnc" id="L3127" title="All 4 branches missed.">                if (_loaded.get(index) &amp;&amp; isFieldDirty(index)) {</span>
<span class="nc" id="L3128">                    provideField(_pc, _single, index);</span>
<span class="nc bnc" id="L3129" title="All 2 branches missed.">                    if (_single.proxy(reset, replaceNull)) {</span>
<span class="nc" id="L3130">                        replaceField(_pc, _single, index);</span>
                    } else {
<span class="nc" id="L3132">                        _single.clear();</span>
                    }
                }
            }
        } finally {
<span class="nc" id="L3137">            unlock();</span>
        }
<span class="nc" id="L3139">    }</span>

    /**
     * Unproxy all fields.
     */
    void unproxyFields() {
<span class="nc bnc" id="L3145" title="All 2 branches missed.">        if ((_flags &amp; FLAG_NO_UNPROXY) != 0)</span>
<span class="nc" id="L3146">            return;</span>

<span class="nc" id="L3148">        lock();</span>
        try {
<span class="nc bnc" id="L3150" title="All 2 branches missed.">            for (int i = 0, len = _loaded.length(); i &lt; len; i++) {</span>
<span class="nc" id="L3151">                provideField(_pc, _single, i);</span>
<span class="nc" id="L3152">                _single.unproxy();</span>
<span class="nc" id="L3153">                _single.releaseEmbedded();</span>
<span class="nc" id="L3154">                _single.clear();</span>
            }
        }
        finally {
<span class="nc" id="L3158">            unlock();</span>
        }
<span class="nc" id="L3160">    }</span>

    /**
     * Get ready for a flush. Persists all persistence-capable object fields,
     * and checks for illegal null values. Also assigns oids and field values
     * for all strategies that don't require flushing.
     */
    void preFlush(boolean logical, OpCallbacks call) {
<span class="nc bnc" id="L3168" title="All 2 branches missed.">        if ((_flags &amp; FLAG_PRE_FLUSHED) != 0)</span>
<span class="nc" id="L3169">            return;</span>

<span class="nc bnc" id="L3171" title="All 2 branches missed.">        if (isPersistent()) {</span>
<span class="nc" id="L3172">            fireLifecycleEvent(LifecycleEvent.BEFORE_STORE);</span>
            // BEFORE_PERSIST is handled during Broker.persist and Broker.attach
<span class="nc bnc" id="L3174" title="All 2 branches missed.">            if (isDeleted())</span>
<span class="nc" id="L3175">                fireLifecycleEvent(LifecycleEvent.BEFORE_DELETE);</span>
<span class="nc bnc" id="L3176" title="All 4 branches missed.">            else if (!(isNew() &amp;&amp; !isFlushed())</span>
<span class="nc bnc" id="L3177" title="All 2 branches missed.">				&amp;&amp; (ImplHelper.getUpdateFields(this) != null))</span>
<span class="nc" id="L3178">                fireLifecycleEvent(LifecycleEvent.BEFORE_UPDATE);</span>
<span class="nc" id="L3179">            _flags |= FLAG_PRE_FLUSHED;</span>
        }

<span class="nc" id="L3182">        lock();</span>
        try {
<span class="nc bnc" id="L3184" title="All 2 branches missed.">            if (!logical)</span>
<span class="nc" id="L3185">                assignObjectId(false, true);</span>
<span class="nc bnc" id="L3186" title="All 2 branches missed.">            for (int i = 0, len = _meta.getFields().length; i &lt; len; i++) {</span>
<span class="nc bnc" id="L3187" title="All 8 branches missed.">                if ((logical || !assignField(i, true)) &amp;&amp; !isFieldFlushed(i) &amp;&amp; isFieldDirty(i)) {</span>
<span class="nc" id="L3188">                    provideField(_pc, _single, i);</span>
<span class="nc bnc" id="L3189" title="All 2 branches missed.">                    if (_single.preFlush(logical, call))</span>
<span class="nc" id="L3190">                        replaceField(_pc, _single, i);</span>
                    else
<span class="nc" id="L3192">                        _single.clear();</span>
                }
            }

<span class="nc" id="L3196">            dirtyCheck();</span>
        } finally {
<span class="nc" id="L3198">            unlock();</span>
        }
<span class="nc" id="L3200">    }</span>

    /**
     * Make callbacks for deletion.
     */
    void preDelete() {
        // set a flag while call pre delete callback so that user can't
        // get into infinite recursion by calling delete(this)
        // within his callback method
<span class="nc bnc" id="L3209" title="All 2 branches missed.">        if ((_flags &amp; FLAG_PRE_DELETING) == 0) {</span>
<span class="nc" id="L3210">            _flags |= FLAG_PRE_DELETING;</span>
            try {
<span class="nc" id="L3212">                fireLifecycleEvent(LifecycleEvent.BEFORE_DELETE);</span>
            } finally {
<span class="nc" id="L3214">                _flags &amp;= ~FLAG_PRE_DELETING;</span>
            }
        }
<span class="nc" id="L3217">    }</span>

    /**
     * Cascade deletes and dereference dependent fields.
     */
    void cascadeDelete(OpCallbacks call) {
<span class="nc" id="L3223">        FieldMetaData[] fmds = _meta.getFields();</span>
<span class="nc bnc" id="L3224" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L3225" title="All 2 branches missed.">            if (fmds[i].getCascadeDelete() != ValueMetaData.CASCADE_NONE</span>
<span class="nc bnc" id="L3226" title="All 2 branches missed.">                || fmds[i].getKey().getCascadeDelete()</span>
                != ValueMetaData.CASCADE_NONE
<span class="nc bnc" id="L3228" title="All 2 branches missed.">                || fmds[i].getElement().getCascadeDelete()</span>
                != ValueMetaData.CASCADE_NONE) {
<span class="nc" id="L3230">                _single.storeObjectField(i, fetchField(i, false));</span>
<span class="nc" id="L3231">                _single.delete(call);</span>
<span class="nc" id="L3232">                _single.clear();</span>
            }
        }
<span class="nc" id="L3235">    }</span>

    /**
     * Called after an instance is persisted by a user through the broker.
     * Cascades the persist operation to fields marked
     * {@link ValueMetaData#CASCADE_IMMEDIATE}.
     */
    void cascadePersist(OpCallbacks call) {
<span class="nc" id="L3243">        FieldMetaData[] fmds = _meta.getFields();</span>
<span class="nc bnc" id="L3244" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L3245" title="All 2 branches missed.">            if (!_loaded.get(i))</span>
<span class="nc" id="L3246">                continue;</span>

<span class="nc bnc" id="L3248" title="All 2 branches missed.">            if (fmds[i].getCascadePersist() == ValueMetaData.CASCADE_IMMEDIATE</span>
<span class="nc bnc" id="L3249" title="All 2 branches missed.">             || fmds[i].getKey().getCascadePersist() == ValueMetaData.CASCADE_IMMEDIATE</span>
<span class="nc bnc" id="L3250" title="All 2 branches missed.">             || fmds[i].getElement().getCascadePersist() == ValueMetaData.CASCADE_IMMEDIATE) {</span>
<span class="nc" id="L3251">                _single.storeObjectField(i, fetchField(i, false));</span>
<span class="nc" id="L3252">                _single.persist(call);</span>
<span class="nc" id="L3253">                _single.clear();</span>
            }
        }
<span class="nc" id="L3256">    }</span>

    /**
     * Load the given field set from the data store into the instance.
     * Return true if any data is loaded, false otherwise.
     */
    boolean loadFields(BitSet fields, FetchConfiguration fetch, int lockLevel,
        Object sdata) {
        // can't load version field from store
<span class="nc bnc" id="L3265" title="All 2 branches missed.">        if (fields != null) {</span>
<span class="nc" id="L3266">            FieldMetaData vfield = _meta.getVersionField();</span>
<span class="nc bnc" id="L3267" title="All 2 branches missed.">            if (vfield != null)</span>
<span class="nc" id="L3268">                fields.clear(vfield.getIndex());</span>
        }

<span class="nc" id="L3271">        boolean ret = false;</span>
<span class="nc" id="L3272">        setLoading(true);</span>
        try {
            // if any fields given, load them
<span class="nc bnc" id="L3275" title="All 2 branches missed.">            int len = (fields == null) ? 0 : fields.length();</span>
<span class="nc bnc" id="L3276" title="All 2 branches missed.">            if (len &gt; 0) {</span>
<span class="nc bnc" id="L3277" title="All 2 branches missed.">                if (fetch == null)</span>
<span class="nc" id="L3278">                    fetch = _broker.getFetchConfiguration();</span>
<span class="nc bnc" id="L3279" title="All 2 branches missed.">                if (!_broker.getStoreManager().load(this, fields, fetch, lockLevel, sdata)) {</span>
<span class="nc" id="L3280">                    throw new ObjectNotFoundException(_loc.get(&quot;del-instance&quot;, _meta.getDescribedType(), _oid)).</span>
<span class="nc" id="L3281">                        setFailedObject(getManagedInstance());</span>
                }
<span class="nc" id="L3283">                ret = true;</span>
            }

            // make sure version information has been set; version info must
            // always be set after the first state load or set (which is why
            // we do this even if no fields were loaded -- could be that this
            // method is being called after a field is set)
            // If the _loadVersion field is null AND the version field has been loaded, skip calling sync version.
            // This indicates that the DB has a null value for the version column.
<span class="nc bnc" id="L3292" title="All 2 branches missed.">            FieldMetaData versionMeta = _meta != null ? _meta.getVersionField() : null;</span>
<span class="nc bnc" id="L3293" title="All 6 branches missed.">            if (_loadVersion == null &amp;&amp; (versionMeta != null &amp;&amp; !_loaded.get(versionMeta.getIndex()))) {</span>
<span class="nc" id="L3294">                syncVersion(sdata);</span>
<span class="nc bnc" id="L3295" title="All 4 branches missed.">                ret = ret || _loadVersion != null;</span>
            }
        }
        finally {
<span class="nc" id="L3299">            setLoading(false);</span>
        }

        // see if the dfg is now loaded; do this regardless of whether we
        // loaded any fields, cause may already have been loaded by
        // StoreManager during initialization
<span class="nc" id="L3305">        postLoad(-1, fetch);</span>
<span class="nc" id="L3306">        return ret;</span>
    }

    /**
     * Load the given field's fetch group; the field itself may already be
     * loaded if it is being set by the user.
     */
    protected void loadField(int field, int lockLevel, boolean forWrite,
        boolean fgs) {
<span class="nc" id="L3315">        FetchConfiguration fetch = _broker.getFetchConfiguration();</span>
<span class="nc" id="L3316">        FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc" id="L3317">        BitSet fields = null;</span>
<span class="nc" id="L3318">        boolean unloadedDFGFieldMarked = false;</span>

        // if this is a dfg field or we need to load our dfg, do so
<span class="nc bnc" id="L3321" title="All 4 branches missed.">        if (fgs &amp;&amp; (_flags &amp; FLAG_LOADED) == 0){</span>
<span class="nc" id="L3322">            fields = getUnloadedInternal(fetch, LOAD_FGS, null);</span>
<span class="nc" id="L3323">            unloadedDFGFieldMarked = true;</span>
        }
        // check for load fetch group
<span class="nc" id="L3326">        String lfg = fmd.getLoadFetchGroup();</span>
<span class="nc" id="L3327">        boolean lfgAdded = false;</span>
<span class="nc bnc" id="L3328" title="All 2 branches missed.">        if (lfg != null) {</span>
<span class="nc" id="L3329">            FieldMetaData[] fmds = _meta.getFields();</span>
<span class="nc bnc" id="L3330" title="All 2 branches missed.">            for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L3331" title="All 4 branches missed.">                if (!_loaded.get(i) &amp;&amp; (i == field</span>
<span class="nc bnc" id="L3332" title="All 2 branches missed.">                    || fmds[i].isInFetchGroup(lfg))) {</span>
<span class="nc bnc" id="L3333" title="All 2 branches missed.">                    if (fields == null)</span>
<span class="nc" id="L3334">                        fields = new BitSet(fmds.length);</span>
<span class="nc" id="L3335">                    fields.set(i);</span>
                }
            }

            // relation field is loaded with the load-fetch-group
            // but this addition must be reverted once the load is over
<span class="nc bnc" id="L3341" title="All 2 branches missed.">            if (!fetch.hasFetchGroup(lfg)) {</span>
<span class="nc" id="L3342">                fetch.addFetchGroup(lfg);</span>
<span class="nc" id="L3343">                lfgAdded = true;</span>
            }
<span class="nc bnc" id="L3345" title="All 6 branches missed.">        } else if (fetch.hasFetchGroup(FetchGroup.NAME_DEFAULT) &amp;&amp; fmd.isInDefaultFetchGroup() &amp;&amp; fields == null) {</span>
            // no load group but dfg: add dfg fields if we haven't already
<span class="nc bnc" id="L3347" title="All 2 branches missed.">            if (!unloadedDFGFieldMarked)</span>
<span class="nc" id="L3348">                fields = getUnloadedInternal(fetch, LOAD_FGS, null);</span>
<span class="nc bnc" id="L3349" title="All 2 branches missed.">        } else if (!_loaded.get(fmd.getIndex())) {</span>
            // no load group or dfg: load individual field
<span class="nc bnc" id="L3351" title="All 2 branches missed.">            if (fields == null)</span>
<span class="nc" id="L3352">                fields = new BitSet();</span>
<span class="nc" id="L3353">            fields.set(fmd.getIndex());</span>
        }

        // call this method even if there are no unloaded fields; loadFields
        // takes care of things like loading version info and setting PC flags
        try {
<span class="nc" id="L3359">            loadFields(fields, fetch, lockLevel, null);</span>
        } finally {
<span class="nc bnc" id="L3361" title="All 2 branches missed.">            if (lfgAdded)</span>
<span class="nc" id="L3362">                fetch.removeFetchGroup(lfg);</span>
        }
<span class="nc" id="L3364">    }</span>

    /**
     * Helper method to provide the given field number to the given
     * field manager.
     */
    void provideField(PersistenceCapable pc, FieldManager store, int field) {
<span class="nc bnc" id="L3371" title="All 2 branches missed.">        if (pc != null) {</span>
<span class="nc" id="L3372">            FieldManager beforeFM = _fm;</span>
<span class="nc" id="L3373">            _fm = store;</span>
<span class="nc" id="L3374">            pc.pcProvideField(field);</span>
            // Retaining original FM because of the possibility of reentrant calls
<span class="nc bnc" id="L3376" title="All 2 branches missed.">            if (beforeFM != null) _fm = beforeFM;</span>
        }
<span class="nc" id="L3378">    }</span>

    /**
     * Helper method to replace the given field number to the given
     * field manager.
     */
    void replaceField(PersistenceCapable pc, FieldManager load, int field) {
<span class="nc" id="L3385">        FieldManager beforeFM = _fm;</span>
<span class="nc" id="L3386">        _fm = load;</span>
<span class="nc" id="L3387">        pc.pcReplaceField(field);</span>
        // Retaining original FM because of the possibility of reentrant calls
<span class="nc bnc" id="L3389" title="All 2 branches missed.">        if (beforeFM != null) _fm = beforeFM;</span>
<span class="nc" id="L3390">    }</span>

    /**
     * Mark the field as loaded or unloaded.
     */
    private void setLoaded(int field, boolean isLoaded) {
        // don't continue if loaded state is already correct; otherwise we
        // can end up clearing _fieldImpl when we shouldn't
<span class="nc bnc" id="L3398" title="All 2 branches missed.">        if (_loaded.get(field) == isLoaded)</span>
<span class="nc" id="L3399">            return;</span>

        // if loading, clear intermediate data; if unloading, clear impl data
<span class="nc bnc" id="L3402" title="All 2 branches missed.">        if (_fieldImpl != null) {</span>
<span class="nc" id="L3403">            int idx = _meta.getExtraFieldDataIndex(field);</span>
<span class="nc bnc" id="L3404" title="All 2 branches missed.">            if (idx != -1)</span>
<span class="nc" id="L3405">                _fieldImpl[idx] = null;</span>
        }

<span class="nc bnc" id="L3408" title="All 2 branches missed.">        if (isLoaded)</span>
<span class="nc" id="L3409">            _loaded.set(field);</span>
        else
<span class="nc" id="L3411">            _loaded.clear(field);</span>
<span class="nc" id="L3412">    }</span>

    /**
     * Set to &lt;code&gt;false&lt;/code&gt; to prevent the postLoad method from
     * sending lifecycle callback events.
     */
    public void setPostLoadCallback(boolean enabled) {
<span class="nc" id="L3419">        this.postLoadCallback = enabled;</span>
<span class="nc" id="L3420">    }</span>

    /**
     * Perform post-load steps, including the post load callback.
     * We have to check the dfg after all field loads because it might be
     * loaded in multiple steps when paging is involved; the initial load
     * might exclude some fields which are then immediately loaded in a
     * separate step before being returned to the user.
     *
     * @param field the field index that was loaded, or -1 to indicate
     * that a group of possibly unknown fields was loaded
     */
    private void postLoad(int field, FetchConfiguration fetch) {
        // no need for postLoad callback?
<span class="nc bnc" id="L3434" title="All 2 branches missed.">        if ((_flags &amp; FLAG_LOADED) != 0)</span>
<span class="nc" id="L3435">            return;</span>

        // in the middle of a group load, after which this method will be
        // called again?
<span class="nc bnc" id="L3439" title="All 4 branches missed.">        if (field != -1 &amp;&amp; isLoading())</span>
<span class="nc" id="L3440">            return;</span>

        // no listeners?
<span class="nc" id="L3443">        LifecycleEventManager mgr = _broker.getLifecycleEventManager();</span>
<span class="nc bnc" id="L3444" title="All 6 branches missed.">        if (mgr == null || !mgr.isActive(_meta) || !mgr.hasLoadListeners(getManagedInstance(), _meta))</span>
<span class="nc" id="L3445">            return;</span>

<span class="nc bnc" id="L3447" title="All 2 branches missed.">        if (fetch == null)</span>
<span class="nc" id="L3448">            fetch = _broker.getFetchConfiguration();</span>
        // is this field a post-load field?
<span class="nc bnc" id="L3450" title="All 2 branches missed.">        if (field != -1) {</span>
<span class="nc" id="L3451">            FieldMetaData fmd = _meta.getField(field);</span>
<span class="nc bnc" id="L3452" title="All 2 branches missed.">            if (fmd.isInDefaultFetchGroup()</span>
<span class="nc bnc" id="L3453" title="All 2 branches missed.">                &amp;&amp; fetch.hasFetchGroup(FetchGroup.NAME_DEFAULT)</span>
<span class="nc bnc" id="L3454" title="All 2 branches missed.">                &amp;&amp; postLoad(FetchGroup.NAME_DEFAULT, fetch))</span>
<span class="nc" id="L3455">                return;</span>
<span class="nc" id="L3456">            String[] fgs = fmd.getCustomFetchGroups();</span>
<span class="nc bnc" id="L3457" title="All 2 branches missed.">            for (int i = 0; i &lt; fgs.length; i++)</span>
<span class="nc bnc" id="L3458" title="All 4 branches missed.">                if (fetch.hasFetchGroup(fgs[i]) &amp;&amp; postLoad(fgs[i], fetch))</span>
<span class="nc" id="L3459">                    return;</span>
<span class="nc" id="L3460">        } else {</span>
<span class="nc" id="L3461">            for (Iterator itr = fetch.getFetchGroups().iterator();</span>
<span class="nc bnc" id="L3462" title="All 2 branches missed.">                itr.hasNext();) {</span>
<span class="nc bnc" id="L3463" title="All 2 branches missed.">                if (postLoad((String) itr.next(), fetch))</span>
<span class="nc" id="L3464">                    return;</span>
            }
        }
<span class="nc" id="L3467">    }</span>

    /**
     * Perform post-load actions if the given fetch group is a post-load group
     * and is fully loaded.
     */
    private boolean postLoad(String fgName, FetchConfiguration fetch) {
<span class="nc" id="L3474">        FetchGroup fg = _meta.getFetchGroup(fgName);</span>
<span class="nc bnc" id="L3475" title="All 4 branches missed.">        if (fg == null || !fg.isPostLoad())</span>
<span class="nc" id="L3476">            return false;</span>

<span class="nc" id="L3478">        FieldMetaData[] fmds = _meta.getFields();</span>
<span class="nc bnc" id="L3479" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++)</span>
<span class="nc bnc" id="L3480" title="All 4 branches missed.">            if (!_loaded.get(i) &amp;&amp; fmds[i].isInFetchGroup(fgName))</span>
<span class="nc" id="L3481">                return false;</span>

<span class="nc" id="L3483">        _flags |= FLAG_LOADED;</span>
<span class="nc bnc" id="L3484" title="All 2 branches missed.">        if (postLoadCallback)</span>
<span class="nc" id="L3485">            _broker.fireLifecycleEvent(getManagedInstance(), fetch, _meta, LifecycleEvent.AFTER_LOAD);</span>
<span class="nc" id="L3486">        return true;</span>
    }

    /**
     * Synchronize our version object with the datastore.
     */
    private boolean syncVersion(Object sdata) {
<span class="nc" id="L3493">        return _broker.getStoreManager().syncVersion(this, sdata);</span>
    }

    /**
     * Returns whether this instance needs a version check.
     */
    @Override
    public boolean isVersionCheckRequired() {
        // explicit flag for version check
<span class="nc bnc" id="L3502" title="All 2 branches missed.">        if ((_flags &amp; FLAG_VERSION_CHECK) != 0)</span>
<span class="nc" id="L3503">            return true;</span>

<span class="nc bnc" id="L3505" title="All 2 branches missed.">        if (!_broker.getOptimistic() &amp;&amp; !_broker.getConfiguration().</span>
<span class="nc bnc" id="L3506" title="All 2 branches missed.">            getCompatibilityInstance().getNonOptimisticVersionCheck())</span>
<span class="nc" id="L3507">            return false;</span>
<span class="nc" id="L3508">        return _state.isVersionCheckRequired(this);</span>
    }

    /**
     * Set whether this instance requires a version check on the next flush.
     */
    void setCheckVersion(boolean versionCheck) {
<span class="nc bnc" id="L3515" title="All 2 branches missed.">        if (versionCheck)</span>
<span class="nc" id="L3516">            _flags |= FLAG_VERSION_CHECK;</span>
        else
<span class="nc" id="L3518">            _flags &amp;= ~FLAG_VERSION_CHECK;</span>
<span class="nc" id="L3519">    }</span>

    /**
     * Returns whether this instance needs a version update.
     */
    @Override
    public boolean isVersionUpdateRequired() {
<span class="nc bnc" id="L3526" title="All 2 branches missed.">        return (_flags &amp; FLAG_VERSION_UPDATE) &gt; 0;</span>
    }

    /**
     * Set whether this instance requires a version update on the next flush.
     */
    void setUpdateVersion(boolean versionUpdate) {
<span class="nc bnc" id="L3533" title="All 2 branches missed.">        if (versionUpdate)</span>
<span class="nc" id="L3534">            _flags |= FLAG_VERSION_UPDATE;</span>
        else
<span class="nc" id="L3536">            _flags &amp;= ~FLAG_VERSION_UPDATE;</span>
<span class="nc" id="L3537">    }</span>

    /**
     * Translate the given exception based on the broker's implicit behavior.
     * Translation only occurs if the exception is initiated by a user action
     * on an instance, and therefore will not be caught and translated by the
     * broker.
     */
    protected RuntimeException translate(RuntimeException re) {
<span class="nc" id="L3546">        RuntimeExceptionTranslator trans = _broker.getInstanceExceptionTranslator();</span>
<span class="nc bnc" id="L3547" title="All 2 branches missed.">        return (trans == null) ? re : trans.translate(re);</span>
    }

    /**
     * Lock the state manager if the multithreaded option is set.
     */
    protected void lock() {
<span class="nc bnc" id="L3554" title="All 2 branches missed.">        if (_instanceLock != null)</span>
<span class="nc" id="L3555">        	_instanceLock.lock();</span>
<span class="nc" id="L3556">    }</span>

    /**
     * Unlock the state manager.
     */
	protected void unlock () {
<span class="nc bnc" id="L3562" title="All 2 branches missed.">        if (_instanceLock != null)</span>
<span class="nc" id="L3563">        	_instanceLock.unlock();</span>
<span class="nc" id="L3564">	}</span>

    private void writeObject(ObjectOutputStream oos) throws IOException {
<span class="nc" id="L3567">        oos.writeObject(_broker);</span>
<span class="nc" id="L3568">        oos.defaultWriteObject();</span>
<span class="nc" id="L3569">        oos.writeObject(_meta.getDescribedType());</span>
<span class="nc" id="L3570">        writePC(oos, _pc);</span>
<span class="nc" id="L3571">    }</span>

    /**
     * Write &lt;code&gt;pc&lt;/code&gt; to &lt;code&gt;oos&lt;/code&gt;, handling internal-form
     * serialization. &lt;code&gt;pc&lt;/code&gt; must be of the same type that this
     * state manager manages.
     *
     * @since 1.1.0
     */
    void writePC(ObjectOutputStream oos, PersistenceCapable pc)
        throws IOException {
<span class="nc bnc" id="L3582" title="All 2 branches missed.">        if (!Serializable.class.isAssignableFrom(_meta.getDescribedType()))</span>
<span class="nc" id="L3583">            throw new NotSerializableException(_meta.getDescribedType().getName());</span>

<span class="nc" id="L3585">        oos.writeObject(pc);</span>
<span class="nc" id="L3586">    }</span>

    private void readObject(ObjectInputStream in)
        throws IOException, ClassNotFoundException {
<span class="nc" id="L3590">        _broker = (BrokerImpl) in.readObject();</span>
<span class="nc" id="L3591">        in.defaultReadObject();</span>

        // we need to store the class before the pc instance so that we can
        // create _meta before calling readPC(), which relies on _meta being
        // non-null when reconstituting ReflectingPC instances. Sadly, this
        // penalizes the serialization footprint of non-ReflectingPC SMs also.
<span class="nc" id="L3597">        Class managedType = (Class) in.readObject();</span>
<span class="nc" id="L3598">        _meta = _broker.getConfiguration().getMetaDataRepositoryInstance()</span>
<span class="nc" id="L3599">            .getMetaData(managedType, null, true);</span>

<span class="nc" id="L3601">        _pc = readPC(in);</span>
<span class="nc" id="L3602">    }</span>

    /**
     * Converts the deserialized &lt;code&gt;o&lt;/code&gt; to a {@link PersistenceCapable}
     * instance appropriate for storing in &lt;code&gt;_pc&lt;/code&gt;.
     *
     * @since 1.1.0
     */
    PersistenceCapable readPC(ObjectInputStream in)
        throws ClassNotFoundException, IOException {
<span class="nc" id="L3612">        Object o = in.readObject();</span>

<span class="nc bnc" id="L3614" title="All 2 branches missed.">        if (o == null)</span>
<span class="nc" id="L3615">            return null;</span>

        PersistenceCapable pc;
<span class="nc bnc" id="L3618" title="All 2 branches missed.">        if (!(o instanceof PersistenceCapable))</span>
<span class="nc" id="L3619">            pc = ImplHelper.toPersistenceCapable(o, this);</span>
        else
<span class="nc" id="L3621">            pc = (PersistenceCapable) o;</span>

<span class="nc" id="L3623">        pc.pcReplaceStateManager(this);</span>
<span class="nc" id="L3624">        return pc;</span>
    }

    public List&lt;FieldMetaData&gt; getMappedByIdFields() {
<span class="nc" id="L3628">        return _mappedByIdFields;</span>
    }

    public boolean requiresFetch(FieldMetaData fmd) {
<span class="nc bnc" id="L3632" title="All 2 branches missed.">        return (_broker.getFetchConfiguration().requiresFetch(fmd) != FetchConfiguration.FETCH_NONE);</span>
    }

    public void setPc(PersistenceCapable pc) {
<span class="nc" id="L3636">        _pc = pc;</span>
<span class="nc" id="L3637">    }</span>

    public void setBroker(BrokerImpl ctx) {
<span class="nc" id="L3640">        _broker = ctx;</span>
<span class="nc" id="L3641">    }</span>

    @Override
    public BitSet getFlushed() {
<span class="nc bnc" id="L3645" title="All 2 branches missed.">        if (_flush == null) {</span>
<span class="nc" id="L3646">            _flush = new BitSet(_meta.getFields().length);</span>
        }
<span class="nc" id="L3648">        return _flush;</span>
    }

    private boolean isFieldFlushed(int index) {
<span class="nc bnc" id="L3652" title="All 2 branches missed.">        if (_flush == null) {</span>
<span class="nc" id="L3653">            return false;</span>
        }
<span class="nc" id="L3655">        return _flush.get(index);</span>
    }

    /**
     * Will clear the bit at the specified if the _flush BetSet has been created.
     */
    private void clearFlushField(int index) {
<span class="nc bnc" id="L3662" title="All 2 branches missed.">        if (_flush != null) {</span>
<span class="nc" id="L3663">            getFlushed().clear(index);</span>
        }
<span class="nc" id="L3665">    }</span>

    @Override
    public BitSet getDirty() {
<span class="nc bnc" id="L3669" title="All 2 branches missed.">        if (_dirty == null) {</span>
<span class="nc" id="L3670">            _dirty = new BitSet(_meta.getFields().length);</span>
        }
<span class="nc" id="L3672">        return _dirty;</span>
    }

    private boolean isFieldDirty(int index) {
<span class="nc bnc" id="L3676" title="All 2 branches missed.">        if (_dirty == null) {</span>
<span class="nc" id="L3677">            return false;</span>
        }
<span class="nc" id="L3679">        return _dirty.get(index);</span>
    }

    private void setFieldDirty(int index) {
<span class="nc" id="L3683">        getDirty().set(index);</span>
<span class="nc" id="L3684">    }</span>

    /**
     * Will clear the bit at the specified index if the _dirty BetSet has been created.
     */
    private void clearDirty(int index) {
<span class="nc bnc" id="L3690" title="All 2 branches missed.">        if (_dirty != null) {</span>
<span class="nc" id="L3691">            getDirty().clear(index);</span>
        }
<span class="nc" id="L3693">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L3697">    	return &quot;SM[&quot; + _meta.getDescribedType().getSimpleName() + &quot;]:&quot; + getObjectId();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>