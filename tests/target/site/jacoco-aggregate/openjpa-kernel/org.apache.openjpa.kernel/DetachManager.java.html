<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DetachManager.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-kernel</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.kernel</a> &gt; <span class="el_source">DetachManager.java</span></div><h1>DetachManager.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.kernel;

import java.io.IOException;
import java.io.ObjectOutput;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.openjpa.conf.Compatibility;
import org.apache.openjpa.conf.DetachOptions;
import org.apache.openjpa.enhance.PersistenceCapable;
import org.apache.openjpa.event.CallbackModes;
import org.apache.openjpa.event.LifecycleEvent;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.meta.ClassMetaData;
import org.apache.openjpa.meta.FieldMetaData;
import org.apache.openjpa.meta.JavaTypes;
import org.apache.openjpa.meta.ValueMetaData;
import org.apache.openjpa.util.CallbackException;
import org.apache.openjpa.util.ObjectNotFoundException;
import org.apache.openjpa.util.Proxy;
import org.apache.openjpa.util.ProxyManager;
import org.apache.openjpa.util.UserException;

/**
 * Handles detaching instances.
 *
 * @author Marc Prud'hommeaux
 */
public class DetachManager
    implements DetachState {

<span class="nc" id="L61">    private static Localizer _loc = Localizer.forPackage(DetachManager.class);</span>

    private final BrokerImpl _broker;
    private final boolean _copy;
    private final boolean _full;
    private final ProxyManager _proxy;
    private final DetachOptions _opts;
    private final OpCallbacks _call;
    private final boolean _failFast;
<span class="nc" id="L70">    private boolean _flushed = false;</span>
    private boolean _flushBeforeDetach;
    private boolean _cascadeWithDetach;
    private boolean _reloadOnDetach;

    // if we're not detaching full, we need to track all detached objects;
    // if we are, then we use a special field manager for more efficient
    // detachment than the standard one
    private final IdentityHashMap _detached;
    private final DetachFieldManager _fullFM;

    /**
     * Used to prepare a detachable instance that does not externalize
     * detached state.
     */
    static boolean preSerialize(StateManagerImpl sm) {
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if (!sm.isPersistent())</span>
<span class="nc" id="L87">            return false;</span>

<span class="nc" id="L89">        if (sm.getBroker().getConfiguration().getCompatibilityInstance()</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">                .getFlushBeforeDetach()) {</span>
<span class="nc" id="L91">            flushDirty(sm);</span>
        }

<span class="nc" id="L94">        ClassMetaData meta = sm.getMetaData();</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        boolean setState = meta.getDetachedState() != null</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">            &amp;&amp; !ClassMetaData.SYNTHETIC.equals(meta.getDetachedState());</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">        BitSet idxs = (setState) ? new BitSet(meta.getFields().length) : null;</span>
<span class="nc" id="L98">        preDetach(sm.getBroker(), sm, idxs, false, true);</span>

<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (setState) {</span>
<span class="nc" id="L101">            sm.getPersistenceCapable().pcSetDetachedState(getDetachedState</span>
<span class="nc" id="L102">                (sm, idxs));</span>
<span class="nc" id="L103">            return false; // don't null state</span>
        }
<span class="nc" id="L105">        return true;</span>
    }

    /**
     * Used by classes that externalize detached state.
     *
     * @return whether to use a detached state manager
     */
    static boolean writeDetachedState(StateManagerImpl sm, ObjectOutput out,
        BitSet idxs)
        throws IOException {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (!sm.isPersistent()) {</span>
<span class="nc" id="L117">            out.writeObject(null); // state</span>
<span class="nc" id="L118">            out.writeObject(null); // sm</span>
<span class="nc" id="L119">            return false;</span>
        }

        // dirty state causes flush
<span class="nc" id="L123">        flushDirty(sm);</span>

<span class="nc" id="L125">        Broker broker = sm.getBroker();</span>
<span class="nc" id="L126">        preDetach(broker, sm, idxs, false, true);</span>

        // write detached state object and state manager
<span class="nc" id="L129">        DetachOptions opts = broker.getConfiguration().</span>
<span class="nc" id="L130">            getDetachStateInstance();</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (!opts.getDetachedStateManager()</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">            || !useDetachedStateManager(sm, opts)) {</span>
<span class="nc" id="L133">            out.writeObject(getDetachedState(sm, idxs));</span>
<span class="nc" id="L134">            out.writeObject(null);</span>
<span class="nc" id="L135">            return false;</span>
        }
<span class="nc" id="L137">        out.writeObject(null);</span>
<span class="nc" id="L138">        out.writeObject(new DetachedStateManager(sm.getPersistenceCapable(),</span>
<span class="nc" id="L139">            sm, idxs, opts.getAccessUnloaded(), broker.getMultithreaded()));</span>
<span class="nc" id="L140">        return true;</span>
    }

    /**
     * Ready the object for detachment, including loading the fields to be
     * detached and updating version information.
     *
     * @param idxs the indexes of fields to detach will be set as a side
     * effect of this method
     */
    private static void preDetach(Broker broker, StateManagerImpl sm,
        BitSet idxs, boolean full,
        boolean reloadOnDetach) {
        // make sure the existing object has the right fields fetched; call
        // even if using currently-loaded fields for detach to make sure
        // version is set
<span class="nc" id="L156">        int detachMode = broker.getDetachState();</span>
<span class="nc" id="L157">        int loadMode = StateManagerImpl.LOAD_FGS;</span>
<span class="nc" id="L158">        BitSet exclude = null;</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (detachMode == DETACH_LOADED)</span>
<span class="nc" id="L160">            exclude = StoreContext.EXCLUDE_ALL;</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        else if (detachMode == DETACH_ALL)</span>
<span class="nc" id="L162">            loadMode = StateManagerImpl.LOAD_ALL;</span>
        try {
<span class="nc bnc" id="L164" title="All 8 branches missed.">            if (detachMode != DETACH_LOADED ||</span>
                    reloadOnDetach ||
                    (!reloadOnDetach &amp;&amp; !full)) {
<span class="nc" id="L167">                sm.load(broker.getFetchConfiguration(), loadMode, exclude,</span>
                    null, false);
            }
<span class="nc" id="L170">        } catch (ObjectNotFoundException onfe) {</span>
            // consume the exception
<span class="nc" id="L172">        }</span>

        // create bitset of fields to detach; if mode is all we can use
        // currently loaded bitset clone, since we know all fields are loaded
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (idxs != null) {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (detachMode == DETACH_FETCH_GROUPS)</span>
<span class="nc" id="L178">                setFetchGroupFields(broker, sm, idxs);</span>
            else
<span class="nc" id="L180">                idxs.or(sm.getLoaded());</span>

            // clear lrs fields
<span class="nc" id="L183">            FieldMetaData[] fmds = sm.getMetaData().getFields();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            for (int i = 0; i &lt; fmds.length; i++)</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                if (fmds[i].isLRS())</span>
<span class="nc" id="L186">                    idxs.clear(i);</span>
        }
<span class="nc" id="L188">    }</span>

    /**
     * Generate the detached state for the given instance.
     */
    private static Object getDetachedState(StateManagerImpl sm, BitSet fields) {
        // if datastore, store id in first element
<span class="nc bnc" id="L195" title="All 2 branches missed.">        int offset = (sm.getMetaData().getIdentityType() ==</span>
<span class="nc" id="L196">            ClassMetaData.ID_DATASTORE) ? 1 : 0;</span>

        // make version state array one larger for new instances; marks new
        // instances without affecting serialization size much
        Object[] state;
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (sm.isNew())</span>
<span class="nc" id="L202">            state = new Object[3 + offset];</span>
        else
<span class="nc" id="L204">            state = new Object[2 + offset];</span>

<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (offset &gt; 0) {</span>
            Object id;
<span class="nc bnc" id="L208" title="All 4 branches missed.">            if (sm.isEmbedded() || sm.getObjectId() == null)</span>
<span class="nc" id="L209">                id = sm.getId();</span>
            else
<span class="nc" id="L211">                id = sm.getObjectId();</span>
<span class="nc" id="L212">            state[0] = id.toString();</span>
        }
<span class="nc" id="L214">        state[offset] = sm.getVersion();</span>
<span class="nc" id="L215">        state[offset + 1] = fields;</span>
<span class="nc" id="L216">        return state;</span>
    }

    /**
     * Flush or invoke pre-store callbacks on the given broker if
     * needed. Return true if flushed/stored, false otherwise.
     */
    private static boolean flushDirty(StateManagerImpl sm) {
<span class="nc bnc" id="L224" title="All 4 branches missed.">        if (!sm.isDirty() || !sm.getBroker().isActive())</span>
<span class="nc" id="L225">            return false;</span>

        // only flush if there are actually any dirty non-flushed fields
<span class="nc" id="L228">        BitSet dirtyFields = sm.getDirty();</span>
<span class="nc" id="L229">        BitSet flushedFields = sm.getFlushed();</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">        for (int i = 0; i &lt; dirtyFields.size(); i++) {</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">            if (dirtyFields.get(i) &amp;&amp; !flushedFields.get(i)) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                if (sm.getBroker().getRollbackOnly())</span>
<span class="nc" id="L233">                    sm.getBroker().preFlush();</span>
                else
<span class="nc" id="L235">                    sm.getBroker().flush();</span>
<span class="nc" id="L236">                return true;</span>
            }
        }
<span class="nc" id="L239">        return false;</span>
    }

    /**
     * Create a bit set for the fields in the current fetch groups.
     */
    private static void setFetchGroupFields(Broker broker,
        StateManagerImpl sm, BitSet idxs) {
<span class="nc" id="L247">        FetchConfiguration fetch = broker.getFetchConfiguration();</span>
<span class="nc" id="L248">        FieldMetaData[] fmds = sm.getMetaData().getFields();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        for (int i = 0; i &lt; fmds.length; i++) {</span>
<span class="nc bnc" id="L250" title="All 4 branches missed.">            if (fmds[i].isPrimaryKey() || fetch.requiresFetch(fmds[i])</span>
                != FetchConfiguration.FETCH_NONE)
<span class="nc" id="L252">                idxs.set(i);</span>
        }
<span class="nc" id="L254">    }</span>


    /**
     * Constructor.
     *
     * @param broker owning broker
     * @param full whether the entire broker cache is being detached; if
     * this is the case, we assume the broker has already
     * flushed if needed, and that we're detaching in-place
     */
<span class="nc" id="L265">    public DetachManager(BrokerImpl broker, boolean full, OpCallbacks call) {</span>
<span class="nc" id="L266">        _broker = broker;</span>
<span class="nc" id="L267">        _proxy = broker.getConfiguration().getProxyManagerInstance();</span>
<span class="nc" id="L268">        _opts = broker.getConfiguration().getDetachStateInstance();</span>
<span class="nc" id="L269">        _flushed = full;</span>
<span class="nc" id="L270">        _call = call;</span>
<span class="nc" id="L271">        _failFast = (broker.getConfiguration().getMetaDataRepositoryInstance().</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            getMetaDataFactory().getDefaults().getCallbackMode()</span>
            &amp; CallbackModes.CALLBACK_FAIL_FAST) != 0;

        // we can only rely on our &quot;full&quot; shortcuts if we know we won't be
        // loading any more data
<span class="nc bnc" id="L277" title="All 4 branches missed.">        _full = full &amp;&amp; broker.getDetachState() == DetachState.DETACH_LOADED;</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (_full) {</span>
<span class="nc" id="L279">            _detached = null;</span>
<span class="nc" id="L280">            _fullFM = new DetachFieldManager();</span>
        } else {
<span class="nc" id="L282">            _detached = new IdentityHashMap();</span>
<span class="nc" id="L283">            _fullFM = null;</span>
        }
<span class="nc" id="L285">        Compatibility compatibility =</span>
<span class="nc" id="L286">            broker.getConfiguration().getCompatibilityInstance();</span>
<span class="nc" id="L287">        _flushBeforeDetach = compatibility.getFlushBeforeDetach();</span>
<span class="nc" id="L288">        _reloadOnDetach = compatibility.getReloadOnDetach();</span>
<span class="nc" id="L289">        _cascadeWithDetach = compatibility.getCascadeWithDetach();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (full) {</span>
<span class="nc" id="L291">            _copy = false;</span>
        }
        else {
<span class="nc" id="L294">            _copy = compatibility.getCopyOnDetach();;</span>
        }
<span class="nc" id="L296">    }</span>

    /**
     * Return a detached version of the given instance.
     */
    public Object detach(Object toDetach) {
<span class="nc" id="L302">        List exceps = null;</span>
        try {
<span class="nc" id="L304">            return detachInternal(toDetach);</span>
<span class="nc" id="L305">        } catch (CallbackException ce) {</span>
<span class="nc" id="L306">            exceps = new ArrayList(1);</span>
<span class="nc" id="L307">            exceps.add(ce);</span>
<span class="nc" id="L308">            return null; // won't be reached as exception will be rethrown</span>
        } finally {
<span class="nc bnc" id="L310" title="All 4 branches missed.">            if (exceps == null || !_failFast)</span>
<span class="nc" id="L311">                exceps = invokeAfterDetach(Collections.singleton(toDetach),</span>
                    exceps);
<span class="nc bnc" id="L313" title="All 2 branches missed.">            if (_detached != null)</span>
<span class="nc" id="L314">                _detached.clear();</span>
<span class="nc" id="L315">            throwExceptions(exceps);</span>
        }
    }

    /**
     * Return detached versions of all the given instances. If not copying,
     * null will be returned.
     */
    public Object[] detachAll(Collection instances) {
<span class="nc" id="L324">        List exceps = null;</span>
<span class="nc" id="L325">        List detached = null;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (_copy)</span>
<span class="nc" id="L327">            detached = new ArrayList(instances.size());</span>

<span class="nc" id="L329">        boolean failFast = false;</span>
        try {
            Object detach;
<span class="nc bnc" id="L332" title="All 2 branches missed.">            for (Iterator itr = instances.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L333">                detach = detachInternal(itr.next());</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                if (_copy)</span>
<span class="nc" id="L335">                    detached.add(detach);</span>
            }
        }
<span class="nc" id="L338">        catch (RuntimeException re) {</span>
<span class="nc bnc" id="L339" title="All 4 branches missed.">            if (re instanceof CallbackException &amp;&amp; _failFast)</span>
<span class="nc" id="L340">                failFast = true;</span>
<span class="nc" id="L341">            exceps = add(exceps, re);</span>
        } finally {
<span class="nc bnc" id="L343" title="All 2 branches missed.">            if (!failFast)</span>
<span class="nc" id="L344">                exceps = invokeAfterDetach(instances, exceps);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            if (_detached != null)</span>
<span class="nc" id="L346">                _detached.clear();</span>
        }
<span class="nc" id="L348">        throwExceptions(exceps);</span>

<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (_copy)</span>
<span class="nc" id="L351">            return detached.toArray();</span>
<span class="nc" id="L352">        return null;</span>
    }

    /**
     * Invoke postDetach() on any detached instances that implement
     * PostDetachCallback. This will be done after the entire graph has
     * been detached. This method has the side-effect of also clearing
     * out the map of all detached instances.
     */
    private List invokeAfterDetach(Collection objs, List exceps) {
<span class="nc bnc" id="L362" title="All 2 branches missed.">        Iterator itr = (_full) ? objs.iterator()</span>
<span class="nc" id="L363">            : _detached.entrySet().iterator();</span>

        Object orig, detached;
        Map.Entry entry;
<span class="nc bnc" id="L367" title="All 2 branches missed.">        while (itr.hasNext()) {</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            if (_full) {</span>
<span class="nc" id="L369">                orig = itr.next();</span>
<span class="nc" id="L370">                detached = orig;</span>
            } else {
<span class="nc" id="L372">                entry = (Map.Entry) itr.next();</span>
<span class="nc" id="L373">                orig = entry.getKey();</span>
<span class="nc" id="L374">                detached = entry.getValue();</span>
            }

<span class="nc" id="L377">            StateManagerImpl sm = _broker.getStateManagerImpl(orig, true);</span>
            try {
<span class="nc bnc" id="L379" title="All 2 branches missed.">                if (sm != null)</span>
<span class="nc" id="L380">                    _broker.fireLifecycleEvent(detached, orig,</span>
<span class="nc" id="L381">                        sm.getMetaData(), LifecycleEvent.AFTER_DETACH);</span>
<span class="nc" id="L382">            } catch (CallbackException ce) {</span>
<span class="nc" id="L383">                exceps = add(exceps, ce);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">                if (_failFast)</span>
<span class="nc" id="L385">                    break; // don't continue processing</span>
<span class="nc" id="L386">            }</span>
<span class="nc" id="L387">        }</span>
<span class="nc" id="L388">        return exceps;</span>
    }

    /**
     * Add an exception to the list.
     */
    private List add(List exceps, RuntimeException re) {
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (exceps == null)</span>
<span class="nc" id="L396">            exceps = new LinkedList();</span>
<span class="nc" id="L397">        exceps.add(re);</span>
<span class="nc" id="L398">        return exceps;</span>
    }

    /**
     * Throw all gathered exceptions.
     */
    private void throwExceptions(List exceps) {
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (exceps == null)</span>
<span class="nc" id="L406">            return;</span>

<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (exceps.size() == 1)</span>
<span class="nc" id="L409">            throw (RuntimeException) exceps.get(0);</span>
<span class="nc" id="L410">        throw new UserException(_loc.get(&quot;nested-exceps&quot;)).</span>
<span class="nc" id="L411">            setNestedThrowables((Throwable[]) exceps.toArray</span>
<span class="nc" id="L412">                (new Throwable[exceps.size()]));</span>
    }

    /**
     * Detach.
     */
    private Object detachInternal(Object toDetach) {
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (toDetach == null)</span>
<span class="nc" id="L420">            return null;</span>

        // already detached?
<span class="nc bnc" id="L423" title="All 2 branches missed.">        if (_detached != null) {</span>
<span class="nc" id="L424">            Object detached = _detached.get(toDetach);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (detached != null)</span>
<span class="nc" id="L426">                return detached;</span>
        }

<span class="nc" id="L429">        StateManagerImpl sm = _broker.getStateManagerImpl(toDetach, true);</span>
<span class="nc bnc" id="L430" title="All 4 branches missed.">        if (_call != null &amp;&amp; (_call.processArgument(OpCallbacks.OP_DETACH,</span>
            toDetach, sm) &amp; OpCallbacks.ACT_RUN) == 0)
<span class="nc" id="L432">            return toDetach;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (sm == null)</span>
<span class="nc" id="L434">            return toDetach;</span>

        // Call PreDetach first as we can't tell if the new system
        // fired an event or just did not fail.
<span class="nc" id="L438">        _broker.fireLifecycleEvent(toDetach, null, sm.getMetaData(),</span>
            LifecycleEvent.BEFORE_DETACH);

<span class="nc bnc" id="L441" title="All 2 branches missed.">        if(! _flushed)  {</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">            if(_flushBeforeDetach) {</span>
                // any dirty instances cause a flush to occur
<span class="nc" id="L444">                flushDirty(sm);</span>
            }
<span class="nc" id="L446">            _flushed = true;</span>
        }

<span class="nc" id="L449">        BitSet fields = new BitSet();</span>
<span class="nc" id="L450">        preDetach(_broker, sm, fields, _full,</span>
            _reloadOnDetach);

        // create and store new object before copy to avoid endless recursion
<span class="nc" id="L454">        PersistenceCapable pc = sm.getPersistenceCapable();</span>
        PersistenceCapable detachedPC;
<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (_copy)</span>
<span class="nc" id="L457">            detachedPC = pc.pcNewInstance(null, true);</span>
        else
<span class="nc" id="L459">            detachedPC = pc;</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">        if (_detached != null)</span>
<span class="nc" id="L461">            _detached.put(toDetach, detachedPC);</span>

        // detach fields and set detached variables
<span class="nc" id="L464">        DetachedStateManager detSM = null;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (_opts.getDetachedStateManager()</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            &amp;&amp; useDetachedStateManager(sm, _opts)</span>
<span class="nc bnc" id="L467" title="All 6 branches missed.">            &amp;&amp; !(sm.isNew() &amp;&amp; !sm.isDeleted() &amp;&amp; !sm.isFlushed()))</span>
<span class="nc" id="L468">            detSM = new DetachedStateManager(detachedPC, sm, fields,</span>
<span class="nc" id="L469">                _opts.getAccessUnloaded(), _broker.getMultithreaded());</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (_full) {</span>
<span class="nc" id="L471">            _fullFM.setStateManager(sm);</span>
<span class="nc bnc" id="L472" title="All 4 branches missed.">            if (_copy || _reloadOnDetach) {</span>
<span class="nc" id="L473">                _fullFM.detachVersion();</span>
            }
<span class="nc" id="L475">            _fullFM.reproxy(detSM);</span>
<span class="nc" id="L476">            _fullFM.setStateManager(null);</span>
        } else {
<span class="nc" id="L478">            InstanceDetachFieldManager fm = new InstanceDetachFieldManager(detachedPC, detSM);</span>
<span class="nc" id="L479">            fm.setStateManager(sm);</span>
<span class="nc" id="L480">            fm.detachFields(fields);</span>
        }

<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (!Boolean.FALSE.equals(sm.getMetaData().usesDetachedState()))</span>
<span class="nc" id="L484">            detachedPC.pcSetDetachedState(getDetachedState(sm, fields));</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">        if (!_copy)</span>
<span class="nc" id="L486">            sm.release(false, true);</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (detSM != null)</span>
<span class="nc" id="L488">            detachedPC.pcReplaceStateManager(detSM);</span>
<span class="nc" id="L489">        return detachedPC;</span>
    }

    private static boolean useDetachedStateManager(StateManagerImpl sm,
        DetachOptions opts) {
<span class="nc" id="L494">        ClassMetaData meta = sm.getMetaData();</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">        return !Boolean.FALSE.equals(meta.usesDetachedState()) &amp;&amp;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">            ClassMetaData.SYNTHETIC.equals(meta.getDetachedState()) &amp;&amp;</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">            opts.getDetachedStateManager();</span>
    }

    /**
     * Base detach field manager.
     */
    private static class DetachFieldManager
        extends TransferFieldManager {

        protected StateManagerImpl sm;

        /**
         * Set the source state manager.
         */
        public void setStateManager(StateManagerImpl sm) {
<span class="nc" id="L512">            this.sm = sm;</span>
<span class="nc" id="L513">        }</span>

        /**
         * Transfer the current version object from the state manager to the
         * detached instance.
         */
        public void detachVersion() {
<span class="nc" id="L520">            FieldMetaData fmd = sm.getMetaData().getVersionField();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">            if (fmd == null)</span>
<span class="nc" id="L522">                return;</span>

<span class="nc" id="L524">            Object val = JavaTypes.convert(sm.getVersion(),</span>
<span class="nc" id="L525">                fmd.getTypeCode());</span>
<span class="nc" id="L526">            val = fmd.getFieldValue(val, sm.getBroker());</span>
<span class="nc bnc" id="L527" title="All 3 branches missed.">            switch (fmd.getDeclaredTypeCode()) {</span>
            case JavaTypes.LONG:
            case JavaTypes.SHORT:
            case JavaTypes.INT:
            case JavaTypes.BYTE:
<span class="nc bnc" id="L532" title="All 2 branches missed.">                longval = (val == null) ? 0L : ((Number) val).longValue();</span>
<span class="nc" id="L533">                break;</span>
            case JavaTypes.DOUBLE:
            case JavaTypes.FLOAT:
<span class="nc bnc" id="L536" title="All 2 branches missed.">                dblval = (val == null) ? 0D : ((Number) val).doubleValue();</span>
<span class="nc" id="L537">                break;</span>
            default:
<span class="nc" id="L539">                objval = val;</span>
            }
<span class="nc" id="L541">            sm.replaceField(getDetachedPersistenceCapable(), this,</span>
<span class="nc" id="L542">                fmd.getIndex());</span>
<span class="nc" id="L543">        }</span>

        /**
         * Unproxies second class object fields.
         */
        public void reproxy(DetachedStateManager dsm) {
<span class="nc bnc" id="L549" title="All 2 branches missed.">            for (FieldMetaData fmd : sm.getMetaData().getProxyFields()) {</span>
<span class="nc bnc" id="L550" title="All 3 branches missed.">                switch (fmd.getDeclaredTypeCode()) {</span>
                case JavaTypes.COLLECTION:
                case JavaTypes.MAP:
                    // lrs proxies not detached
<span class="nc bnc" id="L554" title="All 2 branches missed.">                    if (fmd.isLRS()) {</span>
<span class="nc" id="L555">                        objval = null;</span>
<span class="nc" id="L556">                        sm.replaceField(getDetachedPersistenceCapable(), this, fmd.getIndex());</span>
<span class="nc" id="L557">                        break;</span>
                    }
                    // no break
                case JavaTypes.CALENDAR:
                case JavaTypes.DATE:
                case JavaTypes.OBJECT:
<span class="nc" id="L563">                    sm.provideField(getDetachedPersistenceCapable(), this, fmd.getIndex());</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                    if (objval instanceof Proxy) {</span>
<span class="nc" id="L565">                        Proxy proxy = (Proxy) objval;</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">                        if (proxy.getChangeTracker() != null)</span>
<span class="nc" id="L567">                            proxy.getChangeTracker().stopTracking();</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">                        proxy.setOwner(dsm, (dsm == null) ? -1 : fmd.getIndex());</span>
                    }
                }
            }
<span class="nc" id="L572">            clear();</span>
<span class="nc" id="L573">        }</span>

        /**
         * Return the instance being detached.
         */
        protected PersistenceCapable getDetachedPersistenceCapable() {
<span class="nc" id="L579">            return sm.getPersistenceCapable();</span>
        }
    }

    /**
     * FieldManager that can copy all the fields from one
     * PersistenceCapable instance to another. One of the
     * instances must be managed by a StateManager, and the
     * other must be unmanaged.
     *
     * @author Marc Prud'hommeaux
     */
    private class InstanceDetachFieldManager
        extends DetachFieldManager {

        private final PersistenceCapable _to;
        private final DetachedStateManager _detSM;

        /**
         * Constructor. Supply instance to to copy to.
         */
        public InstanceDetachFieldManager(PersistenceCapable to,
<span class="nc" id="L601">            DetachedStateManager detSM) {</span>
<span class="nc" id="L602">            _to = to;</span>
<span class="nc" id="L603">            _detSM = detSM;</span>
<span class="nc" id="L604">        }</span>

        @Override
        protected PersistenceCapable getDetachedPersistenceCapable() {
<span class="nc" id="L608">            return _to;</span>
        }

        /**
         * Detach the fields of the state manager given on construction to
         * the persistence capable given on construction.
         * Only the fields in the given bit set will be copied.
         */
        public void detachFields(BitSet fgfields) {
<span class="nc" id="L617">            PersistenceCapable from = sm.getPersistenceCapable();</span>
<span class="nc" id="L618">            FieldMetaData[] pks = sm.getMetaData().getPrimaryKeyFields();</span>
<span class="nc" id="L619">            FieldMetaData[] fmds = sm.getMetaData().getFields();</span>

<span class="nc bnc" id="L621" title="All 2 branches missed.">            if (_copy)</span>
<span class="nc" id="L622">                _to.pcReplaceStateManager(sm);</span>
            try {
                // we start with pk fields: objects might rely on pk fields for
                // equals and hashCode methods, and this ensures that pk fields
                // are set properly if we return any partially-detached objects
                // due to reentrant calls when traversing relations
<span class="nc bnc" id="L628" title="All 2 branches missed.">                for (int i = 0; i &lt; pks.length; i++)</span>
<span class="nc" id="L629">                    detachField(from, pks[i].getIndex(), true);</span>
<span class="nc" id="L630">                detachVersion();</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                for (int i = 0; i &lt; fmds.length; i++)</span>
<span class="nc bnc" id="L632" title="All 4 branches missed.">                    if (!fmds[i].isPrimaryKey() &amp;&amp; !fmds[i].isVersion())</span>
<span class="nc" id="L633">                        detachField(from, i, fgfields.get(i));</span>
            } finally {
                // clear the StateManager from the target object
<span class="nc bnc" id="L636" title="All 2 branches missed.">                if (_copy)</span>
<span class="nc" id="L637">                    _to.pcReplaceStateManager(null);</span>
            }
<span class="nc" id="L639">        }</span>

        /**
         * Detach (or clear) the given field index.
         */
        private void detachField(PersistenceCapable from, int i, boolean fg) {
            // tell the state manager to provide the fields from the source to
            // this field manager, which will then replace the field with a
            // detached version
<span class="nc bnc" id="L648" title="All 2 branches missed.">            if (fg)</span>
<span class="nc" id="L649">                sm.provideField(from, this, i);</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">            else if (!_copy) {</span>
                // if not copying and field should not be detached, clear it
<span class="nc" id="L652">                clear();</span>
<span class="nc" id="L653">                sm.replaceField(_to, this, i);</span>
            }
<span class="nc" id="L655">        }</span>

        @Override
        public void storeBooleanField(int field, boolean curVal) {
<span class="nc" id="L659">            super.storeBooleanField(field, curVal);</span>
<span class="nc" id="L660">            sm.replaceField(_to, this, field);</span>
<span class="nc" id="L661">        }</span>

        @Override
        public void storeByteField(int field, byte curVal) {
<span class="nc" id="L665">            super.storeByteField(field, curVal);</span>
<span class="nc" id="L666">            sm.replaceField(_to, this, field);</span>
<span class="nc" id="L667">        }</span>

        @Override
        public void storeCharField(int field, char curVal) {
<span class="nc" id="L671">            super.storeCharField(field, curVal);</span>
<span class="nc" id="L672">            sm.replaceField(_to, this, field);</span>
<span class="nc" id="L673">        }</span>

        @Override
        public void storeDoubleField(int field, double curVal) {
<span class="nc" id="L677">            super.storeDoubleField(field, curVal);</span>
<span class="nc" id="L678">            sm.replaceField(_to, this, field);</span>
<span class="nc" id="L679">        }</span>

        @Override
        public void storeFloatField(int field, float curVal) {
<span class="nc" id="L683">            super.storeFloatField(field, curVal);</span>
<span class="nc" id="L684">            sm.replaceField(_to, this, field);</span>
<span class="nc" id="L685">        }</span>

        @Override
        public void storeIntField(int field, int curVal) {
<span class="nc" id="L689">            super.storeIntField(field, curVal);</span>
<span class="nc" id="L690">            sm.replaceField(_to, this, field);</span>
<span class="nc" id="L691">        }</span>

        @Override
        public void storeLongField(int field, long curVal) {
<span class="nc" id="L695">            super.storeLongField(field, curVal);</span>
<span class="nc" id="L696">            sm.replaceField(_to, this, field);</span>
<span class="nc" id="L697">        }</span>

        @Override
        public void storeShortField(int field, short curVal) {
<span class="nc" id="L701">            super.storeShortField(field, curVal);</span>
<span class="nc" id="L702">            sm.replaceField(_to, this, field);</span>
<span class="nc" id="L703">        }</span>

        @Override
        public void storeStringField(int field, String curVal) {
<span class="nc" id="L707">            super.storeStringField(field, curVal);</span>
<span class="nc" id="L708">            sm.replaceField(_to, this, field);</span>
<span class="nc" id="L709">        }</span>

        @Override
        public void storeObjectField(int field, Object curVal) {
<span class="nc" id="L713">            super.storeObjectField(field, detachField(curVal, field));</span>
<span class="nc" id="L714">            sm.replaceField(_to, this, field);</span>
<span class="nc" id="L715">        }</span>

        /**
         * Set the owner of the field's proxy to the detached state manager.
         */
        private Object reproxy(Object obj, int field) {
<span class="nc bnc" id="L721" title="All 6 branches missed.">            if (obj != null &amp;&amp; _detSM != null &amp;&amp; obj instanceof Proxy)</span>
<span class="nc" id="L722">                ((Proxy) obj).setOwner(_detSM, field);</span>
<span class="nc" id="L723">            return obj;</span>
        }

        /**
         * Detach the given value if needed.
         */
        private Object detachField(Object curVal, int field) {
<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (curVal == null)</span>
<span class="nc" id="L731">                return null;</span>

<span class="nc" id="L733">            FieldMetaData fmd = sm.getMetaData().getField(field);</span>

<span class="nc" id="L735">            boolean cascade = false;</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">            if(_cascadeWithDetach</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">                || fmd.getCascadeDetach() ==</span>
                    ValueMetaData.CASCADE_IMMEDIATE
<span class="nc bnc" id="L739" title="All 2 branches missed.">                || fmd.getKey().getCascadeDetach() ==</span>
                    ValueMetaData.CASCADE_IMMEDIATE
<span class="nc bnc" id="L741" title="All 2 branches missed.">                || fmd.getElement().getCascadeDetach() ==</span>
                    ValueMetaData.CASCADE_IMMEDIATE) {
<span class="nc" id="L743">                cascade = true;</span>
            }

<span class="nc" id="L746">            Object newVal = null;</span>
<span class="nc bnc" id="L747" title="All 8 branches missed.">            switch (fmd.getDeclaredTypeCode()) {</span>
            case JavaTypes.ARRAY:
<span class="nc bnc" id="L749" title="All 2 branches missed.">                if (_copy)</span>
<span class="nc" id="L750">                    newVal = _proxy.copyArray(curVal);</span>
                else
<span class="nc" id="L752">                    newVal = curVal;</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                if (cascade) {</span>
<span class="nc" id="L754">                    detachArray(newVal, fmd);</span>
                }
<span class="nc" id="L756">                return newVal;</span>
            case JavaTypes.COLLECTION:
<span class="nc bnc" id="L758" title="All 2 branches missed.">                if (_copy) {</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">                    if (_detSM != null) {</span>
<span class="nc" id="L760">                        newVal = _proxy.newCollectionProxy(fmd.getProxyType(),</span>
<span class="nc" id="L761">                            fmd.getElement().getDeclaredType(),</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">                            fmd.getInitializer() instanceof Comparator ?</span>
<span class="nc" id="L763">                            (Comparator) fmd.getInitializer() : null,</span>
<span class="nc" id="L764">                            sm.getBroker().getConfiguration().</span>
<span class="nc" id="L765">                            getCompatibilityInstance().getAutoOff());</span>
<span class="nc" id="L766">                        ((Collection) newVal).addAll((Collection) curVal);</span>
                    } else
<span class="nc" id="L768">                        newVal = _proxy.copyCollection((Collection) curVal);</span>
                } else
<span class="nc" id="L770">                    newVal = curVal;</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">                if (cascade) {</span>
<span class="nc" id="L772">                    detachCollection((Collection) newVal, (Collection) curVal,</span>
                        fmd);
                }
<span class="nc" id="L775">                return reproxy(newVal, field);</span>
            case JavaTypes.MAP:
<span class="nc bnc" id="L777" title="All 2 branches missed.">                if (_copy) {</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">                    if (_detSM != null) {</span>
<span class="nc" id="L779">                        newVal = _proxy.newMapProxy(fmd.getProxyType(),</span>
<span class="nc" id="L780">                            fmd.getKey().getDeclaredType(),</span>
<span class="nc" id="L781">                            fmd.getElement().getDeclaredType(),</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">                            fmd.getInitializer() instanceof Comparator ?</span>
<span class="nc" id="L783">                                (Comparator) fmd.getInitializer() : null,</span>
<span class="nc" id="L784">                                sm.getBroker().getConfiguration().</span>
<span class="nc" id="L785">                                getCompatibilityInstance().getAutoOff());</span>
<span class="nc" id="L786">                        ((Map) newVal).putAll((Map) curVal);</span>
                    } else
<span class="nc" id="L788">                        newVal = _proxy.copyMap((Map) curVal);</span>
                } else
<span class="nc" id="L790">                    newVal = curVal;</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">                if (cascade) {</span>
<span class="nc" id="L792">                    detachMap((Map) newVal, (Map) curVal, fmd);</span>
                }
<span class="nc" id="L794">                return reproxy(newVal, field);</span>
            case JavaTypes.CALENDAR:
<span class="nc bnc" id="L796" title="All 2 branches missed.">                newVal = (_copy) ? _proxy.copyCalendar((Calendar) curVal) :</span>
<span class="nc" id="L797">                    curVal;</span>
<span class="nc" id="L798">                return reproxy(newVal, field);</span>
            case JavaTypes.DATE:
<span class="nc bnc" id="L800" title="All 2 branches missed.">                newVal = (_copy) ? _proxy.copyDate((Date) curVal) : curVal;</span>
<span class="nc" id="L801">                return reproxy(newVal, field);</span>
            case JavaTypes.OBJECT:
<span class="nc bnc" id="L803" title="All 2 branches missed.">                if (_copy)</span>
<span class="nc" id="L804">                    newVal = _proxy.copyCustom(curVal);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">                return reproxy((newVal == null) ? curVal : newVal, field);</span>
            case JavaTypes.PC:
            case JavaTypes.PC_UNTYPED:
<span class="nc bnc" id="L808" title="All 2 branches missed.">                if (cascade) {</span>
<span class="nc" id="L809">                    return detachInternal(curVal);</span>
                }
<span class="nc" id="L811">                return curVal;</span>
            default:
<span class="nc" id="L813">                return curVal;</span>
            }
        }

        /**
         * Make sure all the values in the given array are detached.
         */
        private void detachArray(Object array, FieldMetaData fmd) {
<span class="nc bnc" id="L821" title="All 2 branches missed.">            if (!fmd.getElement().isDeclaredTypePC())</span>
<span class="nc" id="L822">                return;</span>

<span class="nc" id="L824">            int len = Array.getLength(array);</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">            for (int i = 0; i &lt; len; i++)</span>
<span class="nc" id="L826">                Array.set(array, i, detachInternal(Array.get(array, i)));</span>
<span class="nc" id="L827">        }</span>

        /**
         * Make sure all the values in the given collection are detached.
         */
        private void detachCollection(Collection coll, Collection orig,
            FieldMetaData fmd) {
            // coll can be null if not copyable
<span class="nc bnc" id="L835" title="All 4 branches missed.">            if (_copy &amp;&amp; coll == null)</span>
<span class="nc" id="L836">                throw new UserException(_loc.get(&quot;not-copyable&quot;, fmd));</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">            if (!fmd.getElement().isDeclaredTypePC())</span>
<span class="nc" id="L838">                return;</span>

            // unfortunately we have to clear the original and re-add to copy
<span class="nc bnc" id="L841" title="All 2 branches missed.">            if (_copy)</span>
<span class="nc" id="L842">                coll.clear();</span>
            Object detached;
<span class="nc bnc" id="L844" title="All 2 branches missed.">            for (Iterator itr = orig.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L845">                detached = detachInternal(itr.next());</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">                if (_copy)</span>
<span class="nc" id="L847">                    coll.add(detached);</span>
            }
<span class="nc" id="L849">        }</span>

        /**
         * Make sure all the values in the given map are detached.
         */
        private void detachMap(Map map, Map orig, FieldMetaData fmd) {
            // map can be null if not copyable
<span class="nc bnc" id="L856" title="All 4 branches missed.">            if (_copy &amp;&amp; map == null)</span>
<span class="nc" id="L857">                throw new UserException(_loc.get(&quot;not-copyable&quot;, fmd));</span>
<span class="nc" id="L858">            boolean keyPC = fmd.getKey().isDeclaredTypePC();</span>
<span class="nc" id="L859">            boolean valPC = fmd.getElement().isDeclaredTypePC();</span>
<span class="nc bnc" id="L860" title="All 4 branches missed.">            if (!keyPC &amp;&amp; !valPC)</span>
<span class="nc" id="L861">                return;</span>

            // if we have to copy keys, just clear and re-add; otherwise
            // we can use the entry set to reset the values only
            Map.Entry entry;
<span class="nc bnc" id="L866" title="All 4 branches missed.">            if (!_copy || keyPC) {</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">                if (_copy)</span>
<span class="nc" id="L868">                    map.clear();</span>
                Object key, val;
<span class="nc bnc" id="L870" title="All 2 branches missed.">                for (Iterator itr = orig.entrySet().iterator(); itr.hasNext();){</span>
<span class="nc" id="L871">                    entry = (Map.Entry) itr.next();</span>
<span class="nc" id="L872">                    key = entry.getKey();</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">                    if (keyPC)</span>
<span class="nc" id="L874">                        key = detachInternal(key);</span>
<span class="nc" id="L875">                    val = entry.getValue();</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">                    if (valPC)</span>
<span class="nc" id="L877">                        val = detachInternal(val);</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">                    if (_copy)</span>
<span class="nc" id="L879">                        map.put(key, val);</span>
                }
            } else {
<span class="nc bnc" id="L882" title="All 2 branches missed.">                for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {</span>
<span class="nc" id="L883">                    entry = (Map.Entry) itr.next ();</span>
<span class="nc" id="L884">                    entry.setValue (detachInternal (entry.getValue ()));</span>
				}
			}
<span class="nc" id="L887">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>