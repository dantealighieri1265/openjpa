<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractBrokerFactory.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-kernel</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.kernel</a> &gt; <span class="el_source">AbstractBrokerFactory.java</span></div><h1>AbstractBrokerFactory.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.kernel;

import java.io.ObjectStreamException;
import java.security.AccessController;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantLock;

import javax.transaction.Status;
import javax.transaction.Synchronization;
import javax.transaction.Transaction;
import javax.transaction.TransactionManager;

import org.apache.commons.collections4.map.AbstractReferenceMap.ReferenceStrength;
import org.apache.commons.collections4.set.MapBackedSet;
import org.apache.openjpa.audit.Auditor;
import org.apache.openjpa.conf.BrokerValue;
import org.apache.openjpa.conf.OpenJPAConfiguration;
import org.apache.openjpa.conf.OpenJPAConfigurationImpl;
import org.apache.openjpa.conf.OpenJPAVersion;
import org.apache.openjpa.datacache.DataCacheStoreManager;
import org.apache.openjpa.ee.ManagedRuntime;
import org.apache.openjpa.enhance.ManagedClassSubclasser;
import org.apache.openjpa.enhance.PCRegistry;
import org.apache.openjpa.enhance.PersistenceCapable;
import org.apache.openjpa.event.BrokerFactoryEvent;
import org.apache.openjpa.event.RemoteCommitEventManager;
import org.apache.openjpa.instrumentation.InstrumentationManager;
import org.apache.openjpa.lib.conf.Configuration;
import org.apache.openjpa.lib.conf.Configurations;
import org.apache.openjpa.lib.instrumentation.InstrumentationLevel;
import org.apache.openjpa.lib.log.Log;
import org.apache.openjpa.lib.util.J2DoPrivHelper;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.lib.util.StringUtil;
import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;
import org.apache.openjpa.meta.MetaDataModes;
import org.apache.openjpa.meta.MetaDataRepository;
import org.apache.openjpa.util.GeneralException;
import org.apache.openjpa.util.InternalException;
import org.apache.openjpa.util.InvalidStateException;
import org.apache.openjpa.util.OpenJPAException;
import org.apache.openjpa.util.UserException;

/**
 * Abstract implementation of the {@link BrokerFactory}
 * that must be subclassed for a specific runtime.
 *
 * @author Abe White
 */
public abstract class AbstractBrokerFactory implements BrokerFactory {
    private static final long serialVersionUID = 1L;

<span class="nc" id="L82">    private static final Localizer _loc = Localizer.forPackage(AbstractBrokerFactory.class);</span>

    // static mapping of configurations to pooled broker factories
<span class="nc" id="L85">    private static final Map&lt;Object,AbstractBrokerFactory&gt; _pool =</span>
<span class="nc" id="L86">       Collections.synchronizedMap(new HashMap&lt;Object,AbstractBrokerFactory&gt;());</span>

    // configuration
    private final OpenJPAConfiguration _conf;
<span class="nc" id="L90">    private transient boolean _readOnly = false;</span>
<span class="nc" id="L91">    private transient boolean _closed = false;</span>
<span class="nc" id="L92">    private transient RuntimeException _closedException = null;</span>
<span class="nc" id="L93">    private Map&lt;Object,Object&gt; _userObjects = null;</span>

    // internal lock: spec forbids synchronization on this object
<span class="nc" id="L96">    private final ReentrantLock _lock = new ReentrantLock();</span>

    // maps global transactions to associated brokers
<span class="nc" id="L99">    private transient ConcurrentHashMap&lt;Object,Collection&lt;Broker&gt;&gt;</span>
        _transactional = new ConcurrentHashMap&lt;&gt;();

    // weak-ref tracking of open brokers
    private transient Set&lt;Broker&gt; _brokers;

    // cache the class names loaded from the persistent classes property so
    // that we can re-load them for each new broker
<span class="nc" id="L107">    private transient Collection&lt;String&gt; _pcClassNames = null;</span>
<span class="nc" id="L108">    private transient Collection&lt;ClassLoader&gt; _pcClassLoaders = null;</span>
<span class="nc" id="L109">    private transient boolean _persistentTypesLoaded = false;</span>

    // lifecycle listeners to pass to each broker
<span class="nc" id="L112">    private transient Map&lt;Object, Class&lt;?&gt;[]&gt; _lifecycleListeners = null;</span>

    // transaction listeners to pass to each broker
<span class="nc" id="L115">    private transient List&lt;Object&gt; _transactionListeners = null;</span>

    // key under which this instance can be stored in the broker pool
    // and later identified
    private Object _poolKey;

    /**
     * Return an internal factory pool key for the given configuration.
     *
     * @since 1.1.0
     */
    protected static Object toPoolKey(Map&lt;String,Object&gt; map) {
<span class="nc" id="L127">        Object key = Configurations.getProperty(&quot;Id&quot;, map);</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        return ( key != null) ? key : map;</span>
    }

    /**
     * Register &lt;code&gt;factory&lt;/code&gt; in the pool under &lt;code&gt;key&lt;/code&gt;.
     *
     * @since 1.1.0
     */
    protected static void pool(Object key, AbstractBrokerFactory factory) {
<span class="nc" id="L137">        synchronized(_pool) {</span>
<span class="nc" id="L138">            _pool.put(key, factory);</span>
<span class="nc" id="L139">            factory.setPoolKey(key);</span>
<span class="nc" id="L140">            factory.makeReadOnly();</span>
<span class="nc" id="L141">        }</span>
<span class="nc" id="L142">    }</span>

    /**
     * Return the pooled factory matching the given key, or null
     * if none. The key must be of the form created by {@link #getPoolKey}.
     */
    public static AbstractBrokerFactory getPooledFactoryForKey(Object key) {
<span class="nc" id="L149">        return _pool.get(key);</span>
    }

    /**
     * Constructor. Configuration must be provided on construction.
     */
<span class="nc" id="L155">    protected AbstractBrokerFactory(OpenJPAConfiguration config) {</span>
<span class="nc" id="L156">        _conf = config;</span>
<span class="nc" id="L157">        _brokers = newBrokerSet();</span>
<span class="nc" id="L158">        getPcClassLoaders();</span>
<span class="nc" id="L159">    }</span>

    /**
     * Return the configuration for this factory.
     */
    @Override
    public OpenJPAConfiguration getConfiguration() {
<span class="nc" id="L166">        return _conf;</span>
    }

    @Override
    public Broker newBroker() {
<span class="nc" id="L171">        return newBroker(_conf.getConnectionUserName(), _conf.getConnectionPassword());</span>
    }

    public Broker newBroker(String user, String pass) {
<span class="nc" id="L175">        return newBroker(user, pass, _conf.isTransactionModeManaged(), _conf.getConnectionRetainModeConstant());</span>
    }

    public Broker newBroker(boolean managed, int connRetainMode) {
<span class="nc" id="L179">        return newBroker(_conf.getConnectionUserName(), _conf.getConnectionPassword(), managed, connRetainMode);</span>
    }

    public Broker newBroker(String user, String pass, boolean managed, int connRetainMode) {
<span class="nc" id="L183">        return newBroker(user, pass, managed, connRetainMode, true);</span>
    }

    @Override
    public Broker newBroker(String user, String pass, boolean managed, int connRetainMode, boolean findExisting) {
<span class="nc" id="L188">        return newBroker(user, pass, managed, connRetainMode, findExisting, &quot;&quot;, &quot;&quot;);</span>
    }

    @Override
    public Broker newBroker(String user, String pass, boolean managed, int connRetainMode, boolean findExisting,
        String cf1Name, String cf2Name) {
        try {
<span class="nc" id="L195">            assertOpen();</span>

<span class="nc bnc" id="L197" title="All 2 branches missed.">            if(StringUtil.isNotEmpty(cf1Name)) {</span>
                // If the cfName has been set on the broker try looking up now.
                try {
<span class="nc" id="L200">                    _conf.getConnectionFactory();</span>
                }
<span class="nc" id="L202">                catch(UserException ue) {</span>
                     // try setting the broker's CF into the configuration.
<span class="nc" id="L204">                    _conf.setConnectionFactoryName(cf1Name);</span>
<span class="nc" id="L205">                }</span>
            }
<span class="nc" id="L207">            makeReadOnly();</span>

<span class="nc" id="L209">            Broker broker = null;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (findExisting)</span>
<span class="nc" id="L211">                broker = findBroker(user, pass, managed);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (broker == null) {</span>
<span class="nc" id="L213">                broker = newBrokerImpl(user, pass);</span>
<span class="nc" id="L214">                broker.setConnectionFactoryName(cf1Name);</span>
<span class="nc" id="L215">                broker.setConnectionFactory2Name(cf2Name);</span>
<span class="nc" id="L216">                initializeBroker(managed, connRetainMode, broker, false);</span>
            }
<span class="nc" id="L218">            return broker;</span>
<span class="nc" id="L219">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L220">            throw ke;</span>
<span class="nc" id="L221">        } catch (RuntimeException re) {</span>
<span class="nc" id="L222">            throw new GeneralException(re);</span>
        }
    }

    void initializeBroker(boolean managed, int connRetainMode, Broker broker, boolean fromDeserialization) {
<span class="nc" id="L227">        assertOpen();</span>
<span class="nc" id="L228">        makeReadOnly();</span>

<span class="nc" id="L230">        DelegatingStoreManager dsm = createDelegatingStoreManager();</span>

<span class="nc" id="L232">        ((BrokerImpl) broker).initialize(this, dsm, managed, connRetainMode, fromDeserialization);</span>

        // if we're using remote events, register the event manager so
        // that it can broadcast commit notifications from the broker
<span class="nc" id="L236">        RemoteCommitEventManager remote = _conf.getRemoteCommitEventManager();</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (remote.areRemoteEventsEnabled())</span>
<span class="nc" id="L238">            broker.addTransactionListener(remote);</span>

<span class="nc" id="L240">       loadPersistentTypes(broker.getClassLoader());</span>
<span class="nc" id="L241">        _brokers.add(broker);</span>
<span class="nc" id="L242">        _conf.setReadOnly(Configuration.INIT_STATE_FROZEN);</span>
<span class="nc" id="L243">    }</span>

    /**
     * Add factory-registered lifecycle listeners to the broker.
     */
    protected void addListeners(Broker broker) {
<span class="nc bnc" id="L249" title="All 4 branches missed.">        if (_lifecycleListeners != null &amp;&amp; !_lifecycleListeners.isEmpty()) {</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            for (Map.Entry&lt;Object,Class&lt;?&gt;[]&gt; entry : _lifecycleListeners.entrySet()) {</span>
<span class="nc" id="L251">                broker.addLifecycleListener(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L252">            }</span>
        }

<span class="nc bnc" id="L255" title="All 4 branches missed.">        if (_transactionListeners != null &amp;&amp; !_transactionListeners.isEmpty()) {</span>
<span class="nc" id="L256">            for (Iterator&lt;Object&gt; itr = _transactionListeners.iterator();</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">                itr.hasNext(); ) {</span>
<span class="nc" id="L258">                broker.addTransactionListener(itr.next());</span>
            }
        }
<span class="nc" id="L261">    }</span>

    /**
     * Load the configured persistent classes list. Performed automatically
     * whenever a broker is created.
     */
    public void loadPersistentTypes(ClassLoader envLoader) {
        // if we've loaded the persistent types and the class name list
        // is empty, then we can simply return. Note that there is a
        // potential threading scenario in which _persistentTypesLoaded is
        // false when read, but the work to populate _pcClassNames has
        // already been done. This is ok; _pcClassNames can tolerate
        // concurrent access, so the worst case is that the list is
        // persistent type data is processed multiple times, which this
        // algorithm takes into account.
<span class="nc bnc" id="L276" title="All 4 branches missed.">        if (_persistentTypesLoaded &amp;&amp; _pcClassNames.isEmpty())</span>
<span class="nc" id="L277">            return;</span>

        // cache persistent type names if not already
<span class="nc" id="L280">        ClassLoader loader = _conf.getClassResolverInstance().</span>
<span class="nc" id="L281">            getClassLoader(getClass(), envLoader);</span>
<span class="nc" id="L282">        Collection&lt;Class&lt;?&gt;&gt; toRedefine = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (!_persistentTypesLoaded) {</span>
<span class="nc" id="L284">            Collection&lt;Class&lt;?&gt;&gt; clss = _conf.getMetaDataRepositoryInstance().</span>
<span class="nc" id="L285">                loadPersistentTypes(false, loader, _conf.isInitializeEagerly());</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            if (clss.isEmpty())</span>
<span class="nc" id="L287">                _pcClassNames = Collections.emptyList();</span>
            else {
<span class="nc" id="L289">                Collection&lt;String&gt; c = new ArrayList&lt;&gt;(clss.size());</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                for (Iterator&lt;Class&lt;?&gt;&gt; itr = clss.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L291">                    Class&lt;?&gt; cls = itr.next();</span>
<span class="nc" id="L292">                    c.add(cls.getName());</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                    if (needsSub(cls))</span>
<span class="nc" id="L294">                        toRedefine.add(cls);</span>
<span class="nc" id="L295">                }</span>
<span class="nc" id="L296">                getPcClassLoaders().add(loader);</span>
<span class="nc" id="L297">                _pcClassNames = c;</span>
            }
<span class="nc" id="L299">            _persistentTypesLoaded = true;</span>
<span class="nc" id="L300">        } else {</span>
            // reload with this loader
<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (getPcClassLoaders().add(loader)) {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                for (String clsName : _pcClassNames) {</span>
                    try {
<span class="nc" id="L305">                        Class&lt;?&gt; cls = Class.forName(clsName, true, loader);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                        if (needsSub(cls))</span>
<span class="nc" id="L307">                            toRedefine.add(cls);</span>
<span class="nc" id="L308">                    } catch (Throwable t) {</span>
<span class="nc" id="L309">                        _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME).warn(null, t);</span>
<span class="nc" id="L310">                    }</span>
<span class="nc" id="L311">                }</span>
            }
        }

        // get the ManagedClassSubclasser into the loop
<span class="nc" id="L316">        ManagedClassSubclasser.prepareUnenhancedClasses(_conf, toRedefine, envLoader);</span>
<span class="nc" id="L317">    }</span>

    private boolean needsSub(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">        return !cls.isInterface()</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            &amp;&amp; !PersistenceCapable.class.isAssignableFrom(cls);</span>
    }

    @Override
    public void addLifecycleListener(Object listener, Class&lt;?&gt;[] classes) {
<span class="nc" id="L326">        lock();</span>
        try {
<span class="nc" id="L328">            assertOpen();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            if (_lifecycleListeners == null)</span>
<span class="nc" id="L330">                _lifecycleListeners = new HashMap&lt;&gt;(7);</span>
<span class="nc" id="L331">            _lifecycleListeners.put(listener, classes);</span>
        } finally {
<span class="nc" id="L333">            unlock();</span>
        }
<span class="nc" id="L335">    }</span>

    @Override
    public void removeLifecycleListener(Object listener) {
<span class="nc" id="L339">        lock();</span>
        try {
<span class="nc" id="L341">            assertOpen();</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">            if (_lifecycleListeners != null)</span>
<span class="nc" id="L343">                _lifecycleListeners.remove(listener);</span>
        } finally {
<span class="nc" id="L345">            unlock();</span>
        }
<span class="nc" id="L347">    }</span>

    @Override
    public void addTransactionListener(Object listener) {
<span class="nc" id="L351">        lock();</span>
        try {
<span class="nc" id="L353">            assertOpen();</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">            if (_transactionListeners == null)</span>
<span class="nc" id="L355">                _transactionListeners = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L356">            _transactionListeners.add(listener);</span>
        } finally {
<span class="nc" id="L358">            unlock();</span>
        }
<span class="nc" id="L360">    }</span>

    @Override
    public void removeTransactionListener(Object listener) {
<span class="nc" id="L364">        lock();</span>
        try {
<span class="nc" id="L366">            assertOpen();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">            if (_transactionListeners != null)</span>
<span class="nc" id="L368">                _transactionListeners.remove(listener);</span>
        } finally {
<span class="nc" id="L370">            unlock();</span>
        }
<span class="nc" id="L372">    }</span>

    /**
     * Returns true if this broker factory is closed.
     */
    @Override
    public boolean isClosed() {
<span class="nc" id="L379">        return _closed;</span>
    }

    @Override
    public void close() {
<span class="nc" id="L384">        lock();</span>

        try {
<span class="nc" id="L387">            assertOpen();</span>
<span class="nc" id="L388">            assertNoActiveTransaction();</span>

            // remove from factory pool
<span class="nc" id="L391">            synchronized (_pool) {</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                if (_pool.get(_poolKey) == this)</span>
<span class="nc" id="L393">                    _pool.remove(_poolKey);</span>
<span class="nc" id="L394">            }</span>

            // close all brokers
<span class="nc bnc" id="L397" title="All 2 branches missed.">            for (Broker broker : _brokers) {</span>
                // Check for null because _brokers may contain weak references
<span class="nc bnc" id="L399" title="All 4 branches missed.">                if ((broker != null) &amp;&amp; (!broker.isClosed()))</span>
<span class="nc" id="L400">                    broker.close();</span>
<span class="nc" id="L401">            }</span>

<span class="nc bnc" id="L403" title="All 2 branches missed.">            if(_conf.metaDataRepositoryAvailable()) {</span>
                // remove metadata repository from listener list
<span class="nc" id="L405">                PCRegistry.removeRegisterClassListener</span>
<span class="nc" id="L406">                    (_conf.getMetaDataRepositoryInstance());</span>
            }

<span class="nc" id="L409">            _conf.close();</span>
<span class="nc" id="L410">            _closed = true;</span>
<span class="nc" id="L411">            Log log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (log.isTraceEnabled())</span>
<span class="nc" id="L413">                _closedException = new IllegalStateException();</span>
        } finally {
<span class="nc" id="L415">            unlock();</span>
        }
<span class="nc" id="L417">    }</span>

    /**
     * Subclasses should override this method to add a &lt;code&gt;Platform&lt;/code&gt;
     * property listing the runtime platform, such as:
     * &lt;code&gt;OpenJPA JDBC Edition: Oracle Database&lt;/code&gt;
     */
    @Override
    public Map&lt;String,Object&gt; getProperties() {
        // required props are VendorName and VersionNumber
<span class="nc" id="L427">        Map&lt;String,Object&gt; props = _conf.toProperties(true);</span>
<span class="nc" id="L428">        props.put(&quot;VendorName&quot;, OpenJPAVersion.VENDOR_NAME);</span>
<span class="nc" id="L429">        props.put(&quot;VersionNumber&quot;, OpenJPAVersion.VERSION_NUMBER);</span>
<span class="nc" id="L430">        props.put(&quot;VersionId&quot;, OpenJPAVersion.VERSION_ID);</span>
<span class="nc" id="L431">        return props;</span>
    }

    @Override
    public Set&lt;String&gt; getSupportedProperties() {
<span class="nc" id="L436">        return _conf.getPropertyKeys();</span>
    }

    @Override
    public Object getUserObject(Object key) {
<span class="nc" id="L441">        lock();</span>
        try {
<span class="nc" id="L443">            assertOpen();</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">            return (_userObjects == null) ? null : _userObjects.get(key);</span>
        } finally {
<span class="nc" id="L446">            unlock();</span>
        }
    }

    @Override
    public Object putUserObject(Object key, Object val) {
<span class="nc" id="L452">        lock();</span>
        try {
<span class="nc" id="L454">            assertOpen();</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">            if (val == null)</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                return (_userObjects == null) ? null : _userObjects.remove(key);</span>

<span class="nc bnc" id="L458" title="All 2 branches missed.">            if (_userObjects == null)</span>
<span class="nc" id="L459">                _userObjects = new HashMap&lt;&gt;();</span>
<span class="nc" id="L460">            return _userObjects.put(key, val);</span>
        } finally {
<span class="nc" id="L462">            unlock();</span>
        }
    }

    @Override
    public void lock() {
<span class="nc" id="L468">        _lock.lock();</span>
<span class="nc" id="L469">    }</span>

    @Override
    public void unlock() {
<span class="nc" id="L473">        _lock.unlock();</span>
<span class="nc" id="L474">    }</span>

    /**
     * Replaces the factory with this JVMs pooled version if it exists. Also
     * freezes the factory.
     */
    protected Object readResolve()
        throws ObjectStreamException {
<span class="nc" id="L482">        AbstractBrokerFactory factory = getPooledFactoryForKey(_poolKey);</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (factory != null)</span>
<span class="nc" id="L484">            return factory;</span>

        // reset these transient fields to empty values
<span class="nc" id="L487">        _transactional = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L488">        _brokers = newBrokerSet();</span>

        // turn off logging while de-serializing BrokerFactory
<span class="nc" id="L491">        String saveLogConfig = _conf.getLog();</span>
<span class="nc" id="L492">        _conf.setLog(&quot;none&quot;);</span>
<span class="nc" id="L493">        makeReadOnly();</span>
        // re-enable any logging which was in effect
<span class="nc" id="L495">        _conf.setLog(saveLogConfig);</span>

<span class="nc" id="L497">        return this;</span>
    }

    private Set&lt;Broker&gt; newBrokerSet() {
        BrokerValue bv;
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if (_conf instanceof OpenJPAConfigurationImpl)</span>
<span class="nc" id="L503">            bv = ((OpenJPAConfigurationImpl) _conf).brokerPlugin;</span>
        else
<span class="nc" id="L505">            bv = (BrokerValue) _conf.getValue(BrokerValue.KEY);</span>

<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (FinalizingBrokerImpl.class.isAssignableFrom(bv.getTemplateBrokerType(_conf))) {</span>
<span class="nc" id="L508">            return MapBackedSet.mapBackedSet(new ConcurrentHashMap(), new Object() { });</span>
        } else {
<span class="nc" id="L510">            return new ConcurrentReferenceHashSet&lt;&gt;(ReferenceStrength.WEAK);</span>
        }
    }

    ////////////////////////
    // Methods for Override
    ////////////////////////

    /**
     * Return a new StoreManager for this runtime. Note that the instance
     * returned here may be wrapped before being passed to the
     * {@link #newBroker} method.
     */
    protected abstract StoreManager newStoreManager();

    /**
     * Find a pooled broker, or return null if none. If using
     * managed transactions, looks for a transactional broker;
     * otherwise returns null by default. This method will be called before
     * {@link #newStoreManager} so that factory subclasses implementing
     * pooling can return a matching manager before a new {@link StoreManager}
     * is created.
     */
    protected Broker findBroker(String user, String pass, boolean managed) {
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (managed)</span>
<span class="nc" id="L535">            return findTransactionalBroker(user, pass);</span>
<span class="nc" id="L536">        return null;</span>
    }

    /**
     * Return a broker configured with the proper settings.
     * By default, this method constructs a new
     * BrokerImpl of the class set for this factory.
     */
    protected BrokerImpl newBrokerImpl(String user, String pass) {
<span class="nc" id="L545">        BrokerImpl broker = _conf.newBrokerInstance(user, pass);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (broker == null)</span>
<span class="nc" id="L547">            throw new UserException(_loc.get(&quot;no-broker-class&quot;,</span>
<span class="nc" id="L548">                _conf.getBrokerImpl()));</span>

<span class="nc" id="L550">        return broker;</span>
    }

    /**
     * Setup transient state used by this factory based on the
     * current configuration, which will subsequently be locked down. This
     * method will be called before the first broker is requested,
     * and will be re-called each time the factory is deserialized into a JVM
     * that has no configuration for this data store.
     */
    protected void setup() {
<span class="nc" id="L561">    }</span>

    /////////////
    // Utilities
    /////////////

    /**
     * Find a managed runtime broker associated with the
     * current transaction, or returns null if none.
     */
    protected Broker findTransactionalBroker(String user, String pass) {
        Transaction trans;
<span class="nc" id="L573">        ManagedRuntime mr = _conf.getManagedRuntimeInstance();</span>
        Object txKey;
        try {
<span class="nc" id="L576">            trans = mr.getTransactionManager().</span>
<span class="nc" id="L577">                getTransaction();</span>
<span class="nc" id="L578">            txKey = mr.getTransactionKey();</span>

<span class="nc bnc" id="L580" title="All 2 branches missed.">            if (trans == null</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">                || trans.getStatus() == Status.STATUS_NO_TRANSACTION</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                || trans.getStatus() == Status.STATUS_UNKNOWN)</span>
<span class="nc" id="L583">                return null;</span>
<span class="nc" id="L584">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L585">            throw ke;</span>
<span class="nc" id="L586">        } catch (Exception e) {</span>
<span class="nc" id="L587">            throw new GeneralException(e);</span>
<span class="nc" id="L588">        }</span>

<span class="nc" id="L590">        Collection&lt;Broker&gt; brokers = _transactional.get(txKey);</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">        if (brokers != null) {</span>
            // we don't need to synchronize on brokers since one JTA transaction
            // can never be active on multiple concurrent threads.
<span class="nc bnc" id="L594" title="All 2 branches missed.">            for (Broker broker : brokers) {</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">                if (Objects.equals(broker.getConnectionUserName(), user)</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                 &amp;&amp; Objects.equals(broker.getConnectionPassword(), pass))</span>
<span class="nc" id="L597">                    return broker;</span>
<span class="nc" id="L598">            }</span>
        }
<span class="nc" id="L600">        return null;</span>
    }

    /**
     * Configures the given broker with the current factory option settings.
     */
    protected void configureBroker(BrokerImpl broker) {
<span class="nc" id="L607">        broker.setOptimistic(_conf.getOptimistic());</span>
<span class="nc" id="L608">        broker.setNontransactionalRead(_conf.getNontransactionalRead());</span>
<span class="nc" id="L609">        broker.setNontransactionalWrite(_conf.getNontransactionalWrite());</span>
<span class="nc" id="L610">        broker.setRetainState(_conf.getRetainState());</span>
<span class="nc" id="L611">        broker.setRestoreState(_conf.getRestoreStateConstant());</span>
<span class="nc" id="L612">        broker.setAutoClear(_conf.getAutoClearConstant());</span>
<span class="nc" id="L613">        broker.setIgnoreChanges(_conf.getIgnoreChanges());</span>
<span class="nc" id="L614">        broker.setMultithreaded(_conf.getMultithreaded());</span>
<span class="nc" id="L615">        broker.setAutoDetach(_conf.getAutoDetachConstant());</span>
<span class="nc" id="L616">        broker.setDetachState(_conf.getDetachStateInstance().getDetachState());</span>
<span class="nc" id="L617">        broker.setPostLoadOnMerge(_conf.getPostLoadOnMerge());</span>
<span class="nc" id="L618">    }</span>

    /**
     * Freezes the configuration of this factory.
     */
    public void makeReadOnly() {
<span class="nc bnc" id="L624" title="All 2 branches missed.">        if (_readOnly)</span>
<span class="nc" id="L625">            return;</span>

<span class="nc" id="L627">        lock();</span>
        try {
            // check again
<span class="nc bnc" id="L630" title="All 2 branches missed.">            if (_readOnly)</span>
<span class="nc" id="L631">                return;</span>
<span class="nc" id="L632">            _readOnly = true;</span>

<span class="nc" id="L634">            Log log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">            if (log.isInfoEnabled()) {</span>
<span class="nc" id="L636">                log.info(getFactoryInitializationBanner());</span>
            }
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (log.isTraceEnabled()) {</span>
<span class="nc" id="L639">                Map&lt;String,Object&gt; props = _conf.toProperties(true);</span>
<span class="nc" id="L640">                String lineSep = J2DoPrivHelper.getLineSeparator();</span>
<span class="nc" id="L641">                StringBuilder buf = new StringBuilder();</span>
                Map.Entry&lt;?,?&gt; entry;
<span class="nc bnc" id="L643" title="All 2 branches missed.">                for (Iterator&lt;Map.Entry&lt;String,Object&gt;&gt; itr = props.entrySet().iterator(); itr.hasNext();) {</span>
<span class="nc" id="L644">                    entry = itr.next();</span>
<span class="nc" id="L645">                    Object value = entry.getValue();</span>
<span class="nc" id="L646">                    buf.append(entry.getKey()).append(&quot;: &quot;)</span>
<span class="nc bnc" id="L647" title="All 4 branches missed.">                       .append(value != null &amp;&amp; value.getClass().isArray() ? Arrays.toString((Object[])value) : value);</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">                    if (itr.hasNext())</span>
<span class="nc" id="L649">                        buf.append(lineSep);</span>
<span class="nc" id="L650">                }</span>
<span class="nc" id="L651">                log.trace(_loc.get(&quot;factory-properties&quot;, buf.toString()));</span>
            }

            // setup transient state
<span class="nc" id="L655">            setup();</span>

            // register the metdata repository to auto-load persistent types
            // and make sure types are enhanced
<span class="nc" id="L659">            MetaDataRepository repos = _conf.getMetaDataRepositoryInstance();</span>
<span class="nc" id="L660">            repos.setValidate(MetaDataRepository.VALIDATE_RUNTIME, true);</span>
<span class="nc" id="L661">            repos.setResolve(MetaDataModes.MODE_MAPPING_INIT, true);</span>
<span class="nc" id="L662">            PCRegistry.addRegisterClassListener(repos);</span>

            // freeze underlying configuration and eagerly initialize to
            // avoid synchronization
<span class="nc" id="L666">            _conf.setReadOnly(Configuration.INIT_STATE_FREEZING);</span>
<span class="nc" id="L667">            _conf.instantiateAll();</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">            if (_conf.isInitializeEagerly()) {</span>
<span class="nc" id="L669">                _conf.setReadOnly(Configuration.INIT_STATE_FROZEN);</span>
            }
            // fire an event for all the broker factory listeners
            // registered on the configuration.
<span class="nc" id="L673">            _conf.getBrokerFactoryEventManager().fireEvent(</span>
                new BrokerFactoryEvent(this,
                    BrokerFactoryEvent.BROKER_FACTORY_CREATED));
<span class="nc" id="L676">        } catch (RuntimeException e) {</span>
            // if the db connection is not available we need to reset the state
<span class="nc" id="L678">            _readOnly = false;</span>
<span class="nc" id="L679">            throw e;</span>
        } finally {
<span class="nc" id="L681">            unlock();</span>
        }
<span class="nc" id="L683">    }</span>

    /**
     * Return an object to be written to the log when this broker factory
     * initializes. This happens after the configuration is fully loaded.
     */
    protected Object getFactoryInitializationBanner() {
<span class="nc" id="L690">        return _loc.get(&quot;factory-init&quot;, OpenJPAVersion.VERSION_NUMBER);</span>
    }

    /**
     * Throw an exception if the factory is closed.  The exact message and
     * content of the exception varies whether TRACE is enabled or not.
     */
    @Override
    public void assertOpen() {
<span class="nc bnc" id="L699" title="All 2 branches missed.">        if (_closed) {</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">            if (_closedException == null)  // TRACE not enabled</span>
<span class="nc" id="L701">                throw new InvalidStateException(_loc</span>
<span class="nc" id="L702">                        .get(&quot;closed-factory-notrace&quot;));</span>
            else
<span class="nc" id="L704">                throw new InvalidStateException(_loc.get(&quot;closed-factory&quot;))</span>
<span class="nc" id="L705">                        .setCause(_closedException);</span>
        }
<span class="nc" id="L707">    }</span>

    ////////////////////
    // Broker utilities
    ////////////////////

    /**
     * Throws a {@link UserException} if a transaction is active. The thrown
     * exception will contain all the Brokers with active transactions as
     * failed objects in the nested exceptions.
     */
    private void assertNoActiveTransaction() {
        Collection&lt;Throwable&gt; excs;
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if (_transactional.isEmpty())</span>
<span class="nc" id="L721">            return;</span>

<span class="nc" id="L723">        excs = new ArrayList&lt;&gt;(_transactional.size());</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">        for (Collection&lt;Broker&gt; brokers : _transactional.values()) {</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">            for (Broker broker : brokers) {</span>
<span class="nc" id="L726">                excs.add(new InvalidStateException(_loc.get(&quot;active&quot;)).setFailedObject(broker));</span>
<span class="nc" id="L727">            }</span>
<span class="nc" id="L728">        }</span>

<span class="nc bnc" id="L730" title="All 2 branches missed.">        if (!excs.isEmpty())</span>
<span class="nc" id="L731">            throw new InvalidStateException(_loc.get(&quot;nested-exceps&quot;)).</span>
<span class="nc" id="L732">                setNestedThrowables(excs.toArray(new Throwable[excs.size()]));</span>
<span class="nc" id="L733">    }</span>

    /**
     * Synchronize the given broker with a managed transaction,
     * optionally starting one if none is in progress.
     *
     * @return true if synched with transaction, false otherwise
     */
    boolean syncWithManagedTransaction(BrokerImpl broker, boolean begin) {
        Transaction trans;
        try {
<span class="nc" id="L744">            ManagedRuntime mr = broker.getManagedRuntime();</span>
<span class="nc" id="L745">            TransactionManager tm = mr.getTransactionManager();</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">            if (tm == null) {</span>
<span class="nc" id="L747">                throw new InternalException(_loc.get(&quot;null-transactionmanager&quot;, mr));</span>
            }
<span class="nc" id="L749">            trans = tm.getTransaction();</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">            if (trans != null</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">                &amp;&amp; (trans.getStatus() == Status.STATUS_NO_TRANSACTION</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">                || trans.getStatus() == Status.STATUS_UNKNOWN))</span>
<span class="nc" id="L753">                trans = null;</span>

<span class="nc bnc" id="L755" title="All 4 branches missed.">            if (trans == null &amp;&amp; begin) {</span>
<span class="nc" id="L756">                tm.begin();</span>
<span class="nc" id="L757">                trans = tm.getTransaction();</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">            } else if (trans == null)</span>
<span class="nc" id="L759">                return false;</span>

            // synch broker and trans
<span class="nc" id="L762">            trans.registerSynchronization(broker);</span>

            // we don't need to synchronize on brokers or guard against multiple
            // threads using the same trans since one JTA transaction can never
            // be active on multiple concurrent threads.
<span class="nc" id="L767">            Object txKey = mr.getTransactionKey();</span>
<span class="nc" id="L768">            Collection&lt;Broker&gt; brokers = _transactional.get(txKey);</span>

<span class="nc bnc" id="L770" title="All 2 branches missed.">            if (brokers == null) {</span>
<span class="nc" id="L771">                brokers = new ArrayList&lt;&gt;(2);</span>
<span class="nc" id="L772">                _transactional.put(txKey, brokers);</span>
<span class="nc" id="L773">                trans.registerSynchronization(new RemoveTransactionSync(txKey));</span>
            }
<span class="nc" id="L775">            brokers.add(broker);</span>

<span class="nc" id="L777">            return true;</span>
<span class="nc" id="L778">        } catch (OpenJPAException ke) {</span>
<span class="nc" id="L779">            throw ke;</span>
<span class="nc" id="L780">        } catch (Exception e) {</span>
<span class="nc" id="L781">            throw new GeneralException(e);</span>
        }
    }

    /**
     * Returns a set of all the open brokers associated with this factory. The
     * returned set is unmodifiable, and may contain null references.
     */
    public Collection&lt;Broker&gt; getOpenBrokers() {
<span class="nc" id="L790">        return Collections.unmodifiableCollection(_brokers);</span>
    }

    /**
     * Release &lt;code&gt;broker&lt;/code&gt; from any internal data structures. This
     * is invoked by &lt;code&gt;broker&lt;/code&gt; after the broker is fully closed.
     *
     * @since 1.1.0
     */
    protected void releaseBroker(BrokerImpl broker) {
<span class="nc" id="L800">        _brokers.remove(broker);</span>
<span class="nc" id="L801">    }</span>

    /**
     * @return a key that can be used to obtain this broker factory from the
     * pool at a later time.
     *
     * @since 1.1.0
     */
    public Object getPoolKey() {
<span class="nc" id="L810">        return _poolKey;</span>
    }

    /**
     * Set a key that can be used to obtain this broker factory from the
     * pool at a later time.
     *
     * @since 1.1.0
     */
    void setPoolKey(Object key) {
<span class="nc" id="L820">        _poolKey = key;</span>
<span class="nc" id="L821">    }</span>

    /**
     * Simple synchronization listener to remove completed transactions
     * from our cache.
     */
    private class RemoveTransactionSync
        implements Synchronization {

        private final Object _trans;

<span class="nc" id="L832">        public RemoveTransactionSync(Object trans) {</span>
<span class="nc" id="L833">            _trans = trans;</span>
<span class="nc" id="L834">        }</span>

        @Override
        public void beforeCompletion() {
<span class="nc" id="L838">        }</span>

        @Override
        public void afterCompletion(int status) {
<span class="nc" id="L842">            _transactional.remove (_trans);</span>
<span class="nc" id="L843">		}</span>
	}

    /**
     * Method insures that deserialized EMF has this reference re-instantiated
     */
    private Collection&lt;ClassLoader&gt; getPcClassLoaders() {
<span class="nc bnc" id="L850" title="All 2 branches missed.">       if (_pcClassLoaders == null)</span>
<span class="nc" id="L851">         _pcClassLoaders = new ConcurrentReferenceHashSet&lt;&gt;(ReferenceStrength.WEAK);</span>

<span class="nc" id="L853">       return _pcClassLoaders;</span>
    }

    /**
     * &lt;P&gt;
     * Create a DelegatingStoreManager for use with a Broker created by this factory.
     * If a DataCache has been enabled a DataCacheStoreManager will be returned.
     * &lt;/P&gt;
     * &lt;P&gt;
     * If no DataCache is in use an ROPStoreManager will be returned.
     * &lt;/P&gt;
     *
     * @return A delegating store manager suitable for the current
     *         configuration.
     */
    protected DelegatingStoreManager createDelegatingStoreManager() {
        // decorate the store manager for data caching and custom
        // result object providers; always make sure it's a delegating
        // store manager, because it's easier for users to deal with
        // that way
<span class="nc" id="L873">        StoreManager sm = newStoreManager();</span>
<span class="nc" id="L874">        DelegatingStoreManager dsm = null;</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">        if (_conf.getDataCacheManagerInstance().getSystemDataCache() != null) {</span>
<span class="nc" id="L876">            dsm = new DataCacheStoreManager(sm);</span>
        }
<span class="nc bnc" id="L878" title="All 2 branches missed.">        dsm = new ROPStoreManager((dsm == null) ? sm : dsm);</span>

<span class="nc" id="L880">        return dsm;</span>
    }

    /**
     * This method is invoked AFTER a BrokerFactory has been instantiated.
     */
    @Override
    public void postCreationCallback() {
<span class="nc" id="L888">    	Auditor auditor = _conf.getAuditorInstance();</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">    	if (auditor != null) {</span>
<span class="nc" id="L890">    		addTransactionListener(new AuditManager(auditor));</span>
    	}
<span class="nc bnc" id="L892" title="All 2 branches missed.">        if (_conf.isInitializeEagerly()) {</span>
<span class="nc" id="L893">            newBroker(_conf.getConnectionUserName(), _conf.getConnectionPassword(),</span>
<span class="nc" id="L894">                _conf.isConnectionFactoryModeManaged(), _conf.getConnectionRetainModeConstant(), false).close();</span>
        }

        // Don't get a MetaDataRepository yet if not preloading because it is possible that someone has extended the MDR
        // and the extension hasn't been plugged in yet.
<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (MetaDataRepository.needsPreload(_conf) == true) {</span>
            // Don't catch any exceptions here because we want to fail-fast if something bad happens when we're
            // preloading.
<span class="nc" id="L902">            MetaDataRepository mdr = _conf.getMetaDataRepositoryInstance();</span>
<span class="nc" id="L903">            mdr.setValidate(MetaDataRepository.VALIDATE_RUNTIME, true);</span>
<span class="nc" id="L904">            mdr.setResolve(MetaDataModes.MODE_MAPPING_INIT, true);</span>

            // Load persistent classes and hook in subclasser
<span class="nc" id="L907">            loadPersistentTypes(AccessController.doPrivileged(J2DoPrivHelper</span>
<span class="nc" id="L908">                .getContextClassLoaderAction()));</span>
<span class="nc" id="L909">            mdr.preload();</span>
        }

        // Get a DataCacheManager instance up front to avoid threading concerns on first call.
        // _conf.getDataCacheManagerInstance();

<span class="nc" id="L915">        InstrumentationManager imgr = _conf.getInstrumentationManagerInstance();</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">        if (imgr != null) {</span>
            // Start all factory level instrumentation
<span class="nc" id="L918">            imgr.start(InstrumentationLevel.FACTORY, this);</span>
        }
<span class="nc" id="L920">    }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>